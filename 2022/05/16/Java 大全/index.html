<!DOCTYPE html>
<html lang="zh-CH">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Muse | Mist":320,"display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JavaSEHashCode 和 equals  hashCode 方法是属于 Obejct 父类，JVM提供给每个对象生成一个 hashCode 值（整数类型）支持该方法是为哈希表提供一些优点 hashCode 的常规协定是：在 Java 应用程序运行期间，在同一对象上调用 hashCode 方法时，必须一致的返回相同整数 hashCode 的存在主要是为了查找的快捷性，如 HashTable、">
<meta property="og:type" content="article">
<meta property="og:title" content="java大全">
<meta property="og:url" content="http://example.com/2022/05/16/Java%20%E5%A4%A7%E5%85%A8/index.html">
<meta property="og:site_name" content="Erics Lei">
<meta property="og:description" content="JavaSEHashCode 和 equals  hashCode 方法是属于 Obejct 父类，JVM提供给每个对象生成一个 hashCode 值（整数类型）支持该方法是为哈希表提供一些优点 hashCode 的常规协定是：在 Java 应用程序运行期间，在同一对象上调用 hashCode 方法时，必须一致的返回相同整数 hashCode 的存在主要是为了查找的快捷性，如 HashTable、">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-31%2023.21.10.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-31%2023.33.46.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-31%2023.38.54.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-16%2012.35.51.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-16%2013.02.33.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-25%2023.27.41.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-25%2023.31.19.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2000.12.51.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2000.27.43.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2000.29.44.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2000.53.08.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2012.13.21.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2000.09.03.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2000.21.26.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2000.34.39.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2010.19.09.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2012.27.58.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2012.53.08.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2012.59.00.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-05-16%2016.50.24.png?token=ARRLFGH3DQ3MZUZZD72INC3EN42UC">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-29%2023.05.39.png">
<meta property="og:image" content="http://example.com/Users/lei/Desktop/Typora%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%B1%8F2022-05-17%2022.07.02.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-01%2023.50.11.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-01%2023.43.05.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-17%2022.57.17.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-18%2001.06.42.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-18%2017.31.12.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-18%2020.51.00.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-07-17%2001.35.23.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-07-19%2000.32.10.png">
<meta property="og:image" content="http://example.com/Users/lei/Desktop/Typora%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%B1%8F2022-06-23%2015.06.32.png">
<meta property="og:image" content="http://example.com/Users/lei/Desktop/Typora%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%B1%8F2022-06-23%2019.41.03.png">
<meta property="og:image" content="http://example.com/Users/lei/Desktop/Typora%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81.png">
<meta property="og:image" content="http://example.com/Users/lei/Desktop/Typora%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%B1%8F2022-06-07%2014.14.00.png">
<meta property="og:image" content="http://example.com/Users/lei/Desktop/Typora%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%B1%8F2022-06-07%2014.17.53.png">
<meta property="og:image" content="http://example.com/Users/lei/Desktop/Typora%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%B1%8F2022-06-07%2014.24.03.png">
<meta property="og:image" content="http://example.com/Users/lei/Desktop/Typora%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E6%88%AA%E5%B1%8F2022-06-07%2014.32.55.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-10%2000.09.49.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-10%2018.10.21.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-03%2009.58.50.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-03%2010.18.12.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-04%2001.00.29.png">
<meta property="article:published_time" content="2022-05-16T06:24:32.979Z">
<meta property="article:modified_time" content="2023-08-09T16:45:02.734Z">
<meta property="article:author" content="Erics Lei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-31%2023.21.10.png">

<link rel="canonical" href="http://example.com/2022/05/16/Java%20%E5%A4%A7%E5%85%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CH'
  };
</script>

  <title>java大全 | Erics Lei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/EricsLei" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Erics Lei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">pursuit knowledge</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">8</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CH">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/Java%20%E5%A4%A7%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Erics Lei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Erics Lei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java大全
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-16 14:24:32" itemprop="dateCreated datePublished" datetime="2022-05-16T14:24:32+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-10 00:45:02" itemprop="dateModified" datetime="2023-08-10T00:45:02+08:00">2023-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="HashCode-和-equals"><a href="#HashCode-和-equals" class="headerlink" title="HashCode 和 equals"></a>HashCode 和 equals</h2><blockquote>
<ul>
<li>hashCode 方法是属于 Obejct 父类，JVM提供给每个对象生成一个 hashCode 值（整数类型）<br>支持该方法是为哈希表提供一些优点</li>
<li>hashCode 的常规协定是：<br><strong>在 Java 应用程序运行期间，在同一对象上调用 hashCode 方法时，必须一致的返回相同整数</strong></li>
<li>hashCode 的存在主要是为了查找的快捷性，如 HashTable、HashMap 等<br><strong>hashCode 是用来在散列存储结构中确定对象的存储地址的</strong></li>
<li>如果 equals 方法相等，那么 hashCode 一定相等，如果 hashCode 值相等<strong>不代表 equals 方法一定相等</strong></li>
<li>如果类中重写了 equals 方法，那么必须也要重写 hashCode 方法</li>
</ul>
</blockquote>
<h3 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote>
<p>HashCode 值的生成规则是对象的堆内存地址转化为整数类型</p>
</blockquote>
<p><strong>父类 hashCode 的调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> o1;</span><br><span class="line"><span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(o1.hashCode());</span><br><span class="line">System.out.println(o2.hashCode());</span><br><span class="line">System.out.println(o3.hashCode());</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 692404036</span></span><br><span class="line"><span class="comment">// 692404036</span></span><br><span class="line"><span class="comment">// 1554874502</span></span><br></pre></td></tr></table></figure>



<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><blockquote>
<p>两个对象 HashCode 值相同不代表这两个对象是相同的</p>
<p>如果两个对象的哈希值相同，但是值不同，称之为<strong>哈希冲突</strong></p>
</blockquote>
<p><strong>相同的 String 值的 HashCode</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ss&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ss&quot;</span>;</span><br><span class="line">System.out.println(s1.hashCode());</span><br><span class="line">System.out.println(s2.hashCode());</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 3680</span></span><br><span class="line"><span class="comment">// 3680</span></span><br></pre></td></tr></table></figure>



<p><strong>整数类型的 HashCode 就是该数值, 以下是经典哈希冲突案例</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-31%2023.21.10.png" style="zoom: 50%">





<h4 id="重写-hashCode-和-equals"><a href="#重写-hashCode-和-equals" class="headerlink" title="重写 hashCode 和 equals"></a>重写 hashCode 和 equals</h4><blockquote>
<p>重写 equals 方法就必须重写 hashCode 方法</p>
<p>因为不能违背 hashCode 不同两个对象一定不同的设计准则</p>
</blockquote>
<p><strong>声明一个 Student 类，重写 equals 方法但是没重写 hashCode 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 先判断地址，相同返回 true</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="comment">// 下面这个比较蕴含很多知识</span></span><br><span class="line">        <span class="comment">// String 重写了 equals 所以我们可以直接用，而整数类型包装类的 hashCode 就是其值本身，所以直接用 ==</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.name.equals(s.name) &amp;&amp; <span class="built_in">this</span>.age == s.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用类及输出如下</strong><br>由于我们重写的 equals 方法只判断了成员属性，没有重写 hashCode 方法，导致了equals 相同但是 hashCode 不同<br>是不符合设计规范的，所以应该重写 hashCode</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-31%2023.33.46.png">



<p><strong>重写hashCode</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 先判断地址，相同返回 true</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.name.equals(s.name) &amp;&amp; <span class="built_in">this</span>.age == s.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-31%2023.38.54.png">







<h2 id="栈帧链"><a href="#栈帧链" class="headerlink" title="栈帧链"></a>栈帧链</h2><h2 id="Objec"><a href="#Objec" class="headerlink" title="Objec"></a>Objec</h2><blockquote>
<ul>
<li>Object 是类的结构根</li>
<li>如果我们写的类在没有继承其他类的情况下，默认间接继承了 Object 类</li>
</ul>
</blockquote>
<h3 id="Object-主要方法"><a href="#Object-主要方法" class="headerlink" title="Object 主要方法"></a>Object 主要方法</h3><blockquote>
<ul>
<li>无参构造方法（Object 类的代码中没有写，是默认的）<br>Object 没有有参构造方法</li>
<li>clone ：复制对象</li>
<li>equals</li>
<li>finalize ：JVM垃圾回收机制会用到</li>
<li>getClass：获得该对象的class</li>
<li>hashCode：</li>
<li>notify、notifyAll、wait：多线程之间的通信</li>
<li>toString ：返回对象的字符串表示形式</li>
</ul>
</blockquote>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类和和对象的特点"><a href="#类和和对象的特点" class="headerlink" title="类和和对象的特点"></a>类和和对象的特点</h2><h3 id="对象的内存"><a href="#对象的内存" class="headerlink" title="对象的内存"></a>对象的内存</h3><p>运行如下代码，在内存中会发生什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// 0</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// 1</span></span><br><span class="line">        student.name = <span class="string">&quot;Erics&quot;</span>; <span class="comment">// 2</span></span><br><span class="line">        student.age = <span class="number">20</span>; <span class="comment">// 2</span></span><br><span class="line">        student.selfIntroduction(); <span class="comment">//3 </span></span><br><span class="line">&#125; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ol start="0">
<li>main 方法运行时会压入栈内存</li>
<li>new 出来的对象会存放在堆内存并返回一个内存地址，该对象的属性都会给默认值<br>而 student 存在于栈内存，存放的是对象在堆内存的地址（即引用）</li>
<li>student 指向堆内存地址，当调用它时就会直接找到堆内存并对对象的属性进行赋值操作</li>
<li>将 selfIntroduction() 方法压栈，进行操作，结束后出栈</li>
<li>main 方法出栈，程序运行结束</li>
</ol>
<h4 id="成员变量访问内存图"><a href="#成员变量访问内存图" class="headerlink" title="成员变量访问内存图"></a>成员变量访问内存图</h4><blockquote>
<p>如下图所示(借鉴了黑马教程的图)</p>
<ul>
<li>首先内存中会出现一个Java的JVM</li>
<li>然后加载java文件时首先将Student这个类以.class形式加载到方法区，方法区中会有一个静态区域是存放static修饰的成员</li>
<li>main方法也在静态区，但比较特殊，main方法会被提取到方法栈中，之后开始执行main方法</li>
<li>main方法的前两句是调用类的静态成员变量，会直接到静态区去拿值</li>
<li>声明对象时，会在堆内存中创建对象主题，为成员变量赋默认值，并给出地址，注意，static修饰的变量不在当中<br>并且在方法栈中会有一个空间存放堆内存中对象的引用，也就是地址</li>
<li>通过对象调用成员变量时会通过方法栈中的对象引用找到堆内存的具体地址，然后调用</li>
<li>如果是通过对象调用静态变量，那么会首先去堆内存中找，找不到再去方法区中的静态区中找</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-16%2012.35.51.png">





<h4 id="成员方法访问内存图"><a href="#成员方法访问内存图" class="headerlink" title="成员方法访问内存图"></a>成员方法访问内存图</h4><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-16%2013.02.33.png">













<h3 id="类的成分"><a href="#类的成分" class="headerlink" title="类的成分"></a>类的成分</h3><blockquote>
<p>类中有且<strong>仅有</strong>五大成分</p>
<ul>
<li><strong>成员变量（Field）</strong><br>描述类和对象的属性信息的</li>
<li><strong>成员方法（Method）</strong><br>描述类或者对象的行为信息</li>
<li><strong>构造器（Construct）</strong><br>初始化一个类的对象并返回引用</li>
<li><strong>代码块</strong></li>
<li><strong>内部类</strong></li>
</ul>
</blockquote>
<h2 id="权限和方法"><a href="#权限和方法" class="headerlink" title="权限和方法"></a>权限和方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<ol>
<li>如果没有定义构造方法，系统将提供一个默认的<strong>无参构造方法</strong></li>
<li>如果提供了构造方法，系统将不再提供默认的构造方法<br>所以如果定义了有参构造方法，但是还会用到无参构造方法，就需要自己定义一下</li>
</ol>
</blockquote>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><blockquote>
<p>private 修饰的成员变量只能在该对象内被访问<br>即要想对 private 变量进行操作，需要提供 get 和 set 方法</p>
</blockquote>
<p>这句话应该大家都不陌生，但是很多时候不是特别理解，比如 private 和 public 修饰的成员变量在赋值时的不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public 修饰</span></span><br><span class="line">student.name = <span class="string">&quot;Erics&quot;</span>;</span><br><span class="line"><span class="comment">// private 修饰</span></span><br><span class="line">student.setName(<span class="string">&quot;Erics&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>初看上述对比并不是特别理解真正的区别在哪，感觉上不都是写一行代码提供一个字符串然后给对象赋值<br>其实，这两个点的不同就体现在 set 方法上，例如我可以对 set 方法进行如下改造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt; <span class="number">120</span> || age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;age is wrong&quot;</span>);        </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 set 方法对 age 进行了判断，这样用户在输入 age 时就不可以输入小于0 或大于120的明显错误年龄</p>
<p>这就体现了 private 的作用了，private 并不是许多老师口中的 “看不见” 或者简简单单说一句 “私有” 就可以理解的，要进一步解释私有的含义：<strong>即对象外不可以随意的对对象的私有属性赋值</strong>，必须满足 set 方法也就是该对象对于其私有属性的规定即可赋值，而不是说对象不想从对象外进行赋值</p>
<p>这种中间添加一层的思想广泛应用于各种设计模式。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><blockquote>
<p>this 用于指代当前被调用的类的对象<br>如果当前类的方法的形参（局部变量）没有和类的成员变量相同的，那么可以不用加 this 区分，默认指向的就是成员变量，如果有相同的，则默认指向形参，如果想调用成员变量，需要加 this 区分。</p>
<p><strong>this 存放的就是被调用对象的地址</strong></p>
</blockquote>
<p>this 的使用细节：<br>this 可以在构造方法中调用：this(参数列表)，只能在构造器中这么用，即只能在一个构造器中访问另外一个构造器<br>且 this 必须放在第一行：</p>
<p><strong>正确：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-25%2023.27.41.png">

<p><strong>错误</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-25%2023.31.19.png">





<h3 id="super-和继承"><a href="#super-和继承" class="headerlink" title="super 和继承"></a>super 和继承</h3><blockquote>
<p>和 this 相似，不过代表的是父类存储空间的标识（可以理解为父类对象的引用）</p>
</blockquote>
<h4 id="super-访问父类的成员变量"><a href="#super-访问父类的成员变量" class="headerlink" title="super 访问父类的成员变量"></a>super 访问父类的成员变量</h4><ul>
<li><p>父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问本方法内的 age &quot;</span> + age); <span class="comment">// 22</span></span><br><span class="line">        System.out.println(<span class="string">&quot;访问当前类的 age&quot;</span> + <span class="built_in">this</span>.age); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="string">&quot;访问父类的 age&quot;</span> + <span class="built_in">super</span>.age); <span class="comment">// 18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="super-访问父类的构造方法"><a href="#super-访问父类的构造方法" class="headerlink" title="super 访问父类的构造方法"></a>super 访问父类的构造方法</h4><ul>
<li><p>父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在 main 方法中分别调用 student 类的无参和有参构造方法，结果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2000.12.51.png">



<blockquote>
<p>所以可以得结论：</p>
<ol>
<li>子类中的所有构造方法默认都会访问父类中的无参构造方法</li>
<li>因为子类会继承父类中的数据，可能还会使用父类的数据，所以在子类初始化之前需要对父类进行初始化</li>
<li>每个子类的构造方法第一行默认都是 super()</li>
</ol>
<p>所以如果父类没有无参构造方法且只有有参构造方法，子类就会报错，因为子类如果没有用 super 显示调用父类的构造方法，默认都是调用父类的无参构造方法，而父类如果只有有参构造方法，便不会默认生成无参构造方法，所以就会报错。以此类推，父类如果啥也没，一片空白，那么子类初始化就不会报错，因为父类会默认生成无参构造方法。如下图：</p>
</blockquote>
<p><strong>父类只有有参构造方法</strong></p>
<ul>
<li><p>父类如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类不用 super 关键字会报错</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2000.27.43.png">

<ul>
<li>子类用 super 关键字显示调用父类构造方法则不会报错</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2000.29.44.png">



<p><strong>父类什么构造方法也没有</strong></p>
<ul>
<li><p>父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类不用 super 也不会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="super-访问父类成员方法"><a href="#super-访问父类成员方法" class="headerlink" title="super 访问父类成员方法"></a>super 访问父类成员方法</h4><blockquote>
<ol>
<li>先查找子类中的成员方法</li>
<li>如果子类没有，才会去父类中调用方法</li>
</ol>
</blockquote>
<ul>
<li>父类</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是父类的show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是子类的show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用子类的 show 输出：</span></span><br><span class="line"><span class="comment">//我是父类的show</span></span><br><span class="line"><span class="comment">//我是子类的show</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><blockquote>
<p>子类出现了和父类一模一样的方法就是重写</p>
<p>重写存在的意义就是父类功能的延续，在原有基础上功能的拓展</p>
</blockquote>
<h4 id="重写的意义"><a href="#重写的意义" class="headerlink" title="重写的意义"></a>重写的意义</h4><ul>
<li><p>父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的功能是语音电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;我的新功能是视频电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Override-及重写的注意事项"><a href="#Override-及重写的注意事项" class="headerlink" title="@Override 及重写的注意事项"></a>@Override 及重写的注意事项</h4><blockquote>
<ul>
<li>重写的方法的方法名和参数列表必须和父类一致</li>
<li>父类中的私有方法子类是没有办法重写的</li>
<li>子类的方法访问权限不能比父类低（public &gt; default &gt; private)<br>但是可以高</li>
</ul>
</blockquote>
<p><strong>重写的方法的方法名和参数列表必须和父类一致</strong></p>
<ul>
<li><p>父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的功能是语音电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2000.53.08.png" style="zoom:70%">





<p><strong>父类中的私有方法子类是没有办法重写的</strong></p>
<p><strong>子类的方法访问权限不能比父类低（public &gt; default &gt; private)</strong></p>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table>
<thead>
<tr>
<th>权限修饰符</th>
<th>同一个类</th>
<th>同一个包</th>
<th>不同包子类</th>
<th>不同包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>&amp;check;</td>
<td>&amp;cross;</td>
<td>&amp;cross;</td>
<td>&amp;cross;</td>
</tr>
<tr>
<td>default</td>
<td>&amp;check;</td>
<td>&amp;check;</td>
<td>&amp;cross;</td>
<td>&amp;cross;</td>
</tr>
<tr>
<td>protected</td>
<td>&amp;check;</td>
<td>&amp;check;</td>
<td>&amp;check;</td>
<td>&amp;cross;</td>
</tr>
<tr>
<td>public</td>
<td>&amp;check;</td>
<td>&amp;check;</td>
<td>&amp;check;</td>
<td>&amp;check;</td>
</tr>
</tbody></table>
<h3 id="package-、import"><a href="#package-、import" class="headerlink" title="package 、import"></a>package 、import</h3><blockquote>
<p>包的作用是实现对类的分类管理</p>
<p>类的名称如何组成：包的名称 + 类的名称组合 – 保证唯一不允许重复（类的全限定名）</p>
<p>如果直接在 src 目录下创建的类是没有任何包的名称的</p>
</blockquote>
<p>使用不同包的类的时候需要使用该类的全限定名，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.Erics.test.<span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.Erics.test.Parent();</span><br></pre></td></tr></table></figure>

<p>这明显是麻烦的，代码冗余，所以可以使用 import 将该类导入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.Erics.test.Parent;</span><br></pre></td></tr></table></figure>

<p>如果该包下大多类都用到了，那么也可以把整个包都导入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.Erics.test.*;</span><br></pre></td></tr></table></figure>

<p>如果导入的包的类名和当前包的类名是一样的，java会优先使用当前包的类名，要使用其他包的相同名的类，需要在类名面前加上包名</p>
<h3 id="fianl-和-static"><a href="#fianl-和-static" class="headerlink" title="fianl 和 static"></a>fianl 和 static</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><blockquote>
<p><strong>fianl（最终态）</strong></p>
<ul>
<li>fianl 定义的变量是常量，是不能被修改的</li>
<li>被 final 修饰的类是无法被继承的</li>
<li>被 fianl 修饰的成员方法是无法被重写的</li>
<li>被 final 修饰的成员变量是无法被修改的，必须被初始化（手动赋值）</li>
</ul>
</blockquote>
<p>使用 final 修饰局部变量，如果该变量是基本数据类型，则不能被修改<br>但是如果 final 修饰的是一个引用类型（对象），那么引用地址的值是不能被修改的，但是里面的属性可以修改</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-27%2012.13.21.png" style="zoom:60%">





<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><blockquote>
<p><strong>static（静态）</strong></p>
<p>可以修饰成员方法、成员变量，其特点是 static 修饰的会被类的所有对象共享访问</p>
<p><strong>static 访问特点</strong></p>
<p>非静态成员方法</p>
<ol>
<li>能够访问静态的成员变量</li>
<li>能够访问非静态的成员变量</li>
<li>能访问静态的成员方法</li>
<li>能访问非静态的成员方法</li>
</ol>
<p>静态的成员方法</p>
<ol>
<li>能访问静态的成员变量，但是不能直接访问成员变量</li>
<li>能访问静态成员方法，但是不能直接访问成员方法</li>
</ol>
<p><strong>static 使用场景</strong></p>
<p>一句话描述： 方便在没有对象的情况下进行调用（方法、变量）<br>被 static 修饰的成员或方法不需要依赖对象进行访问，只要类被加载了就可以通过类名去进行访问</p>
<p>另外也可以通过编写 static 代码块来优化程序性能</p>
</blockquote>
<p><strong>Child 类继承 Parent 类，父类中 name 属性是 public 修饰，School 属性是 static 修饰，看如下代码输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryOfObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">child1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        child1.name = <span class="string">&quot;c1&quot;</span>;</span><br><span class="line">        child1.school = <span class="string">&quot;school1&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        child2.name = <span class="string">&quot;c2&quot;</span>;</span><br><span class="line">        child2.school = <span class="string">&quot;school2&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(child1.name + <span class="string">&quot; &quot;</span> + child1.school);</span><br><span class="line">        System.out.println(child2.name + <span class="string">&quot; &quot;</span> + child2.school);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// c1 school2</span></span><br><span class="line"><span class="comment">// c2 school2</span></span><br></pre></td></tr></table></figure>

<p>上图可以清晰的反映出 static 修饰的变量的访问特点，且也表达了 static 变量的一个重要作用，就是将多个对象的共同属性只进行一次赋值即可，不用多次赋值，比如对同一所大学的学生赋学校名称时只需要对类赋一次就好，其作用和 final 很相似，但是又有不同，final 进行一次初始化之后就无法更改，但是 static 是可以灵活赋值的，更适合初始化不同大学的学生信息这一场景。</p>
<h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h3><blockquote>
<ul>
<li>main 方法是JVM 调用的</li>
<li>JVM 需要调用 main 方法，所以该方法必须是 public 修饰，因为调用的时候 JVM 和 main 方法不在同一个类</li>
<li>JVM 执行 main 方法的时候不必创建对象，所以该方法必须是 static</li>
<li>main 方法接受 String 类型的数组参数，该数组中保存执行 java 命令时传递给所执行类的参数</li>
</ul>
<p><strong>main 方法使用细节</strong></p>
<ul>
<li>因为 main 方法是 static 的，所以可以i直接访问本类的静态成员</li>
<li>访问本类的非静态成员需要先创建对象再调用</li>
</ul>
</blockquote>
<p><strong>解析 public static void main（String[] args）中 args是什么</strong></p>
<ul>
<li><p>被调用类方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>终端进入该类的目录执行 (注意该类不要带包名，否则 java 命令失效)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding UTF-8 Parent.java</span><br></pre></td></tr></table></figure>

<p>目录会出现该类同名的 class 文件</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2000.09.03.png">

<ul>
<li><p>再执行 java 命令并加入参数运行该类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java Parent // 不带参数</span><br><span class="line">java Parent arg1 arg2 arg3 // 带参数</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2000.21.26.png">



<p> <strong>如何在 idea 中添加运行类时的 main 方法参数注入</strong></p>
<ol>
<li>先运行类，运行后在右上角运行标识旁边会出现该类的启动配置</li>
<li>进入启动配置，在 Program Arguments 那一栏添加参数即可</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2000.34.39.png" style="zoom: 50%">





















<h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><blockquote>
<p>面向对象（oop）三大基本特征：封装、继承、多态</p>
<ul>
<li><p>封装<br>把客观事物封装成抽象的类，并且可以把自己的数据和方法只让可信的类或对象操作<br>而一般来说，给成员变量添加权限修饰符，添加 get set 方法就是封装的流程</p>
</li>
<li><p>继承<br>子类继承父类的属性和方法</p>
</li>
<li><p>多态</p>
<p>同一个对象在不同时刻表现出来的不同形态</p>
</li>
</ul>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<p><strong>封装的作用</strong>：</p>
<ol>
<li>提高安全性</li>
<li>实现组件化（例如用get和set两个体系操作成员变量）</li>
</ol>
<p><strong>封装的规范</strong>：</p>
<ol>
<li>建议成员变量私有（private修饰）<br>private修饰的方法、成员变量、构造器等，只能在本类直接访问</li>
<li>提供成套的getter + setter方法暴露成员变量的取值和赋值（public修饰）<br>public修饰符是公开的意思</li>
</ol>
<p><strong>小结</strong>：<br>封装的核心思想：合理隐藏、合理暴露<br>封装已经成为Java代码的风格，即使代码毫无意义，还是要按照封装的规范去写</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p><strong>优点</strong></p>
<ul>
<li>提高了代码的复用性</li>
<li>提高了代码的维护性</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>继承让类与类之间产生了关系，耦合度增加，当父类变化时子类也要变，降低了子类的独立性</li>
</ul>
<p><strong>继承中的变量访问特点</strong></p>
<ul>
<li>当在子类方法中访问一个变量：<ol>
<li>首先会访问当前方法局部</li>
<li>其次在当前子类的成员属性范围查找</li>
<li>最后在父类成员属性中查找</li>
</ol>
</li>
</ul>
<p><strong>继承的注意事项</strong></p>
<ul>
<li>java 中的类只支持单继承，不支持多继承（一个子类不能有两个父类）</li>
<li>java 支持多层继承（孙子类可以直接继承使用爷爷类的public 方法的）</li>
</ul>
</blockquote>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote>
<p><strong>多态的前提和体现</strong></p>
<ol>
<li>有继承(abstract)、实现(implments)关系，所以多态一定发生在两个或两个类以上的场景</li>
<li>方法重写</li>
<li>有父类引用指向子类对象</li>
</ol>
<p><strong>多态的访问特点</strong></p>
<ul>
<li>成员变量：编译看左边，执行看左边</li>
<li>成员方法：编译看左边，执行看右边</li>
<li>这是因为成员方法有重写的概念，而成员变量没有</li>
</ul>
<p><strong>多态的优点</strong></p>
<ul>
<li>提高了程序的扩展性</li>
</ul>
<p><strong>多态的缺点</strong></p>
<ul>
<li>不能使用子类的独有功能</li>
</ul>
</blockquote>
<p><strong>一个例子体现多态，即一个方法在不同场景实现不同功能，且能体现其访问特点</strong></p>
<ul>
<li><p>父类 Animal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;animal&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal 都有吃的能力&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类 Cat 和 Dog 继承自 Animal，分别重写父类的 eat 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalDog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;dog&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog 有吃的能力&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalCat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;cat&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat 有吃的能力&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在调用时，new 子类的时候用父类去接，并调用 eat 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryOfObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalDog</span>();</span><br><span class="line">        animal1.eat();</span><br><span class="line">        System.out.println(animal1.name);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalCat</span>();</span><br><span class="line">        animal2.eat();</span><br><span class="line">        System.out.println(animal2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// dog 有吃的能力</span></span><br><span class="line"><span class="comment">// dog</span></span><br><span class="line"><span class="comment">// animal</span></span><br><span class="line"><span class="comment">// cat 有吃的能力</span></span><br><span class="line"><span class="comment">// cat</span></span><br><span class="line"><span class="comment">// animal</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多态的优缺点"><a href="#多态的优缺点" class="headerlink" title="多态的优缺点"></a>多态的优缺点</h4><ul>
<li><p>父类 Animal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个子类,重写父类方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalDog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalCat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作类，用父类作为接受参数，并调用 eat 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalOperate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userAnimal</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用操作类的方法，看返回结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryOfObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnimalOperate</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalOperate</span>();</span><br><span class="line">        operate.userAnimal(<span class="keyword">new</span> <span class="title class_">AnimalDog</span>());</span><br><span class="line">        operate.userAnimal(<span class="keyword">new</span> <span class="title class_">AnimalCat</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// i am dog</span></span><br><span class="line"><span class="comment">// i am cat</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述例子体现了多态的优势，在 operate 类中我们利用多态只用一个方法就完成了调用不同子类的各自的方法，如果不用多态，想实现类似的功能，需要编写的代码如下，然后每次添加新的子类的时候还需要添加新的代码，代码冗余。但是这也不能万能的，比如如果子类 dog 有一个自己独有的功能，那么通过多态是无法调用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalOperate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dog</span><span class="params">(AnimalDog dog)</span> &#123;</span><br><span class="line">        dog.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dog</span><span class="params">(AnimalCat cat)</span> &#123;</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="多态的转型"><a href="#多态的转型" class="headerlink" title="多态的转型"></a>多态的转型</h4><blockquote>
<ol>
<li>向上转型（多态的机制）<br>从子到父<br>父类引用指向子类对象<br>向上转型就是基本的多态的使用方法，new 出来的对象由父类去接受，父类指向子类</li>
<li>向下转型（强转）<br>从父到子<br>父类引用转为子类对象</li>
</ol>
</blockquote>
<p><strong>一张图解释什么是向上、向下转型</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2010.19.09.png">









<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="abstarct-抽象类"><a href="#abstarct-抽象类" class="headerlink" title="abstarct 抽象类"></a>abstarct 抽象类</h3><blockquote>
<p><strong>问题引入</strong></p>
<p>在学习多态的时候我们使用的是 Animal、Cat、Dog 的例子，那个例子是有一点不好的，那就是父类 Animal 中的 eat 方法我们是实现了的，并且我们可以直接通过 new Animal 的方式去调用这个 eat 方法，而从逻辑上，Animal 类在未声明是什么具体的种类的时候，是不应该能被声明出来且调用 eat 方法的，这个时候引入抽象类可以解决该问题。</p>
</blockquote>
<blockquote>
<p><strong>抽象类特点</strong></p>
<ul>
<li>在 Java 中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类<br>(没有方法体的意思是连大括号都没有)</li>
<li>抽象类中不一定要有抽象方法，但是有抽象方法的类必须是抽象类</li>
<li>抽象类不能被实例化</li>
<li>子类必须对父类（抽象类）中的所有抽象方法进行重写</li>
<li>抽象类中可以定义非抽象方法</li>
<li>子类如果不重写抽象类中的方法，则该类还是抽象类</li>
<li>抽象类中可以有初始化方法，用于子类访问父类时的数据初始化</li>
</ul>
</blockquote>
<p><strong>抽象类声明及调用</strong></p>
<ul>
<li><p>抽象类父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no args construction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String N)</span> &#123;</span><br><span class="line">        name = N;</span><br><span class="line">        System.out.println(<span class="string">&quot;args construction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类非抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dogs like eating bonds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类如果是抽象类则不必重写父类的抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>abstract 关键字不能和哪些关键字共存</strong></p>
<ol>
<li><strong>private</strong><br>如果父类的抽象方法是 private，那么就不能被继承，那子类就没办法被重写</li>
<li><strong>final</strong><br>static 修饰的方法、变量都不能被修改，也就不能被重写</li>
<li><strong>static</strong><br>无意义，static 是静态的，abstract 方法无方法体，无法调用</li>
</ol>
</blockquote>
<h3 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface 接口"></a>interface 接口</h3><blockquote>
<ul>
<li>接口就是一种公共规范标准，只要符合规范标准，大家都可以通用</li>
<li>Java 中的接口更多的体现在对行为的抽象</li>
</ul>
</blockquote>
<blockquote>
<p><strong>接口定义及实现的特点</strong></p>
<ul>
<li>和抽象类一样，接口的实现类也要实现接口的所有方法</li>
<li>如果实现类用 abstract 修饰就不用实现接口的方法啊<br>且该抽象类可以继续被继承</li>
</ul>
</blockquote>
<ul>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnimalCat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类的子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JiaFeiCat</span> <span class="keyword">extends</span> <span class="title class_">AnimalCat</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jiafei cat eats fish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">app</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JiaFeiCat</span>();</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上实例生成的类图</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2012.27.58.png">



<blockquote>
<p><strong>接口成员变量访问特点</strong></p>
<ul>
<li>成员变量只能是常量<br>默认修饰符：public static final</li>
<li>成员方法只能是抽象方法<br>默认修饰符：public abstract</li>
<li>接口没有构造方法<br>因为接库主要是对行为进行抽象，没有具体存在<br>一个类如果没有父类默认继承自 Object 类，所以实现类的无参构造方法第一行的默认的那个 super 会先调用 Object 的无参构造方法</li>
<li>jdk 8 开始可以在接口中定义非抽象方法，需要使用 default 关键字修饰,且默认加上 public 修饰</li>
</ul>
</blockquote>
<p><strong>在 idea 中，如果重复写了默认修饰符就会显示灰色，提示多余</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2012.53.08.png" style="zoom: 80%">



<p><strong>接口中定义非抽象方法</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-28%2012.59.00.png" style="zoom: 80%">







<h3 id="抽象类和接口案例"><a href="#抽象类和接口案例" class="headerlink" title="抽象类和接口案例"></a>抽象类和接口案例</h3><blockquote>
<p>需求：<br>对猫和狗进行训练他们就可以跳高了，使用接口和抽象类实现</p>
<p>分析：<br>抓住抽象类的整体抽象功能和接口的行为抽象功能，将行为跳高声明在接口中，然后抽象类去实现跳高接口，并定义好 animal 的抽象特征，拥有无参和有参构造器，最后再声明具体的类</p>
</blockquote>
<p><strong>接口定义跳这个行为</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Jump</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象类实现接口并定义动物自己的方法和成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Jump</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">selfIntro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JumpDog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JumpDog</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JumpDog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =  name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog can jump 2 meter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selfIntro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my name is &quot;</span> + name + <span class="string">&quot; my age is &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">app</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jump</span> <span class="variable">jump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JumpCat</span>(<span class="string">&quot;cat&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        jump.jump();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JumpDog</span>(<span class="string">&quot;wangcai&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        dog.selfIntro();</span><br><span class="line">        dog.jump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// cat can jump 1 meter</span></span><br><span class="line"><span class="comment">// my name is wangcai my age is 2</span></span><br><span class="line"><span class="comment">// dog can jump 2 meter</span></span><br></pre></td></tr></table></figure>







<h3 id="类和接口的区别"><a href="#类和接口的区别" class="headerlink" title="类和接口的区别"></a>类和接口的区别</h3><blockquote>
<ul>
<li>类和类的继承关系<br>继承关系只能单继承，但是可以多层继承</li>
<li>类和接口的实现关系<br>实现关系可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>
<li>接口和接口的继承关系<br>一个接口可以继承一个接口也可以继承多个接口</li>
</ul>
</blockquote>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><blockquote>
<ul>
<li>成员区别<ol>
<li>抽象类：可以有常量、变量；有构造方法；有抽象方法也有非抽象方法</li>
<li>接口：只有常量和抽象方法（jdk 8 后可以定义非抽象方法）</li>
</ol>
</li>
<li>关系区别<ol>
<li>类与类：继承，单继承</li>
<li>类与接口：实现，单实现和多实现</li>
<li>接口与接口：继承，单继承与多继承</li>
</ol>
</li>
<li><strong>设计区别</strong><ol>
<li>抽象类是对类的抽象，包括属性行为（对事物的抽象）</li>
<li>接口对行为抽象，主要是行为（对行为的抽象）</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>关于接口和抽象类的设计区别</strong></p>
</blockquote>
<p>使用门锁功能的例子来进一步解释他们之间的设计区别，假设现在有两款门，一个是电子门，一个是传统机械门，他们都具有一些作为门的基础属性，比如长宽高，也有一些门的共有的功能，比如自动开门和关门，但是电子门有一个额外功能就是带报警功能，那么怎么设计呢？如果定义一个抽象类，里面有开门关门报警的方法，并且有长宽高等属性，是不合适的，因为其子类必须重写所有功能，但是机械门是没有报警功能的，如果定义一个接口去实现更不合适了，不光解决不了上述问题，而且其属性都是常量无法修改，那么就可以采用下面的经典方案：</p>
<ul>
<li>定义一个 Alarm 接口声明 alarm 功能</li>
<li>定义一个 Door 抽象类声明各种门的基础属性和功能</li>
<li>机械门只需要继承 Door 抽象类即可</li>
<li>电子门除了继承 Door 抽象类还需要实现 Alarm 接口</li>
</ul>
<p><strong>定义一个接口，里面有报警功能（对行为的抽象）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">alarm</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义抽象类（对事物的抽象）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Door</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Door</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>机械门子类继承抽象类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JXDoor</span> <span class="keyword">extends</span> <span class="title class_">Door</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JXDoor</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>电子门子类继承抽象类并且实现接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DZDoor</span> <span class="keyword">extends</span> <span class="title class_">Door</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DZDoor</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">alarm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; alarm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">app</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DZDoor</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DZDoor</span>(<span class="string">&quot;电子门&quot;</span>);</span><br><span class="line">        door.open();</span><br><span class="line">        door.alarm();</span><br><span class="line">        <span class="type">Door</span> <span class="variable">door1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JXDoor</span>(<span class="string">&quot;机械门&quot;</span>);</span><br><span class="line">        door1.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 电子门 open</span></span><br><span class="line"><span class="comment">// 电子门 alarm</span></span><br><span class="line"><span class="comment">// 机械门 open</span></span><br></pre></td></tr></table></figure>









<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote>
<p>在一个类中定义一个类就是内部类 </p>
</blockquote>
<blockquote>
<p><strong>内部类的访问特点</strong></p>
<ul>
<li>内部类可以直接访问外部类成员，包括私有的</li>
<li>在外部类要想访问内部类成员必须先实例化</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内部类的分类</strong></p>
<ul>
<li>成员内部类</li>
<li>方法内部类</li>
<li>静态内部类</li>
<li>匿名内部类</li>
</ul>
<p>如果分的不那么细，也可以分为：</p>
<ul>
<li>成员内部类（成员内部类、静态内部类）</li>
<li>局部内部类（方法内部类、匿名内部类）</li>
</ul>
<p><strong>成员内部类和局部内部类区别</strong></p>
<ul>
<li>如果定义在方法里面则是方法内部类或局部内部类</li>
<li>如果定义在方法外面则是成员内部类，如果还加上了 static 修饰就是静态内部类</li>
</ul>
</blockquote>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><blockquote>
<p><strong>在外部访问内部类的成员方法</strong></p>
</blockquote>
<p>成员内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutSideObj</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 声明一个成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsideObj</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am inside object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        OutSideObj.<span class="type">InsideObj</span> <span class="variable">insideObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutSideObj</span>().<span class="keyword">new</span> <span class="title class_">InsideObj</span>();</span><br><span class="line">        insideObj.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>但是在企业开发中，通常内部类是不允许外界访问的<br>所以会把内部类用 private 修饰，但是在外部类里面还是可以 new 出来用的</p>
<p>但是不可以在外部类的 main 方法中访问，因为 static 方法只能直接访问 static 修饰的成员</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutSideObj</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个成员内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InsideObj</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am inside object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InsideObj</span> <span class="variable">insideObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsideObj</span>();</span><br><span class="line">        insideObj.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><blockquote>
<p>有 static 修饰的内部类就是静态内部类 </p>
</blockquote>
<blockquote>
<p>静态内部类的外界访问</p>
</blockquote>
<p>声明静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutSideObj</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InsideObj</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am inside object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 静态内部类可以在 main 方法中直接访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InsideObj</span> <span class="variable">insideObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsideObj</span>();</span><br><span class="line">        insideObj.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>外界调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        OutSideObj.<span class="type">InsideObj</span> <span class="variable">insideObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutSideObj</span>.InsideObj();</span><br><span class="line">        insideObj.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在静态内部类中访问外部成员必须是静态的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutSideObj</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;outside object&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showOut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InsideObj</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            showOut();</span><br><span class="line">            System.out.println(<span class="string">&quot;i am inside object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h3><blockquote>
<p>方法内部类是在方法里面定义的类，所以外界是无法使用的，需要在方法里面创建对象并使用</p>
<p>但是方法内部类是可以直接访问外部类的成员的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutSideObj</span> &#123;</span><br><span class="line">    <span class="comment">// 声明外部类的成员属性和方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;outsideObj&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showOut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showOut&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inside</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 声明一个方法内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InsideObj</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInside</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 方法内部类访问外部类的私有成员</span></span><br><span class="line">                System.out.println(name);</span><br><span class="line">                showOut();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在方法内调用内部类</span></span><br><span class="line">        <span class="type">InsideObj</span> <span class="variable">insideObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsideObj</span>();</span><br><span class="line">        insideObj.showInside();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OutSideObj</span> <span class="variable">outSideObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutSideObj</span>();</span><br><span class="line">        outSideObj.inside();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// outsideObj</span></span><br><span class="line"><span class="comment">// showOut</span></span><br></pre></td></tr></table></figure>





<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><blockquote>
<p>使用匿名内部类就不需要创建<strong>实现类(interface)</strong> 和<strong>子类(abstracr)</strong></p>
<p>直接通过 new 的形式简化创建过程</p>
<p>其使用场景就是在简单实现接口或抽象类的方法的时候不用那么麻烦的先去创建一个子类去继承或实现了</p>
</blockquote>
<p><strong>创建及调用</strong></p>
<p>声明一个接口和一个抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnonymousInter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnonymousObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">showobj</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明使用匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnonymousInter</span> <span class="variable">anonymousInter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousInter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInter</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;show interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">AnonymousObj</span> <span class="variable">anonymousObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousObj</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showobj</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;show abstract&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        anonymousInter.showInter();</span><br><span class="line">        anonymousObj.showobj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>匿名内部类的底层实现原理</p>
<p>以接口为例，在 new InterfaceIml { } 的时候底层实际上为我们创建了实现类来实现接口的方法</p>
</blockquote>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><hr>
<blockquote>
<p>集合的诞生是因为用数组存放多个数据有很多弊端：</p>
<ol>
<li>长度开始时必须指定，而且指定后不可更改</li>
<li>保存的数据必须是同一类型</li>
<li>使用数组进行删除、添加数据会比较麻烦</li>
</ol>
</blockquote>
<blockquote>
<p><strong>集合特点</strong>：</p>
<ol>
<li>可以动态保存任意多个对象</li>
<li>提供了一系列方便的操作对象的方法</li>
<li>使用集合添加、删除新元素很方便</li>
</ol>
<p>本章直接拿几个经典框架开撕源码，跳过基本使用了</p>
</blockquote>
<p>集合分类图</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-05-16%2016.50.24.png?token=ARRLFGH3DQ3MZUZZD72INC3EN42UC">









<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote>
<p>ArrayList 作为集合框架中的经典实现，作为深入集合框架设计理念的的起点是比较合适的</p>
<p><strong>特点</strong></p>
<ul>
<li>顺序容器，即存放顺序和插入顺序相同</li>
<li>允许存放 null 元素，底层通过数组实现</li>
<li>除了没有实现同步外，其他大致与 Vector 相同</li>
</ul>
</blockquote>
<p><strong>类图如下</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-29%2023.05.39.png" style="zoom: 70%">







<h3 id="ArrayList-中的迭代器"><a href="#ArrayList-中的迭代器" class="headerlink" title="ArrayList 中的迭代器"></a>ArrayList 中的迭代器</h3><h3 id="ArrayList-中的泛型"><a href="#ArrayList-中的泛型" class="headerlink" title="ArrayList 中的泛型"></a>ArrayList 中的泛型</h3><h3 id="ArrayList-源码"><a href="#ArrayList-源码" class="headerlink" title="ArrayList 源码"></a>ArrayList 源码</h3><blockquote>
<ul>
<li>基于下标 index 的查找和修改的时间复杂度是 O(1)，效率较高<br>基于元素值去查询时间复杂度是 O(n)</li>
<li>增加和删除的效率很低，因为 ArrayList 的底层是数组，增加和删除都会有数组移动的操作<br>且增加可能还会引起扩容</li>
</ul>
<p>了解以上两点后再去学习 ArrayList 的源码</p>
<p><strong>学习源码的步骤</strong></p>
<ol>
<li>先看构造函数</li>
<li>看方法实现</li>
</ol>
</blockquote>
<h4 id="手写一个简单-ArrayList"><a href="#手写一个简单-ArrayList" class="headerlink" title="手写一个简单 ArrayList"></a>手写一个简单 ArrayList</h4><blockquote>
<p>了解了 ArrayList 的工作机制后，可以先手写一个简单的 ArrayList，再去对比一下 Java 开发者设计的 ArrayList 机制</p>
</blockquote>
<h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><blockquote>
<p><strong>add 方法</strong></p>
<ul>
<li>懒加载，使用时才会加载，且初始化容量是 <strong>10</strong></li>
<li>超过容量大小后会扩容，且按原容量的 <strong>1.5</strong> 倍扩容</li>
</ul>
<p><strong>get 方法</strong></p>
<ul>
<li>只能根据下标去删除</li>
<li>判断传入的下标是否越界后，返回该数组元素</li>
</ul>
<p><strong>remove</strong></p>
<ul>
<li>下标检查后移动</li>
<li>移动的逻辑是先复制即将删除的 index 后面的所有元素，然后从 index 开始赋值，再将最后一位设置为 null</li>
</ul>
</blockquote>
<h3 id="ArrayList-和-vector-的区别"><a href="#ArrayList-和-vector-的区别" class="headerlink" title="ArrayList 和 vector 的区别"></a>ArrayList 和 vector 的区别</h3><blockquote>
<p><strong>相同点</strong></p>
<ul>
<li>ArrayList 和 Vector 都默认初始化容量是 10</li>
<li>底层都是基于数组去实现的</li>
<li>都是 List 接口下的子类</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>ArrayList 线程不安全，Vector 线程安全</li>
<li>ArrayList 扩容是原来的 1.5 倍<br>Vector 默认扩容是原来的 2 倍，且扩容倍数可以设置</li>
<li>ArrayList 是懒加载<br>Vector 是通过构造函数去初始化容量为 10</li>
</ul>
</blockquote>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><blockquote>
<ul>
<li>底层是双向链表</li>
<li>LinkedList 是线程不安全的</li>
<li>元素允许为 null，允许重复元素</li>
<li>插入、删除效率高（如果根据下标来删除，夏绿还是不高的），查找效率低</li>
<li>不存在容量不足的方法，所以没有扩容</li>
<li>LinkedList 还实现了栈和队列的操作方法，因此可以作为栈、队列和双端队列来使用</li>
</ul>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><blockquote>
<ul>
<li>只能按下标 get，或者 get 头节点或尾节点</li>
</ul>
</blockquote>
<h3 id="get-源码"><a href="#get-源码" class="headerlink" title="get 源码"></a>get 源码</h3><blockquote>
<p>一般来说链表的查询是比较耗时的，必须挨个遍历<br>所以 java 优化了 LinkedList 的 get 时候的查找方法 – 二分查找</p>
<p>分成两半：前一半从头往后，后一半从后往前</p>
</blockquote>
<h3 id="remove-源码"><a href="#remove-源码" class="headerlink" title="remove 源码"></a>remove 源码</h3><blockquote>
<p>先找到节点再删除</p>
<p>找到节点的逻辑和 get 一样</p>
</blockquote>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote>
<p><strong>常用方法</strong></p>
<ul>
<li>get</li>
<li>keySet</li>
<li>values</li>
<li>entrySet</li>
<li>getOrDefault</li>
</ul>
<p><strong>HashMap 遍历的三种方式</strong></p>
<ul>
<li>keySet 方法配和 get 方法，增强 for 循环遍历 keySet</li>
<li>entrySet  配合增强 for</li>
<li>entrySet 配合 Iterator 迭代器</li>
</ul>
<p><strong>常见知识点</strong></p>
<ul>
<li>HashMap 的 key 是可以存放 null 的，且存放在 index 为 0 的位置<br>HashTable 的 key 是不能存放 null 的</li>
<li>HashMap 的键值对是怎么封装的？<br>Map 接口定义了一个 Entry 对象，交给了子类来实现</li>
<li>HashMap 集合在 Java 1.7 版本是基于数组+链表实现的<br>在 Java 1.8 版本是通过数组 + 链表 + 红黑树实现</li>
</ul>
</blockquote>
<h3 id="HashMap-的KV封装"><a href="#HashMap-的KV封装" class="headerlink" title="HashMap 的KV封装"></a>HashMap 的KV封装</h3><blockquote>
<ul>
<li>Map 接口定义了一个 Entry 对象，交给了子类来实现</li>
<li>HashMap 的 Entry 是基于单向链表实现的</li>
<li>如果用 ArrayList 来实现 HashMap 那么效率很低，查找效率是O（n）<br>但是也有优点，可以保证有序存放<br>但是 HashMap 不追求有序存放，所以其底层是通过计算 hashCode 值来确定其存放位置</li>
</ul>
</blockquote>
<h3 id="Key-的哈希计算原理"><a href="#Key-的哈希计算原理" class="headerlink" title="Key 的哈希计算原理"></a>Key 的哈希计算原理</h3><blockquote>
<p>int index &#x3D; k.hashCode( ) % entrys.length<br>Entrys[index] &#x3D; new Entry&lt;k,v&gt;</p>
<p>逻辑是如果 k相同，那么其哈希值相同，那么其计算出来的index也相同，那么就可以直接计算出其在entrys数组中的位置</p>
</blockquote>
<h3 id="HashMap-解决哈希冲突"><a href="#HashMap-解决哈希冲突" class="headerlink" title="HashMap 解决哈希冲突"></a>HashMap 解决哈希冲突</h3><blockquote>
<ul>
<li>HashMap 采用了链表来哦解决该问题<br>即：存储在同一链表中的元素是哈希值相同但是值不同的</li>
</ul>
</blockquote>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><blockquote>
<ul>
<li><p>put 方法的核心就是判断是否相等</p>
</li>
<li><pre><code class="java">p.hash == hash &amp;&amp;
    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 即先判断两个对象的地址，再判断这个对象的 equals 方法</span><br><span class="line">  如果这个对象没有重写 equals 方法，那么默认的就是会比较其地址再比较其成员属性值</span><br><span class="line">  注意：重写 equals 方法必须重写 hashCode 方法</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## HashSet</span><br><span class="line"></span><br><span class="line">- HashSet 是基于 HashMap 来实现的，是一个不允许有重复元素的集合</span><br><span class="line">- HashSet 允许有 null 值</span><br><span class="line">- HashSet 是无序的，即不会记录插入的顺序</span><br><span class="line">- HashSet 没有 get 方法，所以不能使用普通 for 循环遍历，可以使用 foreach 遍历</span><br><span class="line">  因为底层 HashMap 存放元素是散列的，所以没有 index 来提供访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### add 方法</span><br><span class="line"></span><br><span class="line">- 调用的其实就是 HashMap 的put 方法</span><br><span class="line">- key 存放的是传入的参数，所有的 key 初始化的 value 值都是一个 final 的相同值，value 仅作为占位用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 线程基本概念</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 什么是线程、进程</span><br><span class="line"></span><br><span class="line">- cpu 从硬盘读一段程序到内存中，该执行程序的实例就叫做进程</span><br><span class="line">  一个程序如果被 cpu 多次读取到内存中，则变成多个独立的进程</span><br><span class="line">- 程序：指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念</span><br><span class="line">- 进程是执行程序的一次过程，是一个动态的概念，是系统资源分配的单位</span><br><span class="line">- 在一个进程中可以包括多个线程，一个进程中至少有一个线程，线程是cpu调度和执行的单位</span><br><span class="line">- 很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器，如果是模拟出来的多线程，cpu在同一时间只能处理一个代码，只不过切换的很快，给人同时执行的错觉</span><br><span class="line">- 在java程序运行时，即使没有创建自己的线程，后台也会有多个线程，如main线程，gc线程</span><br><span class="line">- main线程是用户线程，gc是jvm给的称为守护线程</span><br><span class="line">- main（）称之为主线程，为系统的入口，用于执行整个程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 多线程使用场景</span><br><span class="line"></span><br><span class="line">- 客户端（移动端）开发</span><br><span class="line">- 异步发送短信、邮件</span><br><span class="line">- 将执行比较耗时的代码改成多线程异步执行</span><br><span class="line">- 异步写入日志，日志框架底层</span><br><span class="line">- 多线程下载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 基本线程机制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 创建及调用任务</span><br><span class="line"></span><br><span class="line">**定义一个倒数任务类**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class LiftOff implements Runnable &#123;</span><br><span class="line">   protected int countDown = 10;</span><br><span class="line">   private static int taskCount = 0;</span><br><span class="line">   // 标识符用来区分任务的多个实例，它是 final 的，因为它一旦被初始化就不希望被修改</span><br><span class="line">   private final int id = taskCount++;</span><br><span class="line"></span><br><span class="line">   public LiftOff() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   public LiftOff(int countDown) &#123; this.countDown = countDown; &#125;</span><br><span class="line"></span><br><span class="line">   public String status() &#123;</span><br><span class="line">       return &quot;#&quot; + id + &quot;(&quot; +</span><br><span class="line">               (countDown &gt; 0 ? countDown : &quot;LiffOff&quot;) + &quot;),&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       while (countDown-- &gt; 0) &#123;</span><br><span class="line">           System.out.println(status());</span><br><span class="line">           // yield 方法是选择性方法，用来声明我已经完成任务最重要的一部分，可以切换上下文了</span><br><span class="line">           Thread.yield();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<p><strong>任务类的调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LiftOff</span>()).start();</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting for liftoff&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="使用-Executor"><a href="#使用-Executor" class="headerlink" title="使用 Executor"></a>使用 Executor</h3><blockquote>
<p>我们可以使用执行器 (Executor) 来管理 Thread 对象，从而简化并发编程。<br>Executor 在客户端和任务之间提供了一个间接层，与客户端直接执行任务不同，这个中介对象来执行任务。<br>Executor 允许用户管理异步任务的执行，而无须显式地管理线程的生命周期。</p>
<p>以此案例为例，LiftOff 知道如何执行具体的任务，ExecutorService 知道如何构建恰当的上下文来执行 Runnable 对象。<br>这符合<strong>命令设计模式</strong>的思想，这样可以确定 Executor 的类型。<br>命令设计模式就是将 <strong>动作请求者</strong> 和 <strong>任务执行者</strong> 解耦。</p>
</blockquote>
<p><strong>使用newCachedThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// shutdown 方法可以防止新任务被提交给这个 Executor，调用了 shotdown 后线程会执行完任务后退出</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用newFixedThreadPool, 有限的线程集合来执行任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用newSingleThreadExecutor, 运行结果如下</strong></p>
<p>newSingleThreadExecutor就像线程数量为1的newFixedThreadPool，对于希望在另一个线程中连续执行任务是很有用的。<br>如果向 newFixedThreadPool 提交了多个任务，那么任务就会排队执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(LiffOff),#1(9),</span></span><br><span class="line"><span class="comment">#1(8),#1(7),#1(6),#1(5),#1(4),#1(3),#1(2),#1(1),#1(LiffOff),</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h3 id="从任务中产生返回值"><a href="#从任务中产生返回值" class="headerlink" title="从任务中产生返回值"></a>从任务中产生返回值</h3><blockquote>
<p>Runnable 是执行工作的独立任务，但是它不返回任何值，如果需要在任务完成时返回一个值，那么可以使用 Callable 接口。</p>
<ul>
<li>Callable 是一种具有类型参数的泛型</li>
<li>它的类型参数表示的是从 Call（）方法中返回的值</li>
<li>并且必须使用ExecutorService.submit() 调用</li>
</ul>
</blockquote>
<p><strong>Callable 实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskWithResult</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskWithResult</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>调用</strong></p>
<ul>
<li>submit（）方法会产生 Future 对象，它用 Callable 返回结果的特定类型进行了参数化。</li>
<li>可以用 isDone 来查询Future 是否已经完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// Callable 接口产生的结果用 Future 来接</span></span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> <span class="title class_">TaskWithResult</span>(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>对 sleep 的调用可以抛出 InterruptedException 异常，并且它在 run 中被捕获，因为异常不能跨线程传播回 main，所以需要在本地处理任务内部产生的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingTask</span> <span class="keyword">extends</span> <span class="title class_">LiftOff</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (countDown -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(status());</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><blockquote>
<ul>
<li>线程的优先级将该线程的重要性传递给了调度器。</li>
<li>尽管 cpu 处理现有的线程集的顺序是不确定的，但是调度器倾向让优先权最高的线程先执行。</li>
<li>但是这不意味着优先级低的线程不会得到执行，即优先权不会导致死锁，其仅仅只是执行的频率低。</li>
</ul>
</blockquote>
<p><strong>优先级线程声明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePriorities</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> d;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimplePriorities</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在 run 开头设置线程的优先级</span></span><br><span class="line">        Thread.currentThread().setPriority(priority);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 为了体现优先级的效果，加入了浮点数运算</span></span><br><span class="line">                d += (Math.PI + Math.E) / (<span class="type">double</span>) i;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.<span class="keyword">yield</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (-- countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">SimplePriorities</span>(Thread.MIN_PRIORITY));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> <span class="title class_">SimplePriorities</span>(Thread.MAX_PRIORITY));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="让步"><a href="#让步" class="headerlink" title="让步"></a>让步</h3><blockquote>
<p>如果知道已经完成了在 run( ) 方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示：此线程的工作已经完成的差不多了，可以让别的线程使用 cpu 了，这个暗示可以通过调用 yield( ) 来做出（不过这只是一种暗示，没有任何机制会保证它会被采纳）。</p>
<p>即调用 yield ( ) 时，是在建议具有相同优先级的其他线程可以运行。</p>
<p>但是不能太依赖与 yield 来进行线程调度，很多时候他也被误用。</p>
</blockquote>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><blockquote>
<p>所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分。因此，所有的非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程。反过来说，只要有任何的非后台线程还在运行，程序就不会终止。比如，执行main（）的就是一个非后台线程。</p>
</blockquote>
<p><strong>1-1线程声明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>1-2调用</strong></p>
<p>必须在线程 start 之前将其设置成后台线程<br>一旦 main 线程完成其工作，就没什么能阻止程序终止了，因为除了后台线程之外已经没有任何线程在运行了。<br>main 线程被设定 sleep 了一段时间，所以能观察到所有后台线程启动的结果，否则的话可能看不到任何后台线程的启动（只是可能）<br>或者尝试加大 main 线程的睡眠时间，可观察到更多后台线程的信息的打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SimpleDaemons</span>());</span><br><span class="line">            <span class="comment">// must call before start</span></span><br><span class="line">            daemon.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;All daemons started&quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2-1定制 ThreadFactory</strong></p>
<p>SimpleDaemons 创建了显式的线程，以便可以设置他们的后台标志，也可以通过定制的 ThreadFactory 定制由 Executors 创建的线程属性（后台、优先级、名称）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2-2 创建线程所需完成的任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonFromFactory</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> +<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2-3 调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool(<span class="keyword">new</span> <span class="title class_">DaemonThreadFactory</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">DaemonFromFactory</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;All daemons started&quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="加入一个线程"><a href="#加入一个线程" class="headerlink" title="加入一个线程"></a>加入一个线程</h3><blockquote>
<ul>
<li>一个线程可以在其他线程之上调用 join( ) 方法，其效果是等待一段时间直到第二个线程结束才继续执行。</li>
<li>如果一个线程在另一个线程 t 上调用 t.join( ) ，此线程将会被挂起，直到目标线程 t 结束才恢复</li>
<li>也可以在调用 join 时带上一个超时参数，这样目标线程在规定时间还没结束的话，join 总会返回</li>
<li>join 方法的调用可以被中断，在调用线程上调用 interrupt （）方法</li>
</ul>
</blockquote>
<p><strong>定义 Thread类</strong></p>
<p>Sleeper 是一个 Thread 类，它要休眠一段时间，休眠时间是由构造器返回。<br>在 run 方法中，sleep 方法有可能在指定的时间内返回，也可能被打断，在 catch 中打印被打断的信息<br>然而，catch 语句会清理 isInterrupted 的信息，所以结果总为 false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sleeper</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> duration;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sleeper</span><span class="params">(String name, <span class="type">int</span> sleepTime)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        duration = sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(duration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; was interrupted&quot;</span> + <span class="string">&quot;isInterrupted(): &quot;</span> + isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;has awakened&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Joiner 类</strong></p>
<p>Joiner 线程将通过在 Sleeper 对象上调用 join 方法来等待 Sleeper 醒来，在 main 线程里面，每个 Sleeper 都有一个 Joiner，如果 Sleeper 被打断或正常结束， Joiner 将会和 Sleeper 一同结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joiner</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Joiner</span><span class="params">(String name, Sleeper sleeper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.sleeper = sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleeper.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; join completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sleeper</span></span><br><span class="line">                <span class="variable">sleepy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sleeper</span>(<span class="string">&quot;Sleepy&quot;</span>, <span class="number">1500</span>),</span><br><span class="line">                grumpy = <span class="keyword">new</span> <span class="title class_">Sleeper</span>(<span class="string">&quot;grumpy&quot;</span>, <span class="number">1500</span>);</span><br><span class="line">        <span class="type">Joiner</span></span><br><span class="line">                <span class="variable">dopey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Joiner</span>(<span class="string">&quot;dopey&quot;</span>, sleepy),</span><br><span class="line">                doc = <span class="keyword">new</span> <span class="title class_">Joiner</span>(<span class="string">&quot;doc&quot;</span>, grumpy);</span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><blockquote>
<ul>
<li>线程组持有一个线程集合</li>
<li>引用 sun 的架构师的一句话：最好把线程组看成是一次失败的尝试，忽略它就好</li>
</ul>
</blockquote>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h2 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h2><blockquote>
<p>可以把单线程程序当作在问题域求解单一实体，每次只能做一件事。</p>
<p>但是有了并发，就要考虑两个实体试图使用同一个资源。</p>
</blockquote>
<h3 id="不正确地访问资源"><a href="#不正确地访问资源" class="headerlink" title="不正确地访问资源"></a>不正确地访问资源</h3><p>**实现一个 IntGenerator **</p>
<p>这个实例是实现一个生产偶数的任务，而其他任务消费这里生产的数字。<br>首先创建一个 IntGenerator 的抽象类，它必须包含 EvenChecker 必须有的方法：一个 next 方法和一个可以执行撤销的方法。<br>这个类没有实现 Generator 接口，因为它必须产生一个 int，而泛型不支持基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">IntGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// allow this to be canceled</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;<span class="built_in">this</span>.canceled = <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCanceled</span><span class="params">()</span> &#123;<span class="keyword">return</span> canceled;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>EvenChecker</strong></p>
<ul>
<li>在本例中，可以被撤销的类不是 Runnable，而是所有依赖于 IntGenerator 对象的 EvenChecker 任务来测试它。</li>
<li>一个任务不可以依赖另一个任务，因为任务关闭的顺序不可以被保证，这里通过任务依赖非任务对象来消除潜在的竞争条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvenChecker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntGenerator generator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvenChecker</span><span class="params">(IntGenerator g, <span class="type">int</span> ident)</span> &#123;</span><br><span class="line">        generator = g;</span><br><span class="line">        id = ident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!generator.isCanceled()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> generator.next();</span><br><span class="line">            <span class="keyword">if</span> (val % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(val + <span class="string">&quot; not even&quot;</span>);</span><br><span class="line">                generator.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(IntGenerator gp, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Press Control-c to exit&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">EvenChecker</span>(gp, i));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(IntGenerator gp)</span> &#123;</span><br><span class="line">        test(gp, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>具体实现偶数生成器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvenGenerator</span> <span class="keyword">extends</span> <span class="title class_">IntGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过将两次 ++ 分开，加大并发访问的危险程度</span></span><br><span class="line">        ++currentValue;</span><br><span class="line">        ++currentValue;</span><br><span class="line">        <span class="keyword">return</span> currentValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="解决共享资源竞争"><a href="#解决共享资源竞争" class="headerlink" title="解决共享资源竞争"></a>解决共享资源竞争</h3><blockquote>
<ul>
<li>基本上所有的并发模式在解决线程冲突问题的时候，都是采用<strong>序列化访问共享资源</strong>的方案</li>
<li>Java 以提供 synchronized 的形式，为防止资源冲突提供了内置支持。<br>当任务执行被 synchronized 关键字保护的代码片段的时候，它将检查锁是否可用，然后获取锁，执行代码，释放锁。</li>
<li>共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入&#x2F;输出端口，或者是打印机<br>要控制对资源共享的访问，得先把它包装进一个对象，然后把所有要访问这个资源的方法标记为 synchronized<br>如果某一个任务处于对 synchronized 标记的方法的调用中，那么这个线程从该方法返回前，其他所有要调用类中标记为synchronized 方法的线程都将被阻塞。</li>
<li>所有的对象都含有单一的锁（也称为监视器），当在对象上调用<strong>其</strong>任意 synchronized 方法的时候，此对象都会被加锁，这时该对象上的其他 synchronized 方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。<br>所以，对于某个特定的对象来说，其所有 synchronized 方法共享同一个锁。</li>
<li>注意，在使用并发时，将被访问资源设置为 private 是十分重要的，否则，synchronized 就不能防止其他任务直接访问域，这样就会产生冲突。</li>
<li>JVM 会跟踪对象被加锁的数量，如果一个对象被解锁，其计数变为 0<br>一个任务可以多次获得对象的锁，一个任务调用了一个对象的 synchronized 方法，该方法又调用该对象的另一个方法，所得计数会加两次。</li>
<li>针对每个类，也有一个锁，作为类的 class 对象的一部分，所以 synchronized static 方法可以在该类的范围内防止对 static 数据的并发访问。</li>
</ul>
</blockquote>
<p><strong>对刚刚那个偶数生成器重写</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedEvenGenerator</span> <span class="keyword">extends</span> <span class="title class_">IntGenerator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        ++currentValue;</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">        ++currentValue;</span><br><span class="line">        <span class="keyword">return</span> currentValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用显示的 Lock 对象</strong></p>
<p>尽管使用 Lock 显示对象 的 try-finally 所需要写的代码比 synchronized 多，但这也是它的优点。<br>如果使用 synchronized 关键字的时候某些事务失败了，那么只能抛出异常，没有机会进行清理工作，但是使用 Lock，可以在 finally 的代码块里维护系统的正确状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title class_">IntGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++currentValue;</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">            ++currentValue;</span><br><span class="line">            <span class="keyword">return</span> currentValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="原子性与易变性"><a href="#原子性与易变性" class="headerlink" title="原子性与易变性"></a>原子性与易变性</h3><blockquote>
<p>原子性可以应用于除了 long 和 double 之外的所有基本类型之上的“简单操作”。<br>因为 JVM 可以将 64 位（long 和 double 变量）的读取和写入当作两个分离的 32 位操作来执行，这就产生了一个读取和写入的时候可能会上下文切换，（这被称为字撕裂）但是如果使用 vlolatile 关键字来声明 long 和 double ，那么就会获得简单的赋值和返回操作的原子性。</p>
</blockquote>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><h2 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h2><h3 id="在阻塞时终结"><a href="#在阻塞时终结" class="headerlink" title="在阻塞时终结"></a>在阻塞时终结</h3><p><strong>线程状态</strong></p>
<blockquote>
<p>一个线程可以处于以下四种状态之一：</p>
<ul>
<li>新建<br>当线程被创建时，它只会短暂的处于这种状态。<br>此时它已经分配了必须的系统资源，并执行了初始化。此刻线程已经有资格获得 cpu 时间了<br>之后调度器把这个线程变成阻塞状态或可运行状态。</li>
<li>就绪<br>在这种状态下，调度器把时间片分给线程，线程就可以运行。</li>
<li>阻塞<br>线程能够运行，但有某个条件组织了他的运行。<br>当线程处于阻塞状态时，调度器将忽略线程，不会分配 cpu 时间，直到它重新进入了就绪态</li>
<li>死亡<br>处于死亡态的线程是不可被调度的，任务通常的死亡方式是从 run 方法返回或被中断。</li>
</ul>
</blockquote>
<p><strong>进入阻塞态</strong></p>
<blockquote>
<p>一个任务进了阻塞态，可能有如下原因：</p>
<ul>
<li>通过调用 sleep 使任务进入休眠状态</li>
<li>通过 wait（）方法使线程挂起，直到线程得到 notify（）或 notifyAll（）消息（或者用等价的 signal 和 signalAll 方法）</li>
<li>任务在等待某个输入&#x2F;输出完成</li>
<li>任务试图调用某个对象上的同步方法，但是其对象锁不可用，因为另一个任务已经获得了这个锁。</li>
</ul>
</blockquote>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h2 id="线程创建与执行"><a href="#线程创建与执行" class="headerlink" title="线程创建与执行"></a>线程创建与执行</h2><blockquote>
<p>创建线程的方式（针对 Java 开发）：</p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>使用匿名内部类创建</li>
<li>使用lambda表达式创建</li>
<li>使用 Callable 和 Future 创建线程</li>
<li>使用线程池（例如 Excutor 框架）</li>
<li>spring @Async 异步注解</li>
</ol>
</blockquote>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>创建线程步骤：</p>
<ol>
<li>自定义线程类继承Thread类则自定义的线程类就变成了线程类</li>
<li>重写run（）方法，编写线程执行体</li>
<li>创建线程对象，调用start（）方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLearning1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run方法：&quot;</span>+ i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLearning1</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLearning1</span>();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Run（）和start（）"><a href="#Run（）和start（）" class="headerlink" title="Run（）和start（）"></a>Run（）和start（）</h3><img src="/Users/lei/Desktop/Typora笔记/图片/截屏2022-05-17 22.07.02.png" alt="截屏2022-05-17 22.07.02" style="zoom:50%;" />



<p>说明：</p>
<ol>
<li>调用start（）和调用run（）方法都可以执行该线程所创建的方法，但是如果在主线程调用run方法，那么主线程会转去执行run方法，执行结束之后才会继续执行主线程，而如果是调用start（）方法，就意味着在主线程外开辟了一个线程，cpu交替执行两个线程。</li>
<li>线程开启不一定立即执行，由cpu调度</li>
</ol>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>创建步骤：</p>
<ol>
<li>自定义类实现Runnable接口</li>
<li>实现Run（）方法，编写线程执行体</li>
<li>&#x3D;&#x3D;创建线程对象调用构造器以自定义类为参数&#x3D;&#x3D;，调用start（）方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLearning2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLearning2</span> <span class="variable">threadLearning2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLearning2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadLearning2);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注：继承Thread类与实现Runnable接口比较</p>
<ul>
<li>继承Thread类<ul>
<li>子类继承Thread类具备多线程能力</li>
<li>启动线程：子对象.start( )</li>
<li>&#x3D;&#x3D;不建议使用，避免OOP单继承局限性&#x3D;&#x3D;</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>实现接口Runnable具有多线程能力</li>
<li>启动线程：传入目标对象+Thread.start( )</li>
<li>&#x3D;&#x3D;推荐使用，避免了单继承局限性，灵活方便，方便同一个对象被多个线程使用&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>步骤：</p>
<ol>
<li>实现Callable接口，需要返回值类型</li>
<li>重写call方法，需要抛出异常</li>
<li>创建目标对象</li>
<li>创建执行服务</li>
<li>提交执行</li>
<li>获取结果</li>
<li>关闭服务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line"><span class="comment">//1. 实现Callable接口，需要返回值类型</span></span><br><span class="line"><span class="comment">//2. 重写call方法，需要抛出异常</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 创建目标对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ThreadTest2</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest2</span>();</span><br><span class="line">    <span class="type">ThreadTest2</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest2</span>();</span><br><span class="line">    <span class="type">ThreadTest2</span> <span class="variable">test3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest2</span>();</span><br><span class="line">    <span class="comment">//4. 创建执行服务</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//5. 提交执行</span></span><br><span class="line">    Future&lt;Boolean&gt; r1 = service.submit(test1);</span><br><span class="line">    Future&lt;Boolean&gt; r2 = service.submit(test2);</span><br><span class="line">    Future&lt;Boolean&gt; r3 = service.submit(test3);</span><br><span class="line"><span class="comment">//6. 获取结果</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rs1</span> <span class="operator">=</span> r1.get();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rs2</span> <span class="operator">=</span> r2.get();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rs3</span> <span class="operator">=</span> r3.get();</span><br><span class="line"><span class="comment">//7. 关闭服务</span></span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="*线程安全"></a>*线程安全</h2><blockquote>
<p><strong>线程安全性问题其实线程如何保证同步</strong></p>
<p>比如说，多个线程同时对一个全局变量进行写的操作，可能会收到其他线程的干扰<br>要注意的是，多个线程同时对一个线程进程读操作是没有线程安全问题的</p>
</blockquote>
<h3 id="线程安全问题demo"><a href="#线程安全问题demo" class="headerlink" title="线程安全问题demo"></a>线程安全问题demo</h3><p>创建两个线程对共享变量进行写操作，观察他们的竞争情况<br>下面的代码的输出结果是两个线程无规律的交替执行减操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 加入休眠之后会增加线程竞争的可能性，扩大实验效果</span></span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                --count;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadCount</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadCount</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(threadCount).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(threadCount).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="线程安全问题解决方法"><a href="#线程安全问题解决方法" class="headerlink" title="线程安全问题解决方法"></a>线程安全问题解决方法</h3><blockquote>
<p>核心思想：上锁<br><strong>在 JVM 中，多个线程竞争锁的资源，谁（线程）能够获取到锁，谁就能执行代码</strong></p>
<p>主要的方式有以下几种</p>
<ul>
<li>使用 synchronized 锁<br>jdk 1.6 开始 锁的升级过程（偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁）</li>
<li>使用 Lock 锁（JUC）<br>需要自己实现锁的升级过程，底层是基于 aqs + cas 实现，不属于重量级锁</li>
<li>使用 ThreadLocal<br>需要注意内存泄漏问题</li>
<li>原子类 CAS 非阻塞式</li>
</ul>
</blockquote>
<h3 id="synchronized-锁"><a href="#synchronized-锁" class="headerlink" title="synchronized 锁"></a>synchronized 锁</h3><blockquote>
<ul>
<li>synchronized 是一种非公平锁</li>
<li>即谁抢到锁谁执行，抢不到就等待</li>
<li>加上 synchronized 关键字后会变成单线程执行</li>
</ul>
<p><strong>基本用法</strong></p>
<ul>
<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码快前要获得 给定对象 的锁。</li>
<li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得 当前实例 的锁</li>
<li>修饰静态方法，作用于当前类对象（当前类.class）加锁，进入同步代码前要获得 当前类对象 的锁</li>
</ul>
</blockquote>
<h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><p>在多线程情况下，需要的是同一个对象锁，所以可以通过一个 this 锁来解决</p>
<p>这个 this 锁其实就是一种对象锁，括号里需要加上一样的对象，new Object 也行</p>
<p>仍然是一样的代码，但是不在方法上加 synchronized<br>可以发现，现在两个线程仍然是无规律执行方法，但是公共变量 count 是按顺序得从 100 开始减，这就是安全的在执行减少</p>
<p>因为两个线程在竞争 this 锁时，竞争到的那个会执行代码，没拿到锁的会阻塞，当拥有锁的线程执行完 this 锁的代码后，会唤醒另一个线程执行</p>
<p>synchronized 是比较智能的，获取锁释放锁都是底层完成的</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-01%2023.50.11.png" style="zoom:40%">





<h4 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h4><p>将 synchronized 加在实例方法上默认使用的是 this 锁</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-01%2023.43.05.png" style="zoom:40%">





<h4 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h4><p>将 synchronized 加在静态方法上默认使用的是当前的类名称.class 锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                call();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ThreadCount.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized-死锁问题"><a href="#synchronized-死锁问题" class="headerlink" title="synchronized 死锁问题"></a>synchronized 死锁问题</h4><blockquote>
<p>死锁本质就是 a 线程运行需要的资源被 b 线程拿到，b 线程需要的资源在 a 线程这里，这样两个线程都会卡住无法运行，拓展到 n 个线程也是可以的。</p>
<p>下面给出了一个 demo，从这个 demo 可以看出，写代码时尽量避免嵌套锁，不然容易卡住</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="string">&quot;lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 线程1需要获取 lock 再获取 a方法this锁</span></span><br><span class="line">                <span class="comment">// 线程2需要获取this 锁在 获取B方法lock锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    a();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    b();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,a方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,b方法...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadLockDemo</span> <span class="variable">deadLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(deadLockDemo);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(deadLockDemo);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="死锁排查工具"><a href="#死锁排查工具" class="headerlink" title="死锁排查工具"></a>死锁排查工具</h4><blockquote>
<p>jconsole 是 java 自带的死锁排查工具，在 jdk 安装目录 home&#x2F;bin 目录下，在启动界面选择当前项目，选择不安全的连接，然后选择线程选项吗即可找到死锁的线程</p>
<p>点击检测死锁可以自动帮我们找到死锁的线程</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-17%2022.57.17.png" style = "zoom:40%">









<h3 id="springmvc-使用锁"><a href="#springmvc-使用锁" class="headerlink" title="springmvc 使用锁"></a>springmvc 使用锁</h3><blockquote>
<p>springmvc 的 bean 对象默认是单例，即多个请求访问同一个接口，只会创建一个对象，所以如果在 springmvc 的controller 类的方法上加上 synchronized 锁，会导致该方法变为单线程</p>
<p>如果将 controller 用 @Scope(value &#x3D; “prototype”) 指定为多例，那么就不会共享类的某一成员变量了</p>
</blockquote>
<h2 id="线程通讯"><a href="#线程通讯" class="headerlink" title="*线程通讯"></a>*线程通讯</h2><h3 id="wait、notify-使用事项"><a href="#wait、notify-使用事项" class="headerlink" title="wait、notify 使用事项"></a>wait、notify 使用事项</h3><blockquote>
<ul>
<li>wait ( )方法用于释放锁资源，并且当前线程会阻塞，notify 用于唤醒线程</li>
<li>使用 wait ( ) 方法必须声明好锁对象，不然会报错，并且是获取锁的对象去调用 wait</li>
<li>wait 和 notify 方法需要放到 synchronized 同步代码块中使用</li>
</ul>
<p>下面的 demo 展示的是在主线程中创建一个子线程去打印两行语句，打印语句中间会调用 wait 方法，而主线程会在 3 秒后唤醒持有 objectLock 的线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyDemo1</span> &#123;</span><br><span class="line">    <span class="comment">// 自己声明的一个对象锁，对象锁可以是任意对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WaitNotifyDemo1</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// wait 方法需要放在 synchronized 同步代码块中</span></span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&lt;1&gt;&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞 持有 objectLock 的线程</span></span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&lt;2&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程 3 秒后唤醒被阻塞的子线程</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="comment">// notify 需要放到同步代码快中</span></span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            objectLock.notify();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="实现生产者消费者模型"><a href="#实现生产者消费者模型" class="headerlink" title="实现生产者消费者模型"></a>实现生产者消费者模型</h3><blockquote>
<p>本节会用 wait 和 notify 实现一个生产者与消费者模型</p>
<p>模型 demo 效果如下，在 demo 中有三个内部类，一个 User 类作为资源，拥有姓名和性别两个属性，还有两个类继承 Thread，分别是输入类和输出类，输入类每次会访问到共享变量 User，并根据 count 值不同来对 User 写入不同的属性值，而输出类的作用是将输入类输入的属性打印出来。</p>
</blockquote>
<h4 id="未加锁-demo"><a href="#未加锁-demo" class="headerlink" title="未加锁 demo"></a>未加锁 demo</h4><blockquote>
<p>没有经过任何线程安全处理的 demo 如下，代码本身做什么是比较好理解的，但是运行结果是很有趣的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 全局共享对象</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InputThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InputThread</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.user = user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个写入类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 count 值的不同来写入两个不同的 User 对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    user.name = <span class="string">&quot;erics&quot;</span>;</span><br><span class="line">                    user.gender = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    user.name = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line">                    user.gender = <span class="string">&quot;female&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count = (count + <span class="number">1</span>) % <span class="number">2</span>; <span class="comment">// 该 count 值只会在 0 1 之间循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出对象，打印当前线程拿到的全局对象</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">OutputThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">OutputThread</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.user = user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name: &quot;</span> + user.name + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;gender: &quot;</span> + user.gender);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 全局对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">// 输入线程</span></span><br><span class="line">        <span class="type">InputThread</span> <span class="variable">inputThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputThread</span>(user);</span><br><span class="line">        <span class="comment">// 输出线程</span></span><br><span class="line">        <span class="type">OutputThread</span> <span class="variable">outputThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputThread</span>(user);</span><br><span class="line"></span><br><span class="line">        inputThread.start();</span><br><span class="line">        outputThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ProducerAndConsumer</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>运行结果如下: 打印的结果完全是乱的，并没有按照代码逻辑：erics male，rose female 来打印。<br>这个是很好理解的，当前 user 作为共享资源并没有被上锁，输入和输出线程可以同时对该对象进行操作，当输出线程准备打印 user 时，可能刚好性别被改了，名字还没来得及改，所以就会出现“性别混乱”的现象。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-18%2001.06.42.png" style="zoom:50%">







<h4 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h4><blockquote>
<p>第一次优化的点在于，我们需要将名称和性别匹配上，做到这一点就需要输入线程和输出线程在分别拿到 User 资源的时候其他线程不允许对该资源进行操作，于是很容易我们可以想到使用 synchronized 对 user 对象进行加锁，代码如下,仅展示两个线程的方法修改</p>
<p>该代码可以做到打印的名称和性别能够对应，但是仍然是有问题，每次打印会讲相同属性的对象打印很多次。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InputThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputThread</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个写入类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 count 值的不同来写入两个不同的 User 对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (user) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    user.name = <span class="string">&quot;erics&quot;</span>;</span><br><span class="line">                    user.gender = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    user.name = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line">                    user.gender = <span class="string">&quot;female&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count = (count + <span class="number">1</span>) % <span class="number">2</span>; <span class="comment">// 该 count 值只会在 0 1 之间循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出对象，打印当前线程拿到的全局对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutputThread</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (user) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;name: &quot;</span> + user.name + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;gender: &quot;</span> + user.gender);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h4><blockquote>
<p>上述问题还需要实现交替单次打印用户信息，基本思想是在 User 内加入 flag 状态位，然后通过wait 和 notify 结合来完成</p>
<p>完整 demo 代码如下，需要好好品味</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 全局共享对象</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String gender;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当 flag == false ，输入线程可以输入，flag == true，输出线程可以输出，flag 默认为 false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InputThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InputThread</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.user = user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个写入类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 count 值的不同来写入两个不同的 User 对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (user) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (user.flag == <span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            user.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        user.name = <span class="string">&quot;erics&quot;</span>;</span><br><span class="line">                        user.gender = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        user.name = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line">                        user.gender = <span class="string">&quot;female&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 输入完成之后，需要将 flag 改为 true 并唤醒输出线程</span></span><br><span class="line">                    user.flag = <span class="literal">true</span>;</span><br><span class="line">                    user.notify();</span><br><span class="line">                &#125;</span><br><span class="line">                count = (count + <span class="number">1</span>) % <span class="number">2</span>; <span class="comment">// 该 count 值只会在 0 1 之间循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出对象，打印当前线程拿到的全局对象</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">OutputThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">OutputThread</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.user = user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (user) &#123;</span><br><span class="line">                    <span class="comment">// 如果 flag == false，即输出线程不能输出，则应该释放锁资源,同时阻塞自己</span></span><br><span class="line">                    <span class="keyword">if</span> (!user.flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            user.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;name: &quot;</span> + user.name + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;gender: &quot;</span> + user.gender);</span><br><span class="line">                    <span class="comment">// 输出完成后需要修改 flag 值并唤醒线程</span></span><br><span class="line">                    user.flag = <span class="literal">false</span>;</span><br><span class="line">                    user.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 全局对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">// 输入线程</span></span><br><span class="line">        <span class="type">InputThread</span> <span class="variable">inputThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputThread</span>(user);</span><br><span class="line">        <span class="comment">// 输出线程</span></span><br><span class="line">        <span class="type">OutputThread</span> <span class="variable">outputThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputThread</span>(user);</span><br><span class="line"></span><br><span class="line">        inputThread.start();</span><br><span class="line">        outputThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ProducerAndConsumer</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="join-方法原理"><a href="#join-方法原理" class="headerlink" title="join 方法原理"></a>join 方法原理</h3><h4 id="wait-和-notify-底层原理"><a href="#wait-和-notify-底层原理" class="headerlink" title="wait 和 notify 底层原理"></a>wait 和 notify 底层原理</h4><blockquote>
<p>首先了解wait 和 notify 方法的工作原理</p>
<ul>
<li>首先是若干线程共同竞争锁资源，只有抢到锁资源的线程才能执行，剩下的会进入到一个 blockedThread 队列里等待锁资源被释放继续竞争锁资源。</li>
<li>当线程调用 wait 方法意味着释放锁资源并被堵塞，该线程会进入到 waitSet 集合</li>
<li>当线程调用 notify 方法并不是把锁资源给到某一线程，而是将在 waitSet 集合里的线程转移到 blockedThread 队列中，准备竞争锁资源。</li>
</ul>
<p>如下图所示</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-18%2017.31.12.png" style = "zoom:50%">







<h4 id="join-底层原理"><a href="#join-底层原理" class="headerlink" title="join 底层原理"></a>join 底层原理</h4><blockquote>
<p>翻看 join 源码可知：join 就是利用 wait 封装的，谁调用的 wait 方法谁就会释放锁资源，但是其唤醒代码是在 jvm 层面做的，<br>当拥有锁的线程执行完之后，会唤醒锁池里的所有线程</p>
</blockquote>
<h2 id="多线程7种执行状态"><a href="#多线程7种执行状态" class="headerlink" title="*多线程7种执行状态"></a>*多线程7种执行状态</h2><blockquote>
<p>多线程有五种基础状态：</p>
<ul>
<li>初始化状态</li>
<li>就绪态</li>
<li>运行态</li>
<li>死亡状态</li>
<li>阻塞状态</li>
</ul>
<p>现在很多场合还加了两种状态：</p>
<ul>
<li>超市等待</li>
<li>等待状态</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-18%2020.51.00.png" style="zoom:50%">





<h3 id="sleep-防止cpu-100"><a href="#sleep-防止cpu-100" class="headerlink" title="sleep 防止cpu 100%"></a>sleep 防止cpu 100%</h3><blockquote>
<p>在代码中写一个 while 死循环后 cpu 的使用率直接飙高，当在 while 中添加一个 Thread.sleep(30 ) 之后cpu 的使用率就没那么高了，因为其使得线程每间隔 30 秒从就绪到运行</p>
</blockquote>
<h3 id="用户线程与守护线程"><a href="#用户线程与守护线程" class="headerlink" title="用户线程与守护线程"></a>用户线程与守护线程</h3><blockquote>
<p>当我们在主线程中创建了一个子线程，子线程的执行不会因为主线程的停止而停止，如下代码:<br>当主线程执行完毕打印了语句后，子线程仍然在执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSleep</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我是子线程&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是主线程，我已经执行完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>这是因为 java 中线程分为两种：用户线程和守护线程。<br>通过 Thread.setDaemon(true)，可以将线程设置为守护线程，默认为 false，即用户线程。</p>
<p>区别：</p>
<ul>
<li>守护线程依赖于用户线程，用户线程退出了，守护线程也就会退出，典型的守护线程如垃圾回收线程</li>
<li>用户线程是独立存在的，不会因为其他的线程退出而退出</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSleep</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>); <span class="comment">// 设置为守护线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是主线程，我已经执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="安全的停止一个线程"><a href="#安全的停止一个线程" class="headerlink" title="*安全的停止一个线程"></a>*安全的停止一个线程</h2><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><blockquote>
<p>不推荐</p>
</blockquote>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><blockquote>
<p>interrupt 单独使用的话只能停止正在休眠的线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KillThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>();</span><br><span class="line">        killThread.start();</span><br><span class="line">        <span class="comment">// 主线程 sleep 3 秒后中短子线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;中断子线程&quot;</span>);</span><br><span class="line">        killThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>要想用 interrupt 终止一个正在运行态的线程，需要配合 isINterrupt 方法使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KillThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isInterrupted()) &#123; <span class="comment">// 如果当前线程被终止，就停止执行</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>();</span><br><span class="line">        killThread.start();</span><br><span class="line">        <span class="comment">// 主线程 sleep 3 秒后中短子线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;中断子线程&quot;</span>);</span><br><span class="line">        killThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="自己设置标志位"><a href="#自己设置标志位" class="headerlink" title="自己设置标志位"></a>自己设置标志位</h3><blockquote>
<p>推荐使用</p>
<p>需要注意的是标志位最好使用 volatile 关键字修饰</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KillThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>();</span><br><span class="line">        killThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;中断子线程&quot;</span>);</span><br><span class="line">        killThread.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="*Lock 锁"></a>*Lock 锁</h2><blockquote>
<ul>
<li>Jdk1.5 新增的 ReentrantLock 类同样可以达到锁的效果，使用上比 synchronized 更灵活</li>
<li>synchronized 是属于关键字，其底层是虚拟机用 c++ 实现好的</li>
<li>Lock 锁基于 AQS 实现，其有一个不好的点，就是在没获得锁的时候会变成重量级锁</li>
<li>synchronized 在 jdk 1.9 的时候经历了一次提升，提升后还是更推荐使用 synchronized</li>
</ul>
</blockquote>
<h3 id="Lock-锁的正确使用"><a href="#Lock-锁的正确使用" class="headerlink" title="Lock 锁的正确使用"></a>Lock 锁的正确使用</h3><blockquote>
<p>使用 lock 锁千万别忘了释放锁</p>
</blockquote>
<p><strong>错误使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经拿到锁&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经拿到锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLock</span> <span class="variable">threadLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLock</span>();</span><br><span class="line">        threadLock.thread1();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        threadLock.thread2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经拿到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经拿到锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经释放锁&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLock</span> <span class="variable">threadLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLock</span>();</span><br><span class="line">        threadLock.thread1();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        threadLock.thread2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="condition-方法"><a href="#condition-方法" class="headerlink" title="condition 方法"></a>condition 方法</h3><blockquote>
<p>wait 和 notify 需要配合 synchronized 锁使用，所以 lock 锁的通信方法有自己的一套方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 得先拿到锁才能进行阻塞啊</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 拿到锁&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤醒的过程也是在拿到锁的过程中完成的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒线程已经拿到锁&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒线程唤醒成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒线程释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConditionTest</span> <span class="variable">conditionTest</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ConditionTest</span>();</span><br><span class="line">        conditionTest.call();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        conditionTest.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="yield-方法"><a href="#yield-方法" class="headerlink" title="*yield 方法"></a>*yield 方法</h2><blockquote>
<p>主动释放 cpu 执行权，但是这只能表示一种谦让，不一定会成功</p>
</blockquote>
<h2 id="多线程的优先级"><a href="#多线程的优先级" class="headerlink" title="*多线程的优先级"></a>*多线程的优先级</h2><blockquote>
<ul>
<li>优先级有 1-10</li>
<li>linux 系统忽略了 java 线程的优先级，所以没有效果</li>
</ul>
</blockquote>
<h3 id="wait-x2F-join-和-sleep-的区别"><a href="#wait-x2F-join-和-sleep-的区别" class="headerlink" title="wait&#x2F;join 和 sleep 的区别"></a>wait&#x2F;join 和 sleep 的区别</h3><blockquote>
<ul>
<li>wait 方法在等待过程中释放对象锁</li>
<li>sleep 在睡眠时不释放对象锁</li>
<li>Sleep 不释放锁，所以不需要在 synchronized 代码块中使用，而wait 方法是需要在 synchronized 代码块中使用的</li>
</ul>
</blockquote>
<h3 id="wait-和-notify-为什么放在父类中"><a href="#wait-和-notify-为什么放在父类中" class="headerlink" title="wait 和 notify 为什么放在父类中"></a>wait 和 notify 为什么放在父类中</h3><blockquote>
<p>之前说过很多次，wait 和 notify 方法必须配合 synchronized 使用，所以这来宁哥方法都需要配合对象锁来使用，所以放在 Object 类中拿对象锁就会方便一些</p>
</blockquote>
<h2 id="字节码角度分析线程安全"><a href="#字节码角度分析线程安全" class="headerlink" title="*字节码角度分析线程安全"></a>*字节码角度分析线程安全</h2><blockquote>
<p>先写一个 demo 如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread02</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread02</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread02</span>();</span><br><span class="line">        <span class="type">Thread02</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread02</span>();</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在终端中进入到该类的编译后的类（out 或 target 目录中的类）的目录中，输入 javap -p -v xxx.class 的命令即可</p>
</blockquote>
<p>其中关于 sum++ 的字节码是这么写的，getstatic #3 是从常量池中获取 sum，iconst_1 是准备一个常量 1，然后增加到获取的常量后再放回常量池</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-07-17%2001.35.23.png">

<p>看到这段代码也就明白了为什么会出现结果不是 20000 的情况，当单核 cpu 在执行线程1的时候可能刚执行完9、12、13行代码，准备把 sum &#x3D; 1 的结果推回常量池，立马切换到线程2，并进行了上下文切换，线程2的 sum 还是为 0，线程2执行完所有的代码并且将 sum &#x3D; 1 推回常量池，cpu回过头来执行线程1，继续从14行执行，但是会有一个上下文切换的动作，此时的 sum &#x3D; 1，所以常量池中的 sum 又变成1了。</p>
<h2 id="Callable-与-FutureTask-分析"><a href="#Callable-与-FutureTask-分析" class="headerlink" title="*Callable 与 FutureTask 分析"></a>*Callable 与 FutureTask 分析</h2><blockquote>
<p>先看体会如下代码：</p>
</blockquote>
<p>**先写一个类实现 Callable 接口，并且将 call 方法的返回值改为 Integer **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCallableDemo1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: starting execute&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: return 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在main 方法中调用</strong><br>当注释掉 futureTask.get() 代码前，主线程 main 先打印然后是子线程的两句打印，这是很容易理解的，当我们取消注释再执行会发现，自线程先调用方法然后才是主线程，因为 get 方法会阻塞主线程，让子线程执行完才继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadCallableDemo1</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadCallableDemo1</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(demo1);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"><span class="comment">//        Integer integer = futureTask.get();</span></span><br><span class="line"><span class="comment">//        System.out.println(integer);</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="自己手写-Callable-和-Futuretask"><a href="#自己手写-Callable-和-Futuretask" class="headerlink" title="自己手写 Callable 和 Futuretask"></a>自己手写 Callable 和 Futuretask</h3><p><strong>Callable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyCallable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>FutureTusk</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyCallable&lt;V&gt; myCallable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> V result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyFutureTask</span><span class="params">(MyCallable&lt;V&gt; myCallable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myCallable = myCallable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = myCallable.call();</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                lock.notify(); <span class="comment">// 唤醒 lock 锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 run 方法执行完毕返回的结果</span></span><br><span class="line">        <span class="comment">// 主线程阻塞</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 谁调用到这里谁阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>impl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallableImpl</span> <span class="keyword">implements</span> <span class="title class_">MyCallable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: starting execute&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: return 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h3><p><strong>首先通过一个小demo了解 LockSupport 的用法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 1&quot;</span>);</span><br><span class="line">                LockSupport.park(); <span class="comment">// 阻塞方法</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(t1); <span class="comment">// 解锁方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>重新实现callable和futuretask</strong></p>
<p>重写后的 futuretask </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyCallable&lt;V&gt; myCallable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread parkThread; <span class="comment">// 记录当前被阻塞的线程，待会好唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> V result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyFutureTask</span><span class="params">(MyCallable&lt;V&gt; myCallable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myCallable = myCallable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        result = myCallable.call();</span><br><span class="line">        <span class="keyword">if</span> (parkThread != <span class="literal">null</span>) &#123;</span><br><span class="line">            LockSupport.unpark(parkThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        parkThread = Thread.currentThread();</span><br><span class="line">        LockSupport.park(); <span class="comment">// 谁调这个方法谁阻塞</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote>
<p>并发就是多个线程对同一个对象进行操作</p>
<p>以下代码模拟了三个线程抢票的情况<br>三个线程对同一个对象进行操作，代码执行的结果反映了一个问题：多个线程有可能会取得同一张票<br>如何解决问题呢？</p>
</blockquote>
<h3 id="买票案例"><a href="#买票案例" class="headerlink" title="买票案例"></a>买票案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThredTest1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟延时，让结果更加显著</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;我拿到了第&quot;</span> + tickets-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThredTest1</span> <span class="variable">thredTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThredTest1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thredTest1, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thredTest1, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thredTest1, <span class="string">&quot;Mack&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="龟兔赛跑"><a href="#龟兔赛跑" class="headerlink" title="龟兔赛跑"></a>龟兔赛跑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Race</span>  <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">&quot;兔子&quot;</span>) &amp;&amp; i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> gameOver(i);</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;跑了：&quot;</span> + i + <span class="string">&quot;步&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断游戏是否结束</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">gameOver</span><span class="params">(<span class="type">int</span> steps)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (winner != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (steps &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            winner = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;winner is &quot;</span> + winner);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Race</span> <span class="variable">race</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Race</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(race, <span class="string">&quot;乌龟&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(race, <span class="string">&quot;兔子&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h3><blockquote>
<p>处理多线程问题时，多个线程方法同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步机制其实就是一个等待机制，多个需要同时访问某个对象的线程进入这个<strong>对象的等待池形成队列</strong>，等待前面线程使用完毕，下一个线程再使用。</p>
</blockquote>
<h3 id="队列、锁"><a href="#队列、锁" class="headerlink" title="队列、锁"></a>队列、锁</h3><blockquote>
<ul>
<li>由于同一进程的多个线程共享同一块存储空间，就存在着访问冲突的问题，为了保证数据在方法中被访问时的正确性，在访问时加入&#x3D;&#x3D;锁机制（synchronized)&#x3D;&#x3D;,当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可</li>
<li>也会导致以下问题<ul>
<li>一个线程持有锁会导致其他需要此锁的线程刮起挂起</li>
<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引发性能问题</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="三大不安全案例"><a href="#三大不安全案例" class="headerlink" title="三大不安全案例"></a>三大不安全案例</h3><blockquote>
<p>每个线程都有自己的工作缓存区间，会将访问到的资源拷贝到自己的工作区间，这也导致了一些问题</p>
</blockquote>
<ul>
<li><p>不安全的买票<br>不同的人可能会拿到同一张票并且可能会造成票的数量为负数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeByTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyTicket</span> <span class="variable">buyTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyTicket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到了第&quot;</span> + ticketNums-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不安全取钱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeBanl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">100</span>, <span class="string">&quot;工资&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">50</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">100</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"></span><br><span class="line">        person1.start();</span><br><span class="line">        person2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="type">int</span> money;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawing</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Account account; <span class="comment">//账户</span></span><br><span class="line">    <span class="type">int</span> drawingMoney; <span class="comment">//要取多少钱</span></span><br><span class="line">    <span class="type">int</span> nowMoney; <span class="comment">// 现有的钱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Drawing</span><span class="params">(Account account, <span class="type">int</span> drawingMoney, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;钱不够，无法取出&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//sleep方法了问题发生的可能性</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        account.money = account.money - drawingMoney;</span><br><span class="line">        nowMoney += drawingMoney;</span><br><span class="line">        System.out.println(account.name + <span class="string">&quot;余额为&quot;</span> + account.money);</span><br><span class="line">        <span class="comment">//this.getName() = Thread.currentThread().getName()</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;手里的钱&quot;</span> + nowMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不安全的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeList</span> &#123;</span><br><span class="line"><span class="comment">//添加10000个线程的名字到list中,最后打印的list长度没有10000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                 list.add(Thread.currentThread().getName());</span><br><span class="line">             &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="同步实现"><a href="#同步实现" class="headerlink" title="同步实现"></a>同步实现</h3><blockquote>
<ul>
<li>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我只需要针对方法提出一套机制，这套机制就是synchronized , 它包括两种用法：<ul>
<li>synchronized方法， public synchronized void method(int args){}</li>
<li>synchronnized块</li>
</ul>
</li>
<li>synchronized方法控制对对象的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会堵塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才获得这个锁继续执行</li>
<li>若一个方法被声明为synchronized会影响效率</li>
</ul>
</blockquote>
<ol>
<li>synchronized来锁定同步方法：<ul>
<li>直接在需要同步的方法前面添加synchronized关键字即可</li>
<li>synchronized锁的是this</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeByTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyTicket</span> <span class="variable">buyTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyTicket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到了第&quot;</span> + ticketNums-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>同步块： synchronized(Obj) { }<ul>
<li>Obj称之为同步监视器</li>
<li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身或者是class（反射）</li>
<li>同步监视器的执行过程<ol>
<li>第一个线程访问，锁定同步监视器，执行其中代码</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问</li>
<li>第一个线程访问完毕，解锁同步监视器</li>
<li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeBanl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">100</span>, <span class="string">&quot;工资&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">20</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">20</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"></span><br><span class="line">        person1.start();</span><br><span class="line">        person2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="type">int</span> money;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawing</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Account account; <span class="comment">//账户</span></span><br><span class="line">    <span class="type">int</span> drawingMoney; <span class="comment">//要取多少钱</span></span><br><span class="line">    <span class="type">int</span> nowMoney; <span class="comment">// 现有的钱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Drawing</span><span class="params">(Account account, <span class="type">int</span> drawingMoney, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这里我们需要锁account，所以光在run方法后面加synchronized是没用的</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;钱不够，无法取出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//sleep方法了问题发生的可能性</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            account.money = account.money - drawingMoney;</span><br><span class="line">            nowMoney += drawingMoney;</span><br><span class="line">            System.out.println(account.name + <span class="string">&quot;余额为&quot;</span> + account.money);</span><br><span class="line">            <span class="comment">//this.getName() = Thread.currentThread().getName()</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;手里的钱&quot;</span> + nowMoney);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加1000个线程的名字到list中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                 <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                     list.add(Thread.currentThread().getName());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h2 id="线程周边知识"><a href="#线程周边知识" class="headerlink" title="线程周边知识"></a>线程周边知识</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><blockquote>
<p>实质属于函数式编程概念</p>
<ul>
<li>表达式：<ul>
<li>(params) -&gt; expression [表达式]</li>
<li>(Params) -&gt; statement[语句]</li>
<li>(params) -&gt; {statements}</li>
</ul>
</li>
</ul>
</blockquote>
<ol>
<li><p>什么是函数式接口？</p>
<ul>
<li>任何接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口</li>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</li>
</ul>
</li>
<li><p>为什么使用lambda表达式？</p>
<ol>
<li>避免匿名内部类定义过多</li>
<li>让代码看起来更简洁</li>
<li>去掉了一堆无意义代码，只剩下核心逻辑</li>
</ol>
</li>
<li><p>内部类的声明与使用的进化史：</p>
<ul>
<li><p>实现类–静态内部类–局部内部类–匿名内部类–lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Like2</span> <span class="keyword">implements</span> <span class="title class_">ILike</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I like lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">ILike</span> <span class="variable">like</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Like</span>();</span><br><span class="line">       like.lambda();</span><br><span class="line"></span><br><span class="line">      like = <span class="keyword">new</span> <span class="title class_">Like2</span>();</span><br><span class="line">      like.lambda();</span><br><span class="line">      <span class="comment">//4  局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Like3</span> <span class="keyword">implements</span> <span class="title class_">ILike</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I like lambda3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        like = <span class="keyword">new</span> <span class="title class_">Like3</span>();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5 匿名内部类</span></span><br><span class="line">        like = <span class="keyword">new</span> <span class="title class_">ILike</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I like lambda4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6 lambda简化</span></span><br><span class="line">        like = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I like lambdaEnd&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 定义一个函数式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILike</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Like</span> <span class="keyword">implements</span> <span class="title class_">ILike</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like lambda1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>lambda的总结</p>
<ul>
<li>lambda表达式在代码只有一行的情况下可以去掉花括号</li>
<li>lambda表达式能使用的前提是必须是函数式接口</li>
<li>单个参数可以去掉函数类型和括号，多个参数可以去掉函数类型，但必须都去掉，且不能去掉括号</li>
</ul>
</li>
</ol>
<h3 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h3><blockquote>
<p>真实对象和代理对象都要实现同一个接口，代理对象要代理真实角色</p>
<p>优势：</p>
<ul>
<li>代理对象可以做很多真实对象做不了的事</li>
<li>真实对象可以专注于自己的事</li>
</ul>
<p>通过这个案例了解线程创建的模式，Thread就是一个静态代理，自己的定义类只需要专注自己的事</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeddingCompany</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeddingCompany</span>(<span class="keyword">new</span> <span class="title class_">You</span>());</span><br><span class="line">        company.HappyMarry();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Marry</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">HappyMarry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">You</span> <span class="keyword">implements</span> <span class="title class_">Marry</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HappyMarry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am happy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeddingCompany</span> <span class="keyword">implements</span> <span class="title class_">Marry</span>&#123;</span><br><span class="line">    <span class="comment">//真实目标角色</span></span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeddingCompany</span><span class="params">(Marry target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HappyMarry</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="built_in">this</span>.target.HappyMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before marry&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after marry&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="线程的五种状体"><a href="#线程的五种状体" class="headerlink" title="线程的五种状体"></a>线程的五种状体</h3><blockquote>
<p>线程通过new等方法创建后就变成新生状态，一旦通过start（）方法启动就会变成就绪态，但不意味着立即执行，得看cpu调度，当被cpu调度后就进入运行态，运行之后有可能被调用了wait（）或sleep（）等方法进入阻塞态，阻塞态解除后重新进入就绪态等待执行，也有可能线程执行结束或中断，进入死亡状态，就不能再次开启了。</p>
</blockquote>
<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setPriority(int newPriority)</td>
<td>更改线程优先级</td>
</tr>
<tr>
<td>Static void sleep(long millis)</td>
<td>让当前线程休眠指定毫秒</td>
</tr>
<tr>
<td>void join()</td>
<td>等待该线程终止</td>
</tr>
<tr>
<td>static void yield()</td>
<td>暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
<tr>
<td>void interupt()</td>
<td>中断线程（不推荐）</td>
</tr>
<tr>
<td>boolean isAlive()</td>
<td>测试线程是否处于活动状态</td>
</tr>
</tbody></table>
<h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><blockquote>
<p>不推荐使用JDK提供的stop（）、destory（）方法来停止线程</p>
<p>推荐使用一个标志尾flag，当flag &#x3D;&#x3D; false就停止线程，让线程自己停下来</p>
</blockquote>
<p>推荐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span> + i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><blockquote>
<ul>
<li>Sleep(时间) 指定当前线程阻塞的毫秒数</li>
<li>Sleep 存在异常 InteruptedException</li>
<li>sleep时间到达后线程进入就绪状态</li>
<li>sleep可以模拟网络延迟、倒计时等</li>
<li>每一个对象都有一个锁，sleep不会释放锁</li>
</ul>
</blockquote>
<p><strong>模拟网络延时，放大问题的发生性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThredTest1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟延时，让结果更加显著</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;我拿到了第&quot;</span> + tickets-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模拟倒计时</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tenDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟倒计时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tenDown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(num--);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><blockquote>
<ul>
<li>让当前正在执行的线程暂停，但不堵塞</li>
<li>将线程从运行态转为就绪态</li>
<li><strong>让cpu重新调度，礼让不一定成功，看cpu心情</strong></li>
</ul>
</blockquote>
<h3 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h3><blockquote>
<ul>
<li>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li>
<li>类似于插队</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程VIP来了&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TestJoin</span> <span class="variable">testJoin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestJoin</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">200</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread is end&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//查看此时线程状态</span></span><br><span class="line">        Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (state != Thread.State.TERMINATED) &#123; <span class="comment">// 只要线程不终止，就一直输出状态</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            state = thread.getState(); <span class="comment">// 更新线程状态</span></span><br><span class="line">            System.out.println(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><blockquote>
<ul>
<li>java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按优先级决定应该调度哪个线程来执行</li>
<li>优先级高的不是一定先执行，只是先执行的比重大</li>
<li>线程的优先级用数字表示，范围从1–10<ul>
<li>Thread.MIN_PRIORITY &#x3D; 1;</li>
<li>Thread.MAX_PRIORITY &#x3D; 10;</li>
<li>Thread.NORM_PRIORITY &#x3D; 5;</li>
</ul>
</li>
<li>使用以下方法获取、改变优先级<ul>
<li>getPriority( )</li>
<li>setPriority(int x)</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + Thread.currentThread().getPriority());</span><br><span class="line">        <span class="type">myPriority</span> <span class="variable">priority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">myPriority</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(priority);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(priority);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(priority);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(priority);</span><br><span class="line">        </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.setPriority(<span class="number">1</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.setPriority(<span class="number">4</span>);</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.setPriority(Thread.MAX_PRIORITY); <span class="comment">//MAX_PRIORITY = 10</span></span><br><span class="line">        thread4.start();</span><br></pre></td></tr></table></figure>





<h3 id="守护（daemon）线程"><a href="#守护（daemon）线程" class="headerlink" title="守护（daemon）线程"></a>守护（daemon）线程</h3><blockquote>
<ul>
<li>线程分为用户线程和守护线程</li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>虚拟机不用等待守护线程执行完毕</li>
<li>例如：后台记录操作日志，监控内存，垃圾回收</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDaemon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Athread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Athread</span>();</span><br><span class="line">        <span class="type">Bthread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bthread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(bthread);</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>); <span class="comment">// 默认是false，为用户线程，true设置为守护线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(athread).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bthread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;守护&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Athread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<ul>
<li>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。</li>
<li>某一个同步块<strong>同时拥有两个以上对象的锁</strong>时就可能发生死锁</li>
</ul>
</blockquote>
<h3 id="死锁案例"><a href="#死锁案例" class="headerlink" title="死锁案例"></a>死锁案例</h3><p>死锁的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJUC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MakeUp</span> <span class="variable">gl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MakeUp</span>(<span class="number">0</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">        <span class="type">MakeUp</span> <span class="variable">gl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MakeUp</span>(<span class="number">1</span>, <span class="string">&quot;Sherly&quot;</span>);</span><br><span class="line">        gl.start();</span><br><span class="line">        gl2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lipstick</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mirror</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MakeUp</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//化妆所需要的资源，用static来保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lipstick</span> <span class="variable">lipstick</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lipstick</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Mirror</span> <span class="variable">mirror</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mirror</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    String girlName;</span><br><span class="line"></span><br><span class="line">    MakeUp(<span class="type">int</span> choice, String girlName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.choice = choice;</span><br><span class="line">        <span class="built_in">this</span>.girlName = girlName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//化妆，互相持有对方的锁，就是需要拿到对方的资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick) &#123; <span class="comment">//获得口红的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.girlName + <span class="string">&quot;获得口红的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (mirror) &#123; <span class="comment">//一秒钟后想获得镜子</span></span><br><span class="line">                    System.out.println(<span class="built_in">this</span>.girlName + <span class="string">&quot;获得镜子的锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.girlName + <span class="string">&quot;获得口红的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                    System.out.println(<span class="built_in">this</span>.girlName + <span class="string">&quot;获得镜子的锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上的例子解决死锁的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJUC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MakeUp</span> <span class="variable">gl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MakeUp</span>(<span class="number">0</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">        <span class="type">MakeUp</span> <span class="variable">gl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MakeUp</span>(<span class="number">1</span>, <span class="string">&quot;Sherly&quot;</span>);</span><br><span class="line">        gl.start();</span><br><span class="line">        gl2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lipstick</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mirror</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MakeUp</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//化妆所需要的资源，用static来保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lipstick</span> <span class="variable">lipstick</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lipstick</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Mirror</span> <span class="variable">mirror</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mirror</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    String girlName;</span><br><span class="line"></span><br><span class="line">    MakeUp(<span class="type">int</span> choice, String girlName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.choice = choice;</span><br><span class="line">        <span class="built_in">this</span>.girlName = girlName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//化妆，互相持有对方的锁，就是需要拿到对方的资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick) &#123; <span class="comment">//获得口红的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.girlName + <span class="string">&quot;获得口红的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror) &#123; <span class="comment">//一秒钟后想获得镜子</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.girlName + <span class="string">&quot;获得镜子的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.girlName + <span class="string">&quot;获得口红的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.girlName + <span class="string">&quot;获得镜子的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="死锁必要条件"><a href="#死锁必要条件" class="headerlink" title="死锁必要条件"></a>死锁必要条件</h3><blockquote>
<ul>
<li>产生死锁的四个必要条件：<ol>
<li>互斥条件 ：一个资源每次只能被一个进程会用</li>
<li>请求与保持条件 ：一个请求因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件 ：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件 ：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
</li>
<li>只需要破环任意一个或多个条件就可以避免死锁发生</li>
</ul>
</blockquote>
<h2 id="Lock（锁）"><a href="#Lock（锁）" class="headerlink" title="Lock（锁）"></a>Lock（锁）</h2><blockquote>
<ul>
<li>从JDK5.0开始，Java提供了更加强大的线程同步机制—通过显示定义同步锁对象来实现同步，同步锁使用Lock对象充当</li>
<li>java.util.concurrent.locks.Lock（可重入锁）接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应该先获得Lock对象</li>
<li>ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁</li>
</ul>
</blockquote>
<ul>
<li><p>声明Lock的基本结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//保证线程安全的代码</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestLock2</span> <span class="variable">testLock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestLock2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(testLock2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(testLock2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(testLock2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLock2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//定义lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> (ticketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(ticketNums--);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="synchronized、lock"><a href="#synchronized、lock" class="headerlink" title="synchronized、lock"></a>synchronized、lock</h3><blockquote>
<ul>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁,JVM将话费较少的时间来调度线程，性能更好，、。并且有更好的扩展性（提供更多子类）</li>
<li>优先使用顺序：<ul>
<li>Lock &gt; 同步代码块（已经进入了方法体，分配了响应资源） &gt; 同步方法（在方法体之外）</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><blockquote>
<p>生产者消费者问题</p>
<ul>
<li>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费</li>
<li>如果仓库中没有产品，则生产者将产品放入仓库否则停止生产并等待，直到仓库中的产品被消费者取走为止</li>
<li>如果仓库中有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止</li>
</ul>
<p>分析：</p>
<ul>
<li>这是一个线程同步问题，生产者消费者共享一个资源，并且生产者和消费者之间相互依赖，互为条件</li>
<li>对于生产者，没有生产产品之前，要同志消费者等待，而生产了产品之后，又需要马上通知消费者消费</li>
<li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产以供消费</li>
<li>在这个问题中仅有synchronized是不够的<ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步</li>
<li>synchronized不能用来实现不同线程之间的消息传递（通信）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="线程通信方法"><a href="#线程通信方法" class="headerlink" title="线程通信方法"></a>线程通信方法</h3><ul>
<li>wait（）：表示线程一直等待，直到其他线程通知，&#x3D;&#x3D;与sleep不同，会释放锁&#x3D;&#x3D;</li>
<li>wait（long timeout）：指定等待的毫秒数</li>
<li>notify（）：唤醒一个处于等待状态的线程</li>
<li>notifyAll（）：唤醒一个对象上所有调用wait（）方法的线程，优先级别高的线程优先调度</li>
<li>以上方法都是Object类方法，都只能在同步方法或同步块中使用，否则会报错</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol>
<li><p>并发协作模型“生产者&#x2F;消费者模式” – <strong>管程法</strong></p>
<ul>
<li><p>生产者 ：负责生产数据的模块（可能是方法、对象、线程、进程）</p>
</li>
<li><p>消费者 ：负责生产数据的模块（可能是方法、对象、线程、进程）</p>
</li>
<li><p>缓冲区 ：消费者不能直接使用生产者的数据，他们之间有个缓冲区</p>
</li>
<li><p>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿数据</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynContainer</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Productor</span>(container).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Productor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(SynContainer container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            container.push(<span class="keyword">new</span> <span class="title class_">Production</span>(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产了&quot;</span> + i + <span class="string">&quot;只鸡&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(SynContainer container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费了第&quot;</span> + container.pop().id + <span class="string">&quot;只鸡&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Production</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Production</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynContainer</span> &#123;</span><br><span class="line">    <span class="comment">//容器大小</span></span><br><span class="line">    Production[] productions = <span class="keyword">new</span> <span class="title class_">Production</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//容器计数器</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Production production)</span> &#123;</span><br><span class="line">        <span class="comment">//如果容器满了就需要等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == productions.length) &#123;</span><br><span class="line">            <span class="comment">//通知消费者消费，生产者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果容器没有满，我们就需要丢入产品</span></span><br><span class="line">        productions[count++] = production;</span><br><span class="line">        <span class="comment">//通知消费者消费</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Production <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待生产</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="type">Production</span> <span class="variable">production</span> <span class="operator">=</span> productions[count];</span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> production;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>并发协作模型“生产者&#x2F;消费者模式” – <strong>信号灯法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPC2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Player</span>(tv).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者--演员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.tv.play(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.tv.play(<span class="string">&quot;B &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者--观众</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Watcher</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品--节目</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="comment">//言演员表演，观众等待</span></span><br><span class="line">    <span class="comment">//观众观看，演员等待</span></span><br><span class="line">    String voice; <span class="comment">//表演的节目</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//表演</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">play</span><span class="params">(String voice)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;演员表演了&quot;</span> + voice);</span><br><span class="line">        <span class="comment">//通知观众观看</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        <span class="built_in">this</span>.voice = voice;</span><br><span class="line">        <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;观众观看了&quot;</span> + voice);</span><br><span class="line">        <span class="comment">//通知演员表演</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<ul>
<li><p>问题：</p>
<ul>
<li>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</li>
</ul>
</li>
<li><p>解决思路：</p>
<ul>
<li>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。</li>
<li>可以避免频繁创建销毁、实现重复利用。</li>
</ul>
</li>
<li><p>好处：</p>
<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中的线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize ：线程池大小</li>
<li>maxinumPoolSize ：最大线程数</li>
<li>keepAliveTime ：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h3><blockquote>
<ul>
<li>JDK5.0起提供了线程池相关的API，ExecutorService 和 Executors</li>
<li>ExecutorService ：真正的线程池接口，常见子类ThreadPoolExecutor<ul>
<li>void executor（Runnable command）：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable</li>
<li>&lt;&gt;Future&lt;&gt; submit（Callable&lt;&gt; task) : 执行任务，有返回值，一般用来执行callable</li>
<li>void shutdown（）：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">//参数为池子的大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><blockquote>
<ul>
<li>File 类主要是 Java 为文件相关操作（如删除、创建）而设计的类</li>
</ul>
</blockquote>
<h3 id="File-类三种构造方法"><a href="#File-类三种构造方法" class="headerlink" title="File 类三种构造方法"></a>File 类三种构造方法</h3><blockquote>
<p>构造方法：</p>
<ul>
<li>File(String pathName)：通过给定路径名，字符串转换为抽象的路径名来创建新的 File 实例</li>
<li>File(String parents, String childs)：从父路径名，字符串和子路径名，字符串创建新的 File 实例</li>
<li>File(File parent, String child)：从父抽象路径名和子路径名创建新的实例</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializeFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过路径名来创建 File</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFile_1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 声明出我的电脑的 temporary 文件夹的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tempPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/temporary&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;/ioDemo.txt&quot;</span>;</span><br><span class="line">        <span class="comment">// 通过该路径创建出抽象的 File 对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(tempPath + fileName);</span><br><span class="line">        System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过父子路径创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFile_2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tempPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/temporary&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;ioDemo.txt&quot;</span>; <span class="comment">// 注意这里是不需要带反斜杠的</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(tempPath, fileName);</span><br><span class="line">        System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过父 File 对象和子路径创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFile_3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tempPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/temporary&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;ioDemo.txt&quot;</span>; <span class="comment">// 注意这里是不需要带反斜杠的</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(tempPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, fileName);</span><br><span class="line">        System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="创建文件或路径"><a href="#创建文件或路径" class="headerlink" title="创建文件或路径"></a>创建文件或路径</h3><blockquote>
<p>File 类创建文件或路径的方法：</p>
<ul>
<li>public boolean createNewFile( )：当具有该文件名的文件呢不存在时，创建由该抽象路径命名的新文件</li>
<li>public boolean mkdir( )：创建由此抽象路径命名的目录</li>
<li>public boolean mkdirs( )：创建由此抽象路径命名的目录，包括任何必须但不存在的目录</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需求：在 /Users/lei/Desktop/temporary 目录下创建 newFile.html 文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNewFileDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/newFile.html&quot;</span>);</span><br><span class="line">        System.out.println(file.createNewFile()); <span class="comment">// 如果文件已存在，返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需求：在 /Users/lei/Desktop/temporary 目录下创建 newdir 目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mkdirDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/newdir&quot;</span>);</span><br><span class="line">        System.out.println(file.mkdir());</span><br><span class="line">        <span class="comment">// 如果 file 对象的抽象路径有问题，那么创建新目录就会失败</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/x/newdir&quot;</span>);</span><br><span class="line">        System.out.println(file2.mkdir());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需求：在测试目录下创建多级目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mkdirsDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/newdir&quot;</span>);</span><br><span class="line">        System.out.println(file.mkdirs());</span><br><span class="line">        <span class="comment">// 如果 file 对象的抽象路径有问题，那么会全部创建新的</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/x1/x2/newdir&quot;</span>);</span><br><span class="line">        System.out.println(file2.mkdirs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="File-类常见判断方法"><a href="#File-类常见判断方法" class="headerlink" title="File 类常见判断方法"></a>File 类常见判断方法</h3><blockquote>
<ul>
<li>boolean isDirectory( )：判断是否是文件夹</li>
<li>boolean isFile( )：判断是否是文件</li>
<li>boolean exists( )：判断文件是否存在</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalFunctions</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NormalFunctions</span>().normalJudgeFunctions();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">normalJudgeFunctions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否是目录</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;it is a directory&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;it is not a directory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否是文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;it is a file&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;it is not a file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断 file 对象路面的路径是否存在(也可以判断目录是否存在）</span></span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;the file is exists&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;the file is not exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="File-类常见获取方法"><a href="#File-类常见获取方法" class="headerlink" title="File 类常见获取方法"></a>File 类常见获取方法</h3><blockquote>
<ul>
<li>getPath</li>
<li>getAbsolutePath</li>
<li>getName</li>
<li>list</li>
<li>listFiles</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">normalGetFunctions</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing&quot;</span>);</span><br><span class="line">       <span class="comment">// 获取绝对(完整)路径</span></span><br><span class="line">       System.out.println(file.getAbsolutePath());</span><br><span class="line">       <span class="comment">// 抽象路径名转化为字符串</span></span><br><span class="line">       System.out.println(file.getPath());</span><br><span class="line">       <span class="comment">// 获取文件或文件夹的名字</span></span><br><span class="line">       System.out.println(file.getName());</span><br><span class="line">       <span class="comment">// 获取文件夹下所有文件,返回字符串数组</span></span><br><span class="line">       <span class="keyword">for</span> (String name : file.list()) &#123;</span><br><span class="line">           System.out.println(name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取文件夹下所有文件，返回 file 数组</span></span><br><span class="line">       <span class="keyword">for</span> (File file1 : file.listFiles()) &#123;</span><br><span class="line">           System.out.println(file1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h3 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h3><blockquote>
<p>绝对路径和相对路径的区别</p>
<ol>
<li>绝对路径是指文件在硬盘上真正群在的路径</li>
<li>相对路径是指 java 工程中要访问的文件相对于当前文件的路径</li>
</ol>
</blockquote>
<p>以下demo展示了他们之间的区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">twoPathsCompare</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">       System.out.println(file.createNewFile());</span><br><span class="line">       System.out.println(file.getAbsolutePath());</span><br><span class="line">       System.out.println(file.getPath());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>会发现代码默认在项目下创建了一个文件</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-07-19%2000.32.10.png" style="zoom:50%">





<blockquote>
<p>这就会有一个问题：绝对路径是写死的，如果将该代码放到其他电脑上运行就可能会找不到该路径<br>所以我们呢应该使用相对路径动态获取路径</p>
</blockquote>
<h3 id="File-类删除操作"><a href="#File-类删除操作" class="headerlink" title="File 类删除操作"></a>File 类删除操作</h3><h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><blockquote>
<ul>
<li>delete( )：删除文件或者是文件夹<br>如果删除的是文件路径，则直接删除<br>如果删除的是一个文件夹路径，则先将文件夹里面的东西删除，再删除文件夹</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/x1/x2&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/x1/x2/test.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DeleteCase</span>().deleteDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeDirAndFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(file.mkdirs());</span><br><span class="line">        System.out.println(file1.createNewFile());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 直接删除会失败</span></span><br><span class="line">        System.out.println(file.delete());</span><br><span class="line">        <span class="comment">// 先把里面的文件删除干净才可以删除文件夹</span></span><br><span class="line">        System.out.println(file1.delete());</span><br><span class="line">        System.out.println(file.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="File-类-for-循环删除"><a href="#File-类-for-循环删除" class="headerlink" title="File 类 for 循环删除"></a>File 类 for 循环删除</h4><blockquote>
<p>如果要删除某个文件夹，但是该文件夹下有多个文件，需要用 for 循环把文件删干净再删除文件夹</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 已经创建好了目录和文件 x1/x2 下有 4 个test文件,代码省略</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">deleteFilePath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/x1/x2&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (deleteFilePath.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;要删除的是一个文件夹目录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DeleteCase</span>().deleteFiles(deleteFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteFiles</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">// 先删除目录下所有文件</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除的文件名：&quot;</span> + f.getAbsolutePath());</span><br><span class="line">            f.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再删除目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除的文件夹：&quot;</span> + file.getPath());</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="File-类递归删除"><a href="#File-类递归删除" class="headerlink" title="File 类递归删除"></a>File 类递归删除</h4><blockquote>
<p>准备了这样一个测试目录：</p>
<ul>
<li>a&#x2F;<ul>
<li>b1&#x2F;test.java</li>
<li>b2&#x2F;<ul>
<li>c1&#x2F;test.java</li>
<li>c2&#x2F;<ul>
<li>Test1.java</li>
<li>test2.java</li>
</ul>
</li>
</ul>
</li>
<li>Test.java</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="IO-流概述"><a href="#IO-流概述" class="headerlink" title="IO 流概述"></a>IO 流概述</h2><blockquote>
<ul>
<li>流是一种抽象概念，是对数据传输的总称，也就是说数据在设备之间的传输称为流</li>
<li>常见的应用：文件上传、下载、复制等</li>
<li>输入：input：将硬盘中的数据读取到内存中</li>
<li>输出：output：将程序中的数据写入到赢盘中</li>
</ul>
</blockquote>
<h3 id="IO-流的分类"><a href="#IO-流的分类" class="headerlink" title="IO 流的分类"></a>IO 流的分类</h3><blockquote>
<ol>
<li>根据数据流向分类：<ul>
<li>输入流：读数据，将硬盘中的数据读取到内存中</li>
<li>输出流：写数据，将程序中的数据写入到赢盘中</li>
</ul>
</li>
<li>按照数据类型来分：<ul>
<li>字节流：字节输入流、字节输出流</li>
<li>字符流：字符输入流、字符输出流</li>
</ul>
</li>
<li>IO 流应用场景：<ul>
<li>纯文本文件：优先使用字符流</li>
<li>图片、视频、音频等二进制文件：优先使用字节流</li>
<li>不确定文件类型：优先</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节流写入及关闭"><a href="#字节流写入及关闭" class="headerlink" title="字节流写入及关闭"></a>字节流写入及关闭</h3><h4 id="字节流写入数据"><a href="#字节流写入数据" class="headerlink" title="字节流写入数据"></a>字节流写入数据</h4><blockquote>
<p>字节流写入数据常用的三种方式：</p>
<ul>
<li>write (int b)：将指定的字节写入到此文件输出流，一次写一个字节数据</li>
<li>write (byte[] b)：将 b.length 字节从指定的字节数据写入到</li>
<li>write ((byte[], int off, int len))</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputFileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入单个字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeDemo1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 直接在项目里面创建文件这样好观察</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;outtest.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        <span class="comment">// 每次将单个字节数据写入磁盘，效率很低</span></span><br><span class="line">        fileOutputStream.write(<span class="number">97</span>);</span><br><span class="line">        fileOutputStream.write(<span class="number">98</span>);</span><br><span class="line">        fileOutputStream.write(<span class="number">99</span>);</span><br><span class="line">        fileOutputStream.write(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeByteArray</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;outtest.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>&#125;;</span><br><span class="line">        fileOutputStream.write(bytes);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeByteOff</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;outtest.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>&#125;;</span><br><span class="line">        fileOutputStream.write(bytes, <span class="number">0</span>, bytes.length - <span class="number">2</span>);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="写入数据换行和追加写"><a href="#写入数据换行和追加写" class="headerlink" title="写入数据换行和追加写"></a>写入数据换行和追加写</h4><blockquote>
<p>换行就写入一个 “\n”</p>
<p>追加就让输出流构造器传入一个 true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputFileDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 换行写以及追加写</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writenextLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;outtest.txt&quot;</span>));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStreamContinue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;outtest.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello output stream&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            fileOutputStream.write(str.getBytes());</span><br><span class="line">            <span class="comment">// 换行</span></span><br><span class="line">            fileOutputStream.write(<span class="string">&quot;\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        fileOutputStreamContinue.write(<span class="string">&quot;追加内容&quot;</span>.getBytes());</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        fileOutputStreamContinue.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="正确关闭资源"><a href="#正确关闭资源" class="headerlink" title="正确关闭资源"></a>正确关闭资源</h4><blockquote>
<p>在之前的代码中，我们在关闭输出流资源时都是直接 close( ),这么做是不对的，因为代码很有可能走不到 close 方法就出错中断，所以第一个优化的点是将 close 方法放在 finally 块里，保证执行.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeStreamCorrectly</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;outtest.txt&quot;</span>);</span><br><span class="line">           fileOutputStream.write(<span class="string">&quot;close test&quot;</span>.getBytes());</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 模拟出错</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               fileOutputStream.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>但是这样也是不够的，因为 fileOutputStream 有可能初始化失败，走到 finally 的时候是 null，无法调用 close 方法<br>所以需要在 finall 块里做一个判空</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeStreamCorrectly</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;j:outtest.txt&quot;</span>);</span><br><span class="line">           fileOutputStream.write(<span class="string">&quot;close test&quot;</span>.getBytes());</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   fileOutputStream.close();</span><br><span class="line">                   System.out.println(<span class="string">&quot;close succeed&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h3 id="字节流读取"><a href="#字节流读取" class="headerlink" title="字节流读取"></a>字节流读取</h3><h4 id="字节流读取文件"><a href="#字节流读取文件" class="headerlink" title="字节流读取文件"></a>字节流读取文件</h4><blockquote>
<p>read（）方法可以读取文件内容，默认一个字节一个字节读，读到末尾时返回 -1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reedFile</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;inputtest.txt&quot;</span>);</span><br><span class="line">           <span class="type">int</span> data;</span><br><span class="line">           <span class="keyword">while</span> ((data = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">               System.out.print((<span class="type">char</span>) data);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   fileInputStream.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h4 id="字节流复制数据"><a href="#字节流复制数据" class="headerlink" title="字节流复制数据"></a>字节流复制数据</h4><blockquote>
<p>完成以下需求：</p>
<p>将电脑上 temporary &#x2F; testing 目录下的 a 目录中的 inputtest.txt 文件复制到 同目录下的 b 目录中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">copyFrom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/a/inputtest.txt&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">copyToPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/temporary/testing/b/&quot;</span> + copyFrom.getName();</span><br><span class="line">        <span class="type">File</span> <span class="variable">copyTo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(copyToPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            copyTo.createNewFile(); <span class="comment">// 先创建复制的文件</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(copyFrom);</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(copyTo);</span><br><span class="line">            <span class="type">int</span> inData;</span><br><span class="line">            <span class="keyword">while</span> ((inData = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(inData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h4 id="读取字节数组"><a href="#读取字节数组" class="headerlink" title="读取字节数组"></a>读取字节数组</h4><blockquote>
<p>以字节数组读取文件时需要注意以下点：</p>
<ul>
<li>一般来说，汉字占 3 个字节，字母占 1 个字节</li>
<li>换行符也是占字节的，具体占几个字节看操作系统<br>windows 系统一般占 2 个字节，因为他的换行符是 \r\n<br>mac 系统是 1 个字节，\n</li>
<li>字节数组在读取数据时是重复使用的，假设字节数组长度为5，倒数第二次读取的数据是 abcde，还剩 fgh 没有读<br>那么最后一次读取完之后字节数组里的内容是 fghde</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readByByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="comment">// 文件里的内容是：abcdefgh</span></span><br><span class="line">       <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;inputtest.txt&quot;</span>);</span><br><span class="line">       <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(data);</span><br><span class="line">       System.out.println(len);</span><br><span class="line">       System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">       len = in.read(data);</span><br><span class="line">       System.out.println(len);</span><br><span class="line">       <span class="comment">// 第二个参数的含义是 从 offset 下标开始读 x 个，并不是下标</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">       in.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="循环读取大文件"><a href="#循环读取大文件" class="headerlink" title="循环读取大文件"></a>循环读取大文件</h4><blockquote>
<p>循环读取时有一个小细节要注意，while 循环的条件判断写 &gt; 0 或者 !&#x3D; -1 都可以<br>因为只要读取不到内容都会返回 -1<br>更多的是使用 ！&#x3D;  -1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readBigData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;inputtest.txt&quot;</span>);</span><br><span class="line">       <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="type">int</span> len;</span><br><span class="line">       <span class="comment">// while 条件也可以写 (len = in.read(bytes)) &gt; 0</span></span><br><span class="line">       <span class="keyword">while</span> ((len = in.read(bytes)) ！= -<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>









<h3 id="字节流应用"><a href="#字节流应用" class="headerlink" title="字节流应用"></a>字节流应用</h3><h4 id="字节流复制图片"><a href="#字节流复制图片" class="headerlink" title="字节流复制图片"></a>字节流复制图片</h4><blockquote>
<p>现完成以下需求：</p>
<p>将电脑上 temporary &#x2F; testing 目录下的 a 目录中的 龙猫.jpeg 文件复制到 同目录下的 b 目录中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyPicture</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/a/龙猫.jpeg&quot;</span>);</span><br><span class="line">       <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/b/龙猫.jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="type">int</span> len;</span><br><span class="line">       <span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">           out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>













<h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><blockquote>
<ul>
<li>传统方式一个字节一个字节读或者写数据会频繁的发生系统内核调用（用户态 -&gt; 内核态）效率很低</li>
<li>每发生一次从磁盘读取数据到内存中就会发生一次系统转换</li>
<li>我们可以使用字节缓冲流，缓冲区是一个内存区域概念，以块的形式读取或写入数据，减少调用频率</li>
<li>字节缓冲流的缓冲区大小默认是 8k，即 8192 字节</li>
</ul>
</blockquote>
<h3 id="字节缓冲流读写"><a href="#字节缓冲流读写" class="headerlink" title="字节缓冲流读写"></a>字节缓冲流读写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedStreamCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BufferedOutputStreamDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1 创建了字节输出流对象，指定读取磁盘文件的路径</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;outputBuffered.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2 创建一个 bufferedInputStream 并指定输出流对象</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream);</span><br><span class="line">        <span class="comment">// 3 写入</span></span><br><span class="line">        bufferedOutputStream.write(<span class="string">&quot;hello buffered stream&quot;</span>.getBytes());</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BufferedInputStreamDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;outputBuffered.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="字节缓冲流复制视频对比"><a href="#字节缓冲流复制视频对比" class="headerlink" title="字节缓冲流复制视频对比"></a>字节缓冲流复制视频对比</h3><blockquote>
<p>用字节流和缓冲流分别去复制一个视频比较执行速度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopySpeedCompare</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用缓冲流读取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyByBufferedStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建缓冲输入输出流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/a/testVideo.mp4&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/b/testVideo.mp4&quot;</span>);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream);</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bufferedOutputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用缓冲流复制视频耗时：&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyByNormalStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/a/testVideo.mp4&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/b/testVideo.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用字节流复制视频耗时：&quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行效果如下：使用缓冲流耗时 60 毫秒，使用字节流耗时 90 毫秒，如果用更大的视频差距会更夸张</p>
<h2 id="编码相关知识"><a href="#编码相关知识" class="headerlink" title="编码相关知识"></a>编码相关知识</h2><h3 id="汉字的占用空间"><a href="#汉字的占用空间" class="headerlink" title="汉字的占用空间"></a>汉字的占用空间</h3><blockquote>
<ul>
<li>一个汉字如果是 GBK 编码，占用 2 个字节</li>
<li>一个汉字如果是 UTF-8 编码，占用 3 个字节</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">// 存储的是英文字符，占用 1 个字节</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;你好呀&quot;</span>; <span class="comment">// 存储中文占用 3 个字符（使用 utf-8）编码</span></span><br><span class="line"></span><br><span class="line">    System.out.println(str1.getBytes().length); <span class="comment">// 3</span></span><br><span class="line">    System.out.println(str2.getBytes().length); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(str1.getBytes()));</span><br><span class="line">    System.out.println(Arrays.toString(str2.getBytes()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改编码方式</span></span><br><span class="line">    System.out.println(str2.getBytes(<span class="string">&quot;GBK&quot;</span>).length); <span class="comment">// 6</span></span><br><span class="line">    System.out.println(Arrays.toString(str2.getBytes(<span class="string">&quot;GBK&quot;</span>)));</span><br></pre></td></tr></table></figure>





<h3 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h3><blockquote>
<ul>
<li>当字节流读取存储的中文数据时可能会发生乱码，可以使用字符流</li>
<li>字符流 &#x3D; 字节流 + 编码表</li>
<li>编码表可以看作一个字典，表示的是人类的字符和机器语言（二进制）之间的关系，例如 ASCII 表</li>
<li>GB 2312：识别数千中文</li>
<li>GBK： 识别 2 w 多中文，两个字节表是一个字符</li>
<li>GB18030: GBK 的升级</li>
<li>Unicode：世界计算机协会制定的通用码表，两个字节表示一个字符</li>
<li>UTF-8: Unicode 升级版，汉字基本上都是 3 个字节</li>
</ul>
</blockquote>
<h2 id="3-2-字节流"><a href="#3-2-字节流" class="headerlink" title="3.2 字节流"></a>3.2 字节流</h2><h3 id="3-2-1-IO流原理及分类"><a href="#3-2-1-IO流原理及分类" class="headerlink" title="3.2.1 IO流原理及分类"></a>3.2.1 IO流原理及分类</h3><blockquote>
<ul>
<li>IO流：Input、Output缩写，用于数据处理，如读、写文件，网络通讯等</li>
<li>Java程序中，对于数据的输入、输出操作以流（Stream）的方式进行</li>
<li>java.io包下提供了各种流类接口，用以获取不同种类数据，并通过方法输入或输出数据</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>流的分类：</p>
<ul>
<li>按操作数据单位不同分为：<ul>
<li>字节流（8 bit）：保证对二进制文件无损操作</li>
<li>字符流（按字符）：文本文件</li>
</ul>
</li>
<li>按数据流的流向不同<ul>
<li>输入流</li>
<li>输出流</li>
</ul>
</li>
<li>按流的角色不同<ul>
<li>节点流</li>
<li>处理流&#x2F;包装流</li>
</ul>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<ul>
<li>Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的</li>
<li>由这四个类派生出来的子类名称都是以其父类的名字作为子类的名后缀</li>
<li>上面四个类都是抽象类，使用时必须创建他们的实现子类的对象</li>
</ul>
<h3 id="3-2-2-InputStream"><a href="#3-2-2-InputStream" class="headerlink" title="3.2.2 InputStream"></a>3.2.2 InputStream</h3><blockquote>
<p><strong>InputStream：字节输入流，是所有类字节输入流的超类</strong></p>
<p>InputStream的常用子类</p>
<ul>
<li>FileInputStream：文件输入流</li>
<li>BufferedInputStream：缓冲字节输入流</li>
<li>ObjectInputStream：对象字节输入流</li>
</ul>
</blockquote>
<img src="/Users/lei/Desktop/Typora笔记/图片/截屏2022-06-23 15.06.32.png" alt="截屏2022-06-23 15.06.32" style="zoom:50%;" />



<p><strong>FileInputStream</strong></p>
<ul>
<li><p>用FileInputStream读取hello.txt文件，并显示其内容<br>read（）：读取单个字节<br>read（byte[]）：按字节数组读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read（）读取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile_1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/test/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建了fileInputStream对象用于读取文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="comment">//read从流中读取一个字节数据，如果没有输入可用此方法将会被阻止</span></span><br><span class="line">            <span class="comment">//如果返回-1，表示读取完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)readData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">//一定要记得关闭这个流，因为流是一种资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read（byte[]）读取</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile_2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/test/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>]; <span class="comment">//一次读8个字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="keyword">while</span> ((readLen = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, readLen));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-3-OutputStream"><a href="#3-2-3-OutputStream" class="headerlink" title="3.2.3 OutputStream"></a>3.2.3 OutputStream</h3><p><strong>类图</strong></p>
<img src="/Users/lei/Desktop/Typora笔记/图片/截屏2022-06-23 19.41.03.png" alt="截屏2022-06-23 19.41.03" style="zoom:50%;" />



<p><strong>FileOutputStream</strong></p>
<p>案例：<br>在hello.txt文件中写入内容，如果文件不存在会创建文件</p>
<p>方式1:当我们采用fileOutputStream &#x3D; new FileOutputStream(filePath);方式去构造对象时，每次新写入的内容会覆盖原来的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile_1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建FileOutputStream对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/test/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath);</span><br><span class="line">            <span class="comment">//写入一个字节</span></span><br><span class="line">            fileOutputStream.write(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">            <span class="comment">//写入一个字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">            fileOutputStream.write(str.getBytes());</span><br><span class="line">            <span class="comment">//指定起点和偏移量</span></span><br><span class="line">            fileOutputStream.write(str.getBytes(), <span class="number">0</span>, str.length() - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方式2:fileOutputStream &#x3D; new FileOutputStream(filePath，true);方式创建的对象是把内容追加到文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile_2</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//创建FileOutputStream对象</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/test/hello.txt&quot;</span>;</span><br><span class="line">       <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath, <span class="literal">true</span>);</span><br><span class="line">           <span class="comment">//写入一个字节</span></span><br><span class="line">           fileOutputStream.write(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">           <span class="comment">//写入一个字符串</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;234&quot;</span>;</span><br><span class="line">           fileOutputStream.write(str.getBytes());</span><br><span class="line">           <span class="comment">//指定起点和终点</span></span><br><span class="line">           fileOutputStream.write(str.getBytes(), <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               fileOutputStream.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>









<h3 id="3-3-1-文件拷贝"><a href="#3-3-1-文件拷贝" class="headerlink" title="3.3.1 文件拷贝"></a>3.3.1 文件拷贝</h3><blockquote>
<p>主要思路：</p>
<ol>
<li>创建两个File 对象，用于将文件读入内存并且再写入到存储</li>
<li>程序的逻辑应该是读入一部分数据就立即写入文件（效率更高且避免内存不够的问题）<br>使用循环来实现</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/图片/可达鸭.jpeg&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">targetFilePath</span> <span class="operator">=</span> <span class="string">&quot;/Users/lei/Desktop/test/可达鸭2.jpeg&quot;</span>;</span><br><span class="line">       <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath);</span><br><span class="line">           fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFilePath);</span><br><span class="line">           <span class="comment">//定义一个字节数组提高读取效率</span></span><br><span class="line">           <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">           <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> ((readLen = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//读取到后就写入到文件</span></span><br><span class="line">               fileOutputStream.write(buffer, <span class="number">0</span>, readLen); <span class="comment">// 一定要用这个方法</span></span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;Copy Success&quot;</span> );</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                   fileInputStream.close();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                   fileOutputStream.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



















<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="字符流读写"><a href="#字符流读写" class="headerlink" title="字符流读写"></a>字符流读写</h3><h4 id="字符流基础使用"><a href="#字符流基础使用" class="headerlink" title="字符流基础使用"></a>字符流基础使用</h4><blockquote>
<p>既然使用了字符流，那么就要留心编码方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这里指定的编码方式是 GBK，那么 idea 打开就是乱码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;writer.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&quot;你好\n字符流\n再见&quot;</span>);</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;写入成功，开始读取&quot;</span>);</span><br><span class="line">        <span class="comment">// 默认的编码是 utf-8,使用其他的就会乱码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;writer.txt&quot;</span>));</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStreamReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h4 id="字符流写入的5种方式"><a href="#字符流写入的5种方式" class="headerlink" title="字符流写入的5种方式"></a>字符流写入的5种方式</h4><blockquote>
<ol>
<li>单个字符写入</li>
<li>写入 char 数组</li>
<li>写入带偏移量的 char 数组</li>
<li>写入字符串</li>
<li>写入带偏移量的字符串</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(newFileOutputStream(<span class="string">&quot;outputWriter.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 单个字符写入</span></span><br><span class="line">        outputStreamWriter.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&#x27;你&#x27;</span>);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 写入 char 数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;你&#x27;</span>, <span class="string">&#x27;好&#x27;</span>&#125;;</span><br><span class="line">        outputStreamWriter.write(chars);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 写入带偏移量的 char 数组</span></span><br><span class="line">        outputStreamWriter.write(chars, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 写入字符串</span></span><br><span class="line">        outputStreamWriter.write(<span class="string">&quot;你好字符流&quot;</span>);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 写入带偏移量的字符串</span></span><br><span class="line">        outputStreamWriter.write(<span class="string">&quot;你好字符流&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







































<h2 id="3-4-节点流、处理流"><a href="#3-4-节点流、处理流" class="headerlink" title="3.4 节点流、处理流"></a>3.4 节点流、处理流</h2><blockquote>
<p><strong>节点流</strong></p>
<ul>
<li>可以从一个特定的数据源<strong>读写数据</strong></li>
<li>低层数据流，因为会直接操作数据源，效率高，但是功能并不强大</li>
</ul>
<p><strong>处理流</strong></p>
<ul>
<li>也叫<strong>包装流</strong></li>
<li>是连接在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能</li>
<li>BufferedReader 类中有属性 Reader， 即可以封装一个节点流，该节点流是任意的，只要是reader的子类</li>
</ul>
</blockquote>
<p><strong>节点流和处理流一览表</strong></p>
<img src="/Users/lei/Desktop/Typora笔记/图片/节点流和处理流.png" alt="节点流和处理流" style="zoom:50%;" />





<h3 id="3-4-1-节点、字节流关系"><a href="#3-4-1-节点、字节流关系" class="headerlink" title="3.4.1 节点、字节流关系"></a>3.4.1 节点、字节流关系</h3><blockquote>
<p><strong>节点流和处理流的区别和联系</strong></p>
<ul>
<li>节点流是底层流&#x2F;低级流，直接和数据源相接</li>
<li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li>
<li>处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与设计源相连</li>
</ul>
<p><strong>处理流的</strong></p>
</blockquote>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><hr>
<h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>Java泛型（generics）是JDK5中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许我们在编译时检测到非法的类型数据结构。</p>
<p>泛型的本质就是参数化类型，也就是所操作的数据类型被指定为一个参数。</p>
</blockquote>
<h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h3><blockquote>
<ul>
<li>类型安全</li>
<li>消除了强制类型转换</li>
</ul>
</blockquote>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><h3 id="泛型类定义"><a href="#泛型类定义" class="headerlink" title="泛型类定义"></a>泛型类定义</h3><blockquote>
<ul>
<li><p>泛型类的定义语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &lt;泛型标识， 泛型标识....&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 变量名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用的泛型标识：T、E、K、V</p>
</li>
</ul>
</blockquote>
<p><strong>案例：假设一个 Student 类的学号不知道是 Number 类型还是 String 类型，就可以用泛型解决</strong></p>
<p>定义一个泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 传入字符串</span></span><br><span class="line">       <span class="type">Student</span> <span class="variable">studentStr</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>&lt;String&gt;();</span><br><span class="line">       studentStr.setNo(<span class="string">&quot;10001&quot;</span>);</span><br><span class="line">       System.out.println(studentStr.getNo());</span><br><span class="line">      <span class="comment">// 传入Integer</span></span><br><span class="line">       <span class="type">Student</span> <span class="variable">studentNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>&lt;Integer&gt;();</span><br><span class="line">       studentNum.setNo(<span class="number">10001</span>);</span><br><span class="line">        System.out.println(studentStr.getNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="泛型类的继承"><a href="#泛型类的继承" class="headerlink" title="泛型类的继承"></a>泛型类的继承</h3><blockquote>
<p>从泛型类派生子类</p>
<ul>
<li>若子类也是泛型类，子类和父类的泛型类型要一致</li>
<li>若子类不是泛型类，父类要明确泛型的数据类型</li>
</ul>
</blockquote>
<p>父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> E value;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(E value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child_1</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型子类的扩展：泛型可以扩展，但子类一定要有一个和父类相同，否则父类无法接受数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child_1</span>&lt;T,E,K&gt; <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非泛型子类：如果不指定的话创建子类对象时无法指定父类的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child_2</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><h3 id="泛型接口定义"><a href="#泛型接口定义" class="headerlink" title="泛型接口定义"></a>泛型接口定义</h3><blockquote>
<p>interface 接口名称&lt;泛型标识，泛型标识…&gt; {<br>泛型标识 方法名；<br>}</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="泛型接口的实现"><a href="#泛型接口的实现" class="headerlink" title="泛型接口的实现"></a>泛型接口的实现</h3><blockquote>
<p>泛型接口的使用：</p>
<ul>
<li>实现类不是泛型类，接口要明确数据类型</li>
<li>实现类是泛型类，实现类和泛型类的数据类型要一样</li>
</ul>
</blockquote>
<ul>
<li><p>子类不是泛型类且没有指定接口的泛型，那么实现方法默认以Object返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类不是泛型类，但指定了接口的泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类是泛型类,同样也可以扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T,E&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="泛型接口和泛型类区别"><a href="#泛型接口和泛型类区别" class="headerlink" title="泛型接口和泛型类区别"></a>泛型接口和泛型类区别</h2><blockquote>
<p>当声明了一个反省接口，但是方法不是泛型方法时，其实现类</p>
</blockquote>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><h3 id="泛型方法声明"><a href="#泛型方法声明" class="headerlink" title="泛型方法声明"></a>泛型方法声明</h3><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T, E,...&gt; 返回值类型 方法名(形参列表) &#123;</span><br><span class="line">  方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>public 与返回值之间的尖括号T十分重要，可以理解为声明此方法为泛型方法</li>
<li>只有声明了尖括号T的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法</li>
<li>尖括号T表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T</li>
<li>与泛型类的定义一样，此处T可以写为任意标识，常见的如T、E、K、V，等形式的参数常用于表示泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; E <span class="title function_">getProduct</span><span class="params">(ArrayList&lt;E&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="泛型方法调用"><a href="#泛型方法调用" class="headerlink" title="泛型方法调用"></a>泛型方法调用</h3><blockquote>
<ul>
<li>泛型方法的泛型类型的指定与所在的泛型类的泛型类型没关系，可以不一样，但是泛型类的成员方法如果返回值是泛型，那就必须一样了</li>
<li>成员方法不可以声明为static，而泛型方法可以</li>
</ul>
</blockquote>
<p><strong>泛型方法声明类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductGetter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> T product; <span class="comment">//奖品</span></span><br><span class="line">    ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//奖品池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这这是一个成员方法，只是返回值采用了泛型</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        product = list.get(random.nextInt(list.size()));</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义的是一个泛型方法</span></span><br><span class="line"><span class="comment">     * 泛型方法的泛型可以独立于所在泛型类的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt; 泛型标识，具体类型由调用方法的时候来指定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; E <span class="title function_">getProduct</span><span class="params">(ArrayList&lt;E&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>泛型方法调用类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ProductGetter&lt;Integer&gt; getter = <span class="keyword">new</span> <span class="title class_">ProductGetter</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] products = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">400</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; products.length; i++) &#123;</span><br><span class="line">            getter.addProduct(products[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用成员方法</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pro</span> <span class="operator">=</span> getter.getProduct();</span><br><span class="line">        System.out.println(pro + <span class="string">&quot;\t&quot;</span> + pro.getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两次调用泛型方法，泛型指定的类型可以不一样</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;笔记本电脑&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;手机&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;马尔代夫一日游&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">product</span> <span class="operator">=</span> getter.getProduct(list);</span><br><span class="line">        System.out.println(product + <span class="string">&quot;\t&quot;</span> + product.getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1000</span>);</span><br><span class="line">        list1.add(<span class="number">500</span>);</span><br><span class="line">        list1.add(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">money</span> <span class="operator">=</span> getter.getProduct(list1);</span><br><span class="line">        System.out.println(money + <span class="string">&quot;\t&quot;</span> + money.getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="静态泛型方法"><a href="#静态泛型方法" class="headerlink" title="静态泛型方法"></a>静态泛型方法</h3><blockquote>
<p>泛型方法可以被声明成static，成员方法不可以</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, E, K&gt; <span class="keyword">void</span> <span class="title function_">printType</span><span class="params">(T t, E e, K k)</span> &#123;</span><br><span class="line">        System.out.println(t + <span class="string">&quot;\t&quot;</span> + t.getClass().getSimpleName());</span><br><span class="line">        System.out.println(e + <span class="string">&quot;\t&quot;</span> + e.getClass().getSimpleName());</span><br><span class="line">        System.out.println(k + <span class="string">&quot;\t&quot;</span> + k.getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="可变参数泛型方法"><a href="#可变参数泛型方法" class="headerlink" title="可变参数泛型方法"></a>可变参数泛型方法</h3><blockquote>
<p>在参数的泛型类型后添加三个点即可声明为可变参数</p>
</blockquote>
<p><strong>多参数方法定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型可变参数的定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">prints</span><span class="params">(E... e)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; e.length; i++) &#123;</span><br><span class="line">            System.out.println(e[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getter.prints(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>,<span class="literal">true</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">//打印参数列表内容</span></span><br></pre></td></tr></table></figure>











<h2 id="4-5-类型通配符"><a href="#4-5-类型通配符" class="headerlink" title="4.5 类型通配符"></a>4.5 类型通配符</h2><blockquote>
<p>由下图的样例可以看出，在泛型中如果制定了泛型类的类型，哪怕是其指定类型的子 类型也不可以，同理重载也是不可以的，所以解决方案就是使用泛型的通配符</p>
</blockquote>
<img src="/Users/lei/Desktop/Typora笔记/图片/截屏2022-06-07 14.14.00.png" alt="截屏2022-06-07 14.14.00" style="zoom:50%;" />

<hr>
<blockquote>
<p>使用通配符？后即可解决这个问题</p>
</blockquote>
<img src="/Users/lei/Desktop/Typora笔记/图片/截屏2022-06-07 14.17.53.png" alt="截屏2022-06-07 14.17.53" style="zoom:50%;" />





<h3 id="4-5-1-类型通配符介绍"><a href="#4-5-1-类型通配符介绍" class="headerlink" title="4.5.1 类型通配符介绍"></a>4.5.1 类型通配符介绍</h3><blockquote>
<ul>
<li>类型通配符一般是使用 ’ ？‘ 代替具体的类型实参</li>
<li>所以，类型通配符是类型实参，而不是类型形参</li>
</ul>
</blockquote>
<h3 id="4-5-2-类型通配符上限"><a href="#4-5-2-类型通配符上限" class="headerlink" title="4.5.2 类型通配符上限"></a>4.5.2 类型通配符上限</h3><blockquote>
<p>当指定了泛型的上限后意味着只能传递这个上限以及上限的子类</p>
<p>通过extends来指定上限,但不可以添加元素</p>
</blockquote>
<img src="/Users/lei/Desktop/Typora笔记/图片/截屏2022-06-07 14.24.03.png" alt="截屏2022-06-07 14.24.03" style="zoom:50%;" />



<h3 id="4-5-3-类型通配符下限"><a href="#4-5-3-类型通配符下限" class="headerlink" title="4.5.3 类型通配符下限"></a>4.5.3 类型通配符下限</h3><blockquote>
<p>使用super来指定下限，可以添加元素但不保证 约束，且在遍历是以Object接受</p>
<p>要求该反省的类型只能是实参类型或实参类型的父类型</p>
</blockquote>
<img src="/Users/lei/Desktop/Typora笔记/图片/截屏2022-06-07 14.32.55.png" alt="截屏2022-06-07 14.32.55" style="zoom:50%;" />













<h2 id="4-6-类型擦除"><a href="#4-6-类型擦除" class="headerlink" title="4.6 类型擦除"></a>4.6 类型擦除</h2><blockquote>
<p>泛型是java 1.5 才引进的概念，在此之前是没有泛型的，但是，泛型代码能很好的和之前的代码兼容是因为泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除，称之为类型擦除</p>
</blockquote>
<h2 id="4-7-泛型与数组"><a href="#4-7-泛型与数组" class="headerlink" title="4.7 泛型与数组"></a>4.7 泛型与数组</h2><h2 id="4-8-泛型与反射"><a href="#4-8-泛型与反射" class="headerlink" title="4.8 泛型与反射"></a>4.8 泛型与反射</h2><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><hr>
<h2 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h2><h3 id="注解概述"><a href="#注解概述" class="headerlink" title="注解概述"></a>注解概述</h3><blockquote>
<ul>
<li>注解（Annotation）是从JDK5.0开始引入的技术</li>
<li>Annotation 的作用：<ul>
<li>不是程序本身，可以对程序作出解释（这点和注释（comment）一样）</li>
<li><strong>可以被其他程序（比如：编译器）读取</strong></li>
</ul>
</li>
<li>Annotation 可以在哪里使用<ul>
<li>可以附加在package、class、method、field上面，相当于给他们添加了额外的辅助信息<br>可以通过反射机制编程实现对这些元数据的访问</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><blockquote>
<ul>
<li>@Override<br>定义在lang包下，此注释只适用于修辞方式，表示一个方法声明打算重写超类中的另一个方法声明</li>
<li>@Deprecated<br>定义在lang包下，此注释可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它有危险或者有更好的选择</li>
<li>@SuppressWarnings<br>定义在lang包下，用来抑制编译时的警告信息，它需要添加参数才可以使用<br>@SuppressWarnings（”all”）<br>@SuppressWarnings（”unchecked”）<br>@SuppressWarnings（value &#x3D; {“unchecked”, deprecation}）<br>……</li>
</ul>
</blockquote>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><blockquote>
<p>元注解的作用就是负责注解其他注解<br>Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明</p>
<ul>
<li>@Target<br>用于描述注解的使用范围（即被描述的注解可以用在什么地方）</li>
<li>@Retention<br>表示需要在什么级别保存该注解信息，用于描述注解的生命周期<br>source &lt; class &lt; runtime</li>
<li>@Documented<br>说明该注解将被包含在javadoc中</li>
<li>@Inherited<br>说明子类可以继承父类中的该注解</li>
</ul>
</blockquote>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><blockquote>
<p>自定义注解：@interface</p>
<ul>
<li>使用自定义注解时自动继承了java.lang.annatation.Annatation接口</li>
<li>格式：<br>@interface 注解名 {定义内容}</li>
<li><strong>其中的每一个方法实际上是声明了一个配置参数</strong></li>
<li>方法的名称就是参数名</li>
<li>返回类型就是参数的类型（返回值只能是基本类型，Class、String、enum）</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般命名为value</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li>
</ul>
</blockquote>
<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@myAnnatation(name = &quot;Erics&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> myAnnatation &#123;</span><br><span class="line">    <span class="comment">//如果没有default且又声明了一个元素，那么在使用时就必须加参数</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><hr>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="静态、动态语言"><a href="#静态、动态语言" class="headerlink" title="静态、动态语言"></a>静态、动态语言</h3><blockquote>
<p><strong>动态语言</strong></p>
<ul>
<li>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或者其他结构上的变化，即在运行时代码可以根据某些条件改变自身结构</li>
<li>例如：Object-C、C#、JavaScript、PHP、Python等</li>
</ul>
<p><strong>静态语言</strong></p>
<ul>
<li>运行时结构不可以被改变，如Java、C、C++</li>
<li>Java不是动态语言但被称为准动态语言，即Java具有一定的动态性，我们可以利用反射机制获得类似动态语言的特性</li>
</ul>
</blockquote>
<h3 id="反射（Reflectio-n）"><a href="#反射（Reflectio-n）" class="headerlink" title="反射（Reflectio n）"></a>反射（Reflectio n）</h3><blockquote>
<ul>
<li>Reflection是Java被视为动态语言的关键，反射机制允许程序在执行期间借助Reflection API 获得任何类的内部信息，并能直接操作任对象的内部属性及方法</li>
<li>加载完类之后，在堆内存的方法区就产生了一个Class类型的对象（<strong>一个类只有一个Class对象</strong>），这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称之为反射。</li>
<li>正常方式：<br>引入需要的包类名称 –&gt; 通过new实例化 –&gt; 获取实例化对象</li>
<li>反射方式：<br>实例化对象 –&gt; getClass（）方法 –&gt; 得到完整的包类名称</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Java反射机制提供的功能</strong></p>
<ul>
<li>在运行时判断任何一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类具有的成员方法和变量</li>
<li>在运行时获取范型信息</li>
<li>在运行时调用任意一个对象的成员方法和变量</li>
<li><strong>在运行时处理注解</strong></li>
<li>生成动态代理</li>
<li>……</li>
</ul>
</blockquote>
<blockquote>
<p><strong>优点</strong><br>可以实现动态创建对象和编译，体现出很大的灵活性</p>
</blockquote>
<blockquote>
<p><strong>缺点</strong><br>对性能有很大影响<br>使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求，这类操作总是慢于直接执行相同操作</p>
</blockquote>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote>
<p>类加载器的内容以后还要继续补充，下图是关于类加载器的作用的简单示意图</p>
<p>Java 反射机制就是帮助我们拿到堆中的 class 的信息</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-10%2000.09.49.png" style="zoom:50%">





<blockquote>
<p>那么 class 信息是什么时候被 classLoadder 方法 堆中的呢？<br>当我们需要使用的时候才会放, 一般是 new 对象的时候先判断 class 文件存不存在，不存在就会加载到内存，然后来创建对象</p>
</blockquote>
<p><strong>验证如下：</strong></p>
<p>一：new 一个类，然后在这一句打上断点，这个类最好不要实现接口，不然可能会不利于观察结果</p>
<p>二：找到 Java 源码的 ClassLoader 这个类，可以随便 new 一个对象然后通过以下方法进入到 ClassLoader 的 loadClass 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceImpl2.getClass().getClassLoader().loadClass();</span><br></pre></td></tr></table></figure>

<p>三：先只在 new 对象的那一行打断点，不要再 loadClass 方法打，因为程序很有可能在运行的时候先加载了其他类的 class，从而影响我们观察结果。当打好断点后，等debug 代码到断点，再在 classLoad 方法的那里打上断点，并直接执行到该断点，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-10%2018.10.21.png" style="50%">

<p>四：总结：当我们在 new 对象的时候，会将该类的 class 文件加载到堆中</p>
<blockquote>
<p>还有其他知识点：</p>
<ul>
<li>以下代码的打印结果为true，因为 class 文件在内存中只有一份</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(serviceImpl2.getClass() == ServiceImpl2.class);</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="获取-class-的方式"><a href="#获取-class-的方式" class="headerlink" title="获取 class 的方式"></a>获取 class 的方式</h3><blockquote>
<ul>
<li>类名.class</li>
<li>new 出一个对象，根据对象获取 class</li>
<li>Class.forName（类的完整路径地址）</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 类名.class</span></span><br><span class="line">        Class&lt;ServiceImpl2&gt; serviceImpl2Class = ServiceImpl2.class;</span><br><span class="line">        <span class="comment">// 2. new 出一个对象，根据对象获取 class</span></span><br><span class="line">        <span class="type">ServiceImpl2</span> <span class="variable">serviceImpl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl2</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ServiceImpl2</span>&gt; aClass = serviceImpl2.getClass();</span><br><span class="line">        <span class="comment">// 3. Class.forName（类的完整路径地址）</span></span><br><span class="line">        Class&lt;?&gt; aClass1 = Class.forName(<span class="string">&quot;com.sjms.dailimoshi.demo1.ServiceImpl2&quot;</span>);</span><br></pre></td></tr></table></figure>









<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote>
<ul>
<li>JDBC 中 Class.forName(“com.mysql.jdbc.Driver”) 反射技术加载 mysql 驱动</li>
<li>Spring 基于反射技术初始化对象</li>
<li>第三方框架扩展功能</li>
</ul>
</blockquote>
<h2 id="反射技术核心-API"><a href="#反射技术核心-API" class="headerlink" title="反射技术核心 API"></a>反射技术核心 API</h2><blockquote>
<p><strong>newInstance</strong></p>
<p> 默认使用无参构造器创建对象</p>
</blockquote>
<p>一：创建一个对象,为了验证 newInstance 方法调用的是无参构造方法，加一条打印语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectionObject</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;new instance 默认调用无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二：通过 class 来创建对象<br>可以清楚看到 newInstance 方法通过 class 拿到了类的成员方法和变量，并通过无参构造方法创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObject</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.myReflection.ReflectionObject&quot;</span>);</span><br><span class="line">        <span class="comment">// 默认走无参构造器</span></span><br><span class="line">        <span class="type">ReflectionObject</span> <span class="variable">reflectionObject</span> <span class="operator">=</span> (ReflectionObject) aClass.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>getConstructor</strong></p>
<p>通过 class 获取类的构造器，其参数是有参构造方法的参数的 class 信息</p>
</blockquote>
<p>一：给对象增加有参构造器以及 toString 方法来观察结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectionObject</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;new instance 默认调用无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectionObject</span><span class="params">(String name, Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        System.out.println(<span class="string">&quot;construction 的 newInstance 走有参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ReflectionObject&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二：通过 class 拿到 constructor 再调用他的 newInstance 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.myReflection.ReflectionObject&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = aClass.getConstructor(String.class, Integer.class);</span><br><span class="line"><span class="type">ReflectionObject</span> <span class="variable">instance</span> <span class="operator">=</span>(ReflectionObject) constructor.newInstance(<span class="string">&quot;erics&quot;</span>, <span class="number">10001</span>);</span><br><span class="line">System.out.println(instance);</span><br></pre></td></tr></table></figure>



<blockquote>
<ul>
<li><strong>getConstructors</strong><br>获取类中所有的 public 修饰的构造方法</li>
<li><strong>getDeclaredAnnotations</strong><br>获取类中所有的私有的、受保护的构造方法</li>
</ul>
</blockquote>
<blockquote>
<p><strong>获取成员属性</strong></p>
<ul>
<li>getFields()<br>获取所有公有字段</li>
<li>getDeclaredFields<br>获取所有字段</li>
</ul>
</blockquote>
<blockquote>
<p><strong>给成员属性赋值</strong><br>注意：反射是可以直接访问到私有的成员属性的, 但是需要在调用 set 方法前设置访问权限</p>
<ol>
<li>先调用 newInstance 调用无参构造方法创建对象</li>
<li>通过 getDeclaredField( fieldName) 获取指定的成员属性名称</li>
<li>再开启私有属性的访问权限</li>
<li>调用 Field 的 set 方法即可完成赋值</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getProperties</span><span class="params">()</span> </span><br><span class="line">	<span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">// 拿到 class 信息</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.myReflection.ReflectionObject&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用无参构造方法创建对象</span></span><br><span class="line">        <span class="type">ReflectionObject</span> <span class="variable">reflectionObject</span> <span class="operator">=</span>(ReflectionObject) aClass.newInstance();</span><br><span class="line">        <span class="comment">// 通过属性名拿到其对应的 Field </span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">idField</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// 打开访问权限</span></span><br><span class="line">        idField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        idField.set(reflectionObject, <span class="number">10001</span>);</span><br><span class="line">        System.out.println(reflectionObject);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p><strong>获取成员方法</strong></p>
<ul>
<li>getMethods()<br>获取所有的公有方法，<strong>包含 Object 父类中的公有方法</strong></li>
<li>aClass.getDeclaredMethods()<br>获取该类所有方法，包括私有的，不包括继承的</li>
</ul>
</blockquote>
<blockquote>
<p><strong>调用成员方法</strong></p>
<ol>
<li>根据方法名和参数类型列表获取方法</li>
<li>创建对象（方法的执行是依赖于对象的）</li>
<li>如果是私有的方法需要打开权限</li>
<li>调用 invoke</li>
</ol>
</blockquote>
<p><strong>调用 public 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.myReflection.ReflectionObject&quot;</span>);</span><br><span class="line"><span class="type">ReflectionObject</span> <span class="variable">reflectionObject</span> <span class="operator">=</span>(ReflectionObject) aClass.newInstance();</span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">showNameId</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;showNameId&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="comment">// invoke 调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span>(String) showNameId.invoke(reflectionObject, <span class="string">&quot;erics&quot;</span>, <span class="number">10001</span>);       System.out.println(result);</span><br></pre></td></tr></table></figure>

<p><strong>调用 private 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.myReflection.ReflectionObject&quot;</span>);</span><br><span class="line"><span class="type">ReflectionObject</span> <span class="variable">reflectionObject</span> <span class="operator">=</span>(ReflectionObject) aClass.newInstance();</span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">showNameId</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;showNameId&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="comment">// 开启权限</span></span><br><span class="line">showNameId.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// invoke 调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span>(String) showNameId.invoke(reflectionObject, <span class="string">&quot;erics&quot;</span>, <span class="number">10001</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>







<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><blockquote>
<p>JDBC 是 java 官方提供的一套规范接口，用于操作不同的关系型数据库</p>
</blockquote>
<p>p2</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h1 id="Socket-网络编程"><a href="#Socket-网络编程" class="headerlink" title="Socket 网络编程"></a>Socket 网络编程</h1><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><blockquote>
<ul>
<li>http 协议是基于请求(request)与相应(response)模型的</li>
<li>http 底层是基于 tcp 协议封装的，面向连接方式</li>
<li>http 协议是无状态协议，即对事物的处理是没有任何记忆功能的</li>
<li>http 请求多次是无法共享的<br>javaweb 中我们可以通过 cookie、session 解决该问题</li>
<li>http 协议数据传输过程中是属于同步的过程<br>即如果客户端发送请求到服务器端，服务器端一直没有响应，可能会导致客户端一直阻塞等待</li>
</ul>
</blockquote>
<h3 id="http协议请求格式"><a href="#http协议请求格式" class="headerlink" title="http协议请求格式"></a>http协议请求格式</h3><blockquote>
<p>大致可以分为如下三部分</p>
<ol>
<li>请求行</li>
<li>请求头</li>
<li>请求体</li>
</ol>
</blockquote>
<blockquote>
<p><strong>请求行</strong></p>
<p>即请求数据的第一行，包括如下内容：</p>
<ul>
<li>请求方法：get、post</li>
<li>url </li>
<li>http 协议版本</li>
</ul>
<p><strong>以百度为例，请求行为</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<p><strong>请求头</strong></p>
<p>以键值对的形式封装了一些请求的参数，主要的有：</p>
<ul>
<li><p>Host<br>接受请求的服务器地址，可以是 ip + 端口号也可以是域名</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>User-Agent<br>发送请求的应用程序名称（下面的 U-A 信息表示该请求来自于 Chrome 浏览器）</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36</span><br></pre></td></tr></table></figure>
</li>
<li><p>Connection</p>
</li>
<li><p>Accept-Charset</p>
</li>
<li><p>Accept-Encoding</p>
</li>
<li><p>Accept-Language</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>请求体</strong></p>
<p>post 请求的最后一部分，存放发送请求的参数（具体的可以看 get 和 post 请求的区别）</p>
</blockquote>
<h3 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h3><blockquote>
<ul>
<li>get 请求的请求参数在请求行中，没有请求体<br>post 请求的请求参数是在请求体中</li>
<li>get 请求的参数有大小限制<br>post 请求的参数没有大小限制</li>
</ul>
</blockquote>
<h3 id="http-响应格式"><a href="#http-响应格式" class="headerlink" title="http 响应格式"></a>http 响应格式</h3><blockquote>
<p>有以下三个部分：</p>
<ol>
<li>响应行</li>
<li>响应头</li>
</ol>
</blockquote>
<blockquote>
<p><strong>响应行</strong></p>
<p>响应行主要包含 http 协议版本、状态码  </p>
<p><strong>状态码</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_49904442/article/details/126858357">https://blog.csdn.net/weixin_49904442/article/details/126858357</a></p>
</blockquote>
<blockquote>
<p><strong>响应头</strong></p>
<ul>
<li><p>Date<br>响应时间</p>
</li>
<li><p>Content-Type<br>响应的类型，还包含了响应内容编码格式。常见的响应内容有 text、html、image</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text/javascript; charset=utf-8</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h2 id="什么是网络编程"><a href="#什么是网络编程" class="headerlink" title="什么是网络编程"></a>什么是网络编程</h2><blockquote>
<p>网络编程（Socket）就是编写计算机程序使得联网的两个或多个设备进行数据传输</p>
<p><strong>网络编程三要素</strong></p>
<ul>
<li>ip 地址<br>定位对方的主机</li>
<li>端口号<br>定位对方主机上的应用程序</li>
<li>协议（tcp&#x2F;udp）</li>
</ul>
</blockquote>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><blockquote>
<p>IP 地址，即 InternetAddress（在 java 中，InetAddress 即可代表 IP）</p>
<p><strong>相关知识</strong></p>
<ul>
<li>本地回环地址：127.0.0.1（主机名：localhost）</li>
<li>公网IP 和 局域网IP<br>如果两台计算机连接到同一个路由器，那么就组成了一个局域网，这两台计算机之间的通信消耗的资源很少<br>如果两台计算机没有连接到同一个路由器，那么就要走互联网的形式</li>
</ul>
</blockquote>
<h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><blockquote>
<p>封装了一些对本机 ip 地址进行操作的方法</p>
</blockquote>
<p><strong>获取本机 ip 地址，主机名等内容</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> inetAddress.getHostName(); <span class="comment">// 获取本地 ip 地址主机名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> inetAddress.getHostAddress(); <span class="comment">// 获取本机 ip 地址</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost(); <span class="comment">// 将主机 ip 名和 ip 地址包装成对象</span></span><br></pre></td></tr></table></figure>





<h3 id="dns-解析"><a href="#dns-解析" class="headerlink" title="dns 解析"></a>dns 解析</h3><blockquote>
<p>HostName 就是主机名称，也就是我们的域名,baidu.com, taobao.com 都是域名</p>
<p><strong>当我们输入一个网址后，会发生什么</strong></p>
<ol>
<li>先去找本机 hosts 文件，如果有匹配，返回结果</li>
<li>如果没有匹配，则去电信运营商那里获取公网 ip 地址</li>
</ol>
</blockquote>
<p><strong>mac 电脑的 hosts 文件</strong></p>
<ol>
<li>打开 finder，按下 command + shift + g，输入 &#x2F;private</li>
<li>进入 etc 目录找到 hosts 文件，内容大致如下</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-03%2009.58.50.png">



<p><strong>对 host 文件进行如下操作，将 127.0.0.1 的值改为 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></strong></p>
<p>造成的结果有：</p>
<ol>
<li>在浏览器输入 baidu 的域名后无法访问，因为本机 hosts 文件将其解析成了 127.0.0.1</li>
<li>运行 InetAddress 代码，会发现getHostByName 也是 127.0.0.1，如下</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-03%2010.18.12.png">









<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote>
<p>核心特点：面向无连接、不可靠的协议、安全系数低，容易丢包，但是传输速度很快，不需要类似 TCP 协议的三次握手</p>
<p>当客户端采用 UDP 协议向服务器端发送数据时，不会确认服务器端的监听端口是否正常运行，直接发送，如果服务器端的监听端口不在正常工作，那么数据就会丢失</p>
</blockquote>
<h3 id="代码模拟udp发送信息"><a href="#代码模拟udp发送信息" class="headerlink" title="代码模拟udp发送信息"></a>代码模拟udp发送信息</h3><blockquote>
<p><strong>用 Java 代码模拟客户端采用 UDP 协议向服务器端发送数据</strong></p>
<p><strong>客户端代码步骤</strong></p>
<ol>
<li>创建 socket 端对象</li>
<li>提供数据，并将数据封装到数据包中</li>
<li>通过 socket 服务发送功能，将数据包发送出去</li>
<li>释放资源</li>
</ol>
</blockquote>
<p><strong>客户端代码</strong></p>
<p>该代码无论有没有服务端监听都不会失败，因为是面向无连接的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPCLient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建 socket 发送对象，待会会调用他的 send 方法发送一个 daatagramPackage</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 创建参数：发送的信息（byte 数组）、信息长度、服务器端地址、服务器端口号，并封装到 DatagramPacket 中</span></span><br><span class="line">        <span class="type">byte</span>[] msg = <span class="string">&quot;hello udp&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ipAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(msg, msg.length, ipAddress, port);</span><br><span class="line">        <span class="comment">// 发送</span></span><br><span class="line">        datagramSocket.send(packet);</span><br><span class="line">        System.out.println(<span class="string">&quot;send msg sucessed&quot;</span>);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>服务端代码步骤</strong></p>
<ol>
<li>创建接收端 socket 对象</li>
<li>接收数据</li>
<li>解析数据</li>
<li>输出数据</li>
<li>释放资源</li>
</ol>
</blockquote>
<p><strong>服务端代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建接收端 socket 对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);</span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">        <span class="comment">// 开始监听端口，等待客户端发送数据，如果客户端一直没发送数据就阻塞下去</span></span><br><span class="line">        System.out.println(<span class="string">&quot;listening to 8080&quot;</span>);</span><br><span class="line">        datagramSocket.receive(datagramPacket);</span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        System.out.println(<span class="string">&quot;received msg successed&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] data = datagramPacket.getData();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">// 释放</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="UDP-应用"><a href="#UDP-应用" class="headerlink" title="UDP 应用"></a>UDP 应用</h3><blockquote>
<p>现编写一个客户端和服务端 demo 如下：<br>客户端可以一直给服务端发送信息，而服务端也会一直接收信息</p>
</blockquote>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入信息：&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;quit&quot;</span>.equals(context)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;退出程序.....&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span>[] bytes = context.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8080</span>);</span><br><span class="line">            ds.send(dp);</span><br><span class="line">            System.out.println(<span class="string">&quot;信息发送成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">            ds.receive(dp);</span><br><span class="line">            System.out.println(<span class="string">&quot;信息接收成功：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData()));</span><br><span class="line">        &#125;</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><blockquote>
<p>使用 TCP 协议传输数据，需要在经历三次握手以后才将数据发送给服务端</p>
<p><strong>三次握手每一次的作用</strong></p>
<ol>
<li>第一次：客户端向服务端发送请求确认服务端是否可以接收数据</li>
<li>第二次：服务端向客户端回复可以</li>
<li>第三次：客户端与服务端开始建立连接发送数据</li>
</ol>
</blockquote>
<h3 id="实现-TCP-发送接收数据"><a href="#实现-TCP-发送接收数据" class="headerlink" title="实现 TCP 发送接收数据"></a>实现 TCP 发送接收数据</h3><blockquote>
<p><strong>发送端</strong></p>
<ol>
<li>创建发送端 socket 对象</li>
<li>获取输出流对象</li>
<li>发送数据</li>
<li>释放资源</li>
</ol>
</blockquote>
<p><strong>发送端代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1 创建发送端 socket 对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8090</span>);</span><br><span class="line">        <span class="comment">// 2 获取输出流对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3 发送数据</span></span><br><span class="line">        os.write(<span class="string">&quot;hello tcp&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 4 释放资源</span></span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当接收端服务没起来时，会报以下错误,因为是面向连接的，所以会出现 connection refused 的错<br>该错会出现在各种场合，主要有：</p>
<ul>
<li>ip 地址访问不通（防火墙未关等）</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-06-04%2001.00.29.png">



<blockquote>
<p><strong>Server端</strong></p>
<ol>
<li>创建接收端 socket 对象</li>
<li>监听</li>
<li>获取输入流对象</li>
<li>获取数据</li>
<li>输出数据</li>
<li>释放资源</li>
</ol>
</blockquote>
<p><strong>接收端代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建接收端 socket 对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8090</span>);</span><br><span class="line">        <span class="comment">// 如果客户端一直没有给服务端发送数据，那么服务器端会一直阻塞</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">// 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的数据：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="TCP应用"><a href="#TCP应用" class="headerlink" title="TCP应用"></a>TCP应用</h3><blockquote>
<p>应用需求如下：</p>
<ol>
<li>可以不断发送和接收</li>
<li>服务端不但能接受信息还能返回信息</li>
<li>客户端能发送信息也能打印服务端的返回的信息</li>
</ol>
</blockquote>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;quit&quot;</span>.equals(context)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;退出程序...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            os.write(context.getBytes());</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端接收到的服务端的回信: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动成功...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的信息:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="string">&quot;服务端已收到: &quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">            outputStream.write(resp.getBytes());</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><blockquote>
<p>简单优化一下，但是一般来说不允许 new Thread，需要使用线程池维护</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动成功...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到的信息:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">                        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">                        <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="string">&quot;服务端已收到: &quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">                        outputStream.write(resp.getBytes());</span><br><span class="line">                        inputStream.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="手写-http-服务端"><a href="#手写-http-服务端" class="headerlink" title="手写 http 服务端"></a>手写 http 服务端</h2><blockquote>
<p>现手写一个 http 服务端，在主机某文件夹下存放若干 html 格式的静态资源，当在浏览器输入 localhost + 文件路径即可访问到该静态资源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpTcpServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建 ServerSockrt，http基于 tcp 封装的，默认端口号 80</span></span><br><span class="line">        <span class="comment">// 这行代码应该放在 while 循环外面，否则循环监听就会报错</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取客户端发送的数据，判断访问的是哪一个文件</span></span><br><span class="line">                        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                        <span class="type">byte</span>[] reqByte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">reqlen</span> <span class="operator">=</span> inputStream.read(reqByte);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">reqtext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(reqByte, <span class="number">0</span>, reqlen);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">reqAddress</span> <span class="operator">=</span> reqtext.split(<span class="string">&quot;\r\n&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">                        outputStream = socket.getOutputStream();</span><br><span class="line">                        <span class="comment">// 读取静态资源文件</span></span><br><span class="line">                        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/lei/Desktop/temporary/testing/&quot;</span> + reqAddress);</span><br><span class="line">                        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">                        <span class="type">byte</span>[] respBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fileInputStream.read(respBytes);</span><br><span class="line">                        <span class="comment">// 输出流写数据返回给客户端</span></span><br><span class="line">                        outputStream.write(respBytes, <span class="number">0</span>, len);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (outputStream != <span class="literal">null</span>) outputStream.close();</span><br><span class="line">                            <span class="keyword">if</span> (socket != <span class="literal">null</span>) socket.close();</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
























    </div>

    
    
    
        <div class="reward-container">
  <div>您的支持是我最大的动力！！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Erics Lei WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Erics Lei Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="prev" title="数据结构与算法">
      <i class="fa fa-chevron-left"></i> 数据结构与算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="next" title="开发框架和中间件">
      开发框架和中间件 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaSE"><span class="nav-text">JavaSE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashCode-%E5%92%8C-equals"><span class="nav-text">HashCode 和 equals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashCode"><span class="nav-text">HashCode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-text">哈希冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99-hashCode-%E5%92%8C-equals"><span class="nav-text">重写 hashCode 和 equals</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%E9%93%BE"><span class="nav-text">栈帧链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objec"><span class="nav-text">Objec</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-text">Object 主要方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">类和和对象的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-text">对象的内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-text">成员变量访问内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-text">成员方法访问内存图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%88%86"><span class="nav-text">类的成分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-text">权限和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#private"><span class="nav-text">private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super-%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-text">super 和继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#super-%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">super 访问父类的成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super-%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">super 访问父类的构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super-%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-text">super 访问父类成员方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-text">重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">重写的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Override-%E5%8F%8A%E9%87%8D%E5%86%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">@Override 及重写的注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#package-%E3%80%81import"><span class="nav-text">package 、import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fianl-%E5%92%8C-static"><span class="nav-text">fianl 和 static</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final"><span class="nav-text">final</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-%E6%96%B9%E6%B3%95"><span class="nav-text">main 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81"><span class="nav-text">面向对象特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">多态的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E8%BD%AC%E5%9E%8B"><span class="nav-text">多态的转型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-text">抽象类和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#abstarct-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">abstarct 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interface-%E6%8E%A5%E5%8F%A3"><span class="nav-text">interface 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%A1%88%E4%BE%8B"><span class="nav-text">抽象类和接口案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">类和接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">抽象类和接口的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">方法内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">匿名内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-text">ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">ArrayList 中的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="nav-text">ArrayList 中的泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E6%BA%90%E7%A0%81"><span class="nav-text">ArrayList 源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95-ArrayList"><span class="nav-text">手写一个简单 ArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-text">源码解读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E5%92%8C-vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">ArrayList 和 vector 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-%E6%BA%90%E7%A0%81"><span class="nav-text">get 源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-%E6%BA%90%E7%A0%81"><span class="nav-text">remove 源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E7%9A%84KV%E5%B0%81%E8%A3%85"><span class="nav-text">HashMap 的KV封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key-%E7%9A%84%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86"><span class="nav-text">Key 的哈希计算原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-text">HashMap 解决哈希冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put-%E6%96%B9%E6%B3%95"><span class="nav-text">put 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Executor"><span class="nav-text">使用 Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BA%A7%E7%94%9F%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">从任务中产生返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%91%E7%9C%A0"><span class="nav-text">休眠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A9%E6%AD%A5"><span class="nav-text">让步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-text">后台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-text">加入一个线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-text">线程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-text">捕获异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%8F%97%E9%99%90%E8%B5%84%E6%BA%90"><span class="nav-text">共享受限资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%9C%B0%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90"><span class="nav-text">不正确地访问资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89"><span class="nav-text">解决共享资源竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E6%98%93%E5%8F%98%E6%80%A7"><span class="nav-text">原子性与易变性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-text">原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-text">临界区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1"><span class="nav-text">终结任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E9%98%BB%E5%A1%9E%E6%97%B6%E7%BB%88%E7%BB%93"><span class="nav-text">在阻塞时终结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-text">中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="nav-text">线程创建与执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-text">继承Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Run%EF%BC%88%EF%BC%89%E5%92%8Cstart%EF%BC%88%EF%BC%89"><span class="nav-text">Run（）和start（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-text">实现Runnable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-text">实现Callable接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">*线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98demo"><span class="nav-text">线程安全问题demo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-text">线程安全问题解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E9%94%81"><span class="nav-text">synchronized 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">修饰代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-text">修饰实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">修饰静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-text">synchronized 死锁问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7"><span class="nav-text">死锁排查工具</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springmvc-%E4%BD%BF%E7%94%A8%E9%94%81"><span class="nav-text">springmvc 使用锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="nav-text">*线程通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%E3%80%81notify-%E4%BD%BF%E7%94%A8%E4%BA%8B%E9%A1%B9"><span class="nav-text">wait、notify 使用事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-text">实现生产者消费者模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E5%8A%A0%E9%94%81-demo"><span class="nav-text">未加锁 demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96"><span class="nav-text">第一次优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BC%98%E5%8C%96"><span class="nav-text">第二次优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-text">join 方法原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-%E5%92%8C-notify-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">wait 和 notify 底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">join 底层原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B7%E7%A7%8D%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="nav-text">*多线程7种执行状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-%E9%98%B2%E6%AD%A2cpu-100"><span class="nav-text">sleep 防止cpu 100%</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-text">用户线程与守护线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-text">*安全的停止一个线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stop"><span class="nav-text">stop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupt"><span class="nav-text">interrupt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E8%AE%BE%E7%BD%AE%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-text">自己设置标志位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock-%E9%94%81"><span class="nav-text">*Lock 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock-%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8"><span class="nav-text">Lock 锁的正确使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#condition-%E6%96%B9%E6%B3%95"><span class="nav-text">condition 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield-%E6%96%B9%E6%B3%95"><span class="nav-text">*yield 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">*多线程的优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-x2F-join-%E5%92%8C-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">wait&#x2F;join 和 sleep 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-%E5%92%8C-notify-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%9C%A8%E7%88%B6%E7%B1%BB%E4%B8%AD"><span class="nav-text">wait 和 notify 为什么放在父类中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">*字节码角度分析线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable-%E4%B8%8E-FutureTask-%E5%88%86%E6%9E%90"><span class="nav-text">*Callable 与 FutureTask 分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E6%89%8B%E5%86%99-Callable-%E5%92%8C-Futuretask"><span class="nav-text">自己手写 Callable 和 Futuretask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">其他实现方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B0%E7%A5%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">买票案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91"><span class="nav-text">龟兔赛跑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5"><span class="nav-text">同步概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E3%80%81%E9%94%81"><span class="nav-text">队列、锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E4%B8%8D%E5%AE%89%E5%85%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">三大不安全案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="nav-text">同步实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%91%A8%E8%BE%B9%E7%9F%A5%E8%AF%86"><span class="nav-text">线程周边知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-text">静态代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E4%BD%93"><span class="nav-text">线程的五种状体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="nav-text">线程方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2"><span class="nav-text">线程停止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="nav-text">线程休眠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9"><span class="nav-text">线程礼让</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C"><span class="nav-text">线程强制执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B"><span class="nav-text">线程状态观测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%EF%BC%88daemon%EF%BC%89%E7%BA%BF%E7%A8%8B"><span class="nav-text">守护（daemon）线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B"><span class="nav-text">死锁案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">死锁必要条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock%EF%BC%88%E9%94%81%EF%BC%89"><span class="nav-text">Lock（锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E3%80%81lock"><span class="nav-text">synchronized、lock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C"><span class="nav-text">线程协作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95"><span class="nav-text">线程通信方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="nav-text">解决方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8"><span class="nav-text">线程池使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81"><span class="nav-text">流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#File-%E7%B1%BB"><span class="nav-text">File 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#File-%E7%B1%BB%E4%B8%89%E7%A7%8D%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">File 类三种构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E6%88%96%E8%B7%AF%E5%BE%84"><span class="nav-text">创建文件或路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-%E7%B1%BB%E5%B8%B8%E8%A7%81%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="nav-text">File 类常见判断方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-%E7%B1%BB%E5%B8%B8%E8%A7%81%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-text">File 类常见获取方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-text">绝对路径与相对路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-%E7%B1%BB%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-text">File 类删除操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="nav-text">删除方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-%E7%B1%BB-for-%E5%BE%AA%E7%8E%AF%E5%88%A0%E9%99%A4"><span class="nav-text">File 类 for 循环删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-%E7%B1%BB%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4"><span class="nav-text">File 类递归删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-text">IO 流概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">IO 流的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-text">字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E5%85%A5%E5%8F%8A%E5%85%B3%E9%97%AD"><span class="nav-text">字节流写入及关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">字节流写入数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%8D%A2%E8%A1%8C%E5%92%8C%E8%BF%BD%E5%8A%A0%E5%86%99"><span class="nav-text">写入数据换行和追加写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E8%B5%84%E6%BA%90"><span class="nav-text">正确关闭资源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%8F%96"><span class="nav-text">字节流读取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-text">字节流读取文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="nav-text">字节流复制数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="nav-text">读取字节数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="nav-text">循环读取大文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%BA%94%E7%94%A8"><span class="nav-text">字节流应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87"><span class="nav-text">字节流复制图片</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-text">字节缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%E8%AF%BB%E5%86%99"><span class="nav-text">字节缓冲流读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%E5%A4%8D%E5%88%B6%E8%A7%86%E9%A2%91%E5%AF%B9%E6%AF%94"><span class="nav-text">字节缓冲流复制视频对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-text">编码相关知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%89%E5%AD%97%E7%9A%84%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4"><span class="nav-text">汉字的占用空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="nav-text">编码和解码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-text">3.2 字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="nav-text">3.2.1 IO流原理及分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-InputStream"><span class="nav-text">3.2.2 InputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-OutputStream"><span class="nav-text">3.2.3 OutputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="nav-text">3.3.1 文件拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-text">字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%86%99"><span class="nav-text">字符流读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-text">字符流基础使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E5%85%A5%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">字符流写入的5种方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E8%8A%82%E7%82%B9%E6%B5%81%E3%80%81%E5%A4%84%E7%90%86%E6%B5%81"><span class="nav-text">3.4 节点流、处理流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E8%8A%82%E7%82%B9%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%85%B3%E7%B3%BB"><span class="nav-text">3.4.1 节点、字节流关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">泛型概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">泛型的好处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-text">泛型类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-text">泛型类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-text">泛型类的继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-text">泛型接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-text">泛型接口定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">泛型接口的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%8C%BA%E5%88%AB"><span class="nav-text">泛型接口和泛型类区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text">泛型方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E"><span class="nav-text">泛型方法声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-text">泛型方法调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text">静态泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text">可变参数泛型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">4.5 类型通配符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BB%8B%E7%BB%8D"><span class="nav-text">4.5.1 类型通配符介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8A%E9%99%90"><span class="nav-text">4.5.2 类型通配符上限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8B%E9%99%90"><span class="nav-text">4.5.3 类型通配符下限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-text">4.6 类型擦除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-text">4.7 泛型与数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="nav-text">4.8 泛型与反射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3-1"><span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="nav-text">注解概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="nav-text">内置注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-text">自定义注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80"><span class="nav-text">静态、动态语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%EF%BC%88Reflectio-n%EF%BC%89"><span class="nav-text">反射（Reflectio n）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-class-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">获取 class 的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF%E6%A0%B8%E5%BF%83-API"><span class="nav-text">反射技术核心 API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC"><span class="nav-text">JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Socket-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">Socket 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-%E5%8D%8F%E8%AE%AE"><span class="nav-text">HTTP 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F"><span class="nav-text">http协议请求格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">get 和 post 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F"><span class="nav-text">http 响应格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">什么是网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-%E5%9C%B0%E5%9D%80"><span class="nav-text">IP 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InetAddress"><span class="nav-text">InetAddress</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns-%E8%A7%A3%E6%9E%90"><span class="nav-text">dns 解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP"><span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9Fudp%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF"><span class="nav-text">代码模拟udp发送信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP-%E5%BA%94%E7%94%A8"><span class="nav-text">UDP 应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">TCP 三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-TCP-%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="nav-text">实现 TCP 发送接收数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%BA%94%E7%94%A8"><span class="nav-text">TCP应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="nav-text">多线程优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99-http-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-text">手写 http 服务端</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Erics Lei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Erics Lei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

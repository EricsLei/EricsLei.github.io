<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySql</title>
    <url>/2022/03/30/MySql/</url>
    <content><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><h2 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h2><h3 id="1-1-数据库概念"><a href="#1-1-数据库概念" class="headerlink" title="1.1 数据库概念"></a>1.1 数据库概念</h3><blockquote>
<p>数据库（DataBase）是长期存储在计算机内部有结构的，大量的，共享的数据集合</p>
</blockquote>
<ul>
<li>长期存储：持久存储</li>
<li>有结构：<ul>
<li>类型：存储的数据是有类型的</li>
<li>关系：存储数据于数据之间的关系</li>
</ul>
</li>
<li>大量：大多数数据库是文件系统的，也就是说存储在数据库中的数据实际上存储在磁盘的文件中</li>
<li>共享：多个应用程序通过数据库实现数据共享</li>
</ul>
<h3 id="1-2-关系型数据库与非关系型数据库"><a href="#1-2-关系型数据库与非关系型数据库" class="headerlink" title="1.2 关系型数据库与非关系型数据库"></a>1.2 关系型数据库与非关系型数据库</h3><ul>
<li>关系型数据库</li>
</ul>
<blockquote>
<p>采用了关系模型来组织数据的存储，以行和列的的形式存储数据并记录数据与数据之间的关系<br>将数据存储在表格中，可以通过建立表格与表格之间的关系来维护数据与数据之间的关系</p>
</blockquote>
<ul>
<li>非关系型数据库</li>
</ul>
<blockquote>
<p>采用键值对的模型来存储数据，只完成数据的记录，不会记录数据与数据之间的关系<br>基于其特定的的存储结构来解决一些大数据应用难题</p>
<p>NoSQL(Not Only SQL)</p>
</blockquote>
<h3 id="1-3-常见的数据库产品"><a href="#1-3-常见的数据库产品" class="headerlink" title="1.3 常见的数据库产品"></a>1.3 常见的数据库产品</h3><p><strong>关系型数据库</strong></p>
<ul>
<li>mysql 免费<ul>
<li>MariaDB</li>
<li>Persona Server</li>
</ul>
</li>
<li>PostgreSQL</li>
<li>Oracle 收费</li>
<li>SQL Server</li>
<li>Access</li>
<li>Sybase</li>
<li>达梦数据库</li>
</ul>
<p><strong>非关系型数据库</strong></p>
<ul>
<li>面向检索的列式存储<ul>
<li>HaBase(Hadoop子系统)</li>
<li>BigTable（Google)</li>
</ul>
</li>
<li>面向高并发的缓存存储 key-value<ul>
<li>Redis</li>
<li>MemcacheDB</li>
</ul>
</li>
<li>面向海量数据访问文档存储 document-oriented<ul>
<li>MongoDB</li>
<li>CouchDB</li>
</ul>
</li>
</ul>
<h2 id="二、SQL"><a href="#二、SQL" class="headerlink" title="二、SQL"></a>二、SQL</h2><hr>
<h3 id="2-1-SQL概述"><a href="#2-1-SQL概述" class="headerlink" title="2.1 SQL概述"></a>2.1 SQL概述</h3><blockquote>
<p>SQL (Structured Query Language) 结构化查询语言，用于存储、查询、更新数据及管理关系型数据库系统</p>
</blockquote>
<h4 id="2-1-1-SQL分类"><a href="#2-1-1-SQL分类" class="headerlink" title="2.1.1 SQL分类"></a>2.1.1 SQL分类</h4><blockquote>
<p>根据SQL指令完成的数据库操作不同，可以将SQL指令分为四类</p>
</blockquote>
<ul>
<li><strong>DDL (Data Define Language)</strong> 数据库定义语言<ul>
<li>用于完成对数据库对象（数据库，数据表，视图，索引等）的管理</li>
</ul>
</li>
<li><strong>DML (Data Manipulation Language)</strong> 数据库操作语言<ul>
<li>用于完成对数据表中的数据进行添加，删除，修改等操作</li>
</ul>
</li>
<li><strong>DQL (Data Query Language)</strong> 数据库查询语言<ul>
<li>用于将数据表中的数据查询出来</li>
</ul>
</li>
<li><strong>DCL (Data Control Language)</strong> 数据库控制语言<ul>
<li>用于完成事务管理等操作</li>
</ul>
</li>
</ul>
<h3 id="2-2-SQL基本语法"><a href="#2-2-SQL基本语法" class="headerlink" title="2.2 SQL基本语法"></a>2.2 SQL基本语法</h3><ul>
<li>sql指令不区分大小写</li>
<li>每条sql指令结束后都以；结尾</li>
<li>sql关键词之间以空格进行分割</li>
<li>sql之间可以不限制换行</li>
</ul>
<h3 id="2-3-DDL"><a href="#2-3-DDL" class="headerlink" title="2.3 DDL"></a>2.3 DDL</h3><h4 id="2-3-1-数据库操作"><a href="#2-3-1-数据库操作" class="headerlink" title="2.3.1 数据库操作"></a>2.3.1 数据库操作</h4><blockquote>
<p>使用DDL语句创建数据库，修改数据库，查询数据库，删除数据库</p>
</blockquote>
<p><strong>查询数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">##显示当前数据库列表</span><br><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>

<p><strong>创建数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span> if <span class="keyword">not</span> <span class="keyword">exists</span>;</span><br><span class="line">##指定字符集</span><br><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure>

<p><strong>修改数据库</strong></p>
<ul>
<li>修改数据库字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span> <span class="type">character</span> <span class="keyword">set</span> utf8; ## utf8 gbk</span><br></pre></td></tr></table></figure>



<p><strong>删除数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>切换数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="2-3-2-数据表操作"><a href="#2-3-2-数据表操作" class="headerlink" title="2.3.2 数据表操作"></a>2.3.2 数据表操作</h4><blockquote>
<p>数据表实际就是一个二维表格，一个表格由多列组成，表格中的每一列成为一个字段</p>
</blockquote>
<p><strong>创建数据表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> students(</span><br><span class="line">stu_num <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">stu_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">stu_age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">stu_tel <span class="type">char</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">stu_qq <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span></span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p><strong>查询数据表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>

<p><strong>查询表结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改数据表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">##改表名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> rename <span class="keyword">to</span> <span class="operator">&lt;</span>newTableName<span class="operator">&gt;</span>;</span><br><span class="line">##改字符集</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">##添加列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">add</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span>;</span><br><span class="line">##修改字段名和类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> change <span class="operator">&lt;</span>oldColumnName<span class="operator">&gt;</span> <span class="operator">&lt;</span>newColumnName<span class="operator">&gt;</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span>;</span><br><span class="line">##修改字段类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> modify <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span>;</span><br><span class="line">##删除字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-mysql数据类型"><a href="#2-4-mysql数据类型" class="headerlink" title="2.4 mysql数据类型"></a>2.4 mysql数据类型</h3><h4 id="2-4-1-数值类型"><a href="#2-4-1-数值类型" class="headerlink" title="2.4.1 数值类型"></a>2.4.1 数值类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>内存空间大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint</td>
<td>1 byte</td>
<td>特小型整数（年龄）</td>
</tr>
<tr>
<td>smallint</td>
<td>2 byte</td>
<td>小型整数</td>
</tr>
<tr>
<td>mediumint</td>
<td>3 byte</td>
<td>中型整数</td>
</tr>
<tr>
<td>int&#x2F;integer</td>
<td>4 byte</td>
<td>整数</td>
</tr>
<tr>
<td>bigint</td>
<td>8 byte</td>
<td>大型整数</td>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>单精度</td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>双精度</td>
</tr>
<tr>
<td>decimal</td>
<td>第一参数+2</td>
<td>decimal(10,2) 表示一共有10位数字，小数有两位</td>
</tr>
</tbody></table>
<h4 id="2-4-2-字符类型"><a href="#2-4-2-字符类型" class="headerlink" title="2.4.2 字符类型"></a>2.4.2 字符类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>字符长度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>0~255</td>
<td>定字符长度，最多可以存储255字符，当我们指定数据表字段为char(n)<br />此列中的数据最多为n个字符，如果添加的数据少于n，则补”\u0000”至n长度</td>
</tr>
<tr>
<td>varchar</td>
<td>0~65536</td>
<td>可变字符串长度</td>
</tr>
<tr>
<td>tinyblob</td>
<td>0~255</td>
<td>存储二进制字符串</td>
</tr>
<tr>
<td>blob</td>
<td>0~65536</td>
<td>存储二进制字符串</td>
</tr>
<tr>
<td>mediumblob</td>
<td>0~1677215</td>
<td>存储二进制字符串</td>
</tr>
<tr>
<td>longblob</td>
<td>0~4294967295</td>
<td>存储二进制字符串</td>
</tr>
<tr>
<td>tinytext</td>
<td>0~255</td>
<td>文本数据（字符串）</td>
</tr>
<tr>
<td>text</td>
<td>0~65535</td>
<td>文本数据（字符串）</td>
</tr>
<tr>
<td>mediumtext</td>
<td>0~1677215</td>
<td>文本数据（字符串）</td>
</tr>
<tr>
<td>longtext</td>
<td>0~4294967295</td>
<td>文本数据（字符串）</td>
</tr>
</tbody></table>
<h4 id="2-4-3-日起类型"><a href="#2-4-3-日起类型" class="headerlink" title="2.4.3 日起类型"></a>2.4.3 日起类型</h4><blockquote>
<p>在mysql中可以用字符串存储时间 ，但如果我们需要基于时间字段进行查询操作，（某个时间段）<br>就不太方便了</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>2021-09-13</td>
<td>只存年月日</td>
</tr>
<tr>
<td>time</td>
<td>11:12:13</td>
<td>只存分秒</td>
</tr>
<tr>
<td>year</td>
<td>2021</td>
<td>年份</td>
</tr>
<tr>
<td>datatime</td>
<td>2021-09-13 11:12:13</td>
<td>日期加时间</td>
</tr>
<tr>
<td>timestamp</td>
<td>20210913 111213</td>
<td>时间戳</td>
</tr>
</tbody></table>
<h3 id="2-5-字段约束"><a href="#2-5-字段约束" class="headerlink" title="2.5 字段约束"></a>2.5 字段约束</h3><h4 id="2-5-1-约束介绍"><a href="#2-5-1-约束介绍" class="headerlink" title="2.5.1 约束介绍"></a>2.5.1 约束介绍</h4><blockquote>
<p>在创建数据表的时候，指定的对数据表的列的数据限制性的要求</p>
</blockquote>
<p><strong>为什么添加约束</strong></p>
<ul>
<li>保证数据有效性</li>
<li>保证数据完整性</li>
<li>保证数据正确性</li>
</ul>
<p><strong>常见约束</strong></p>
<ul>
<li>非空  not null</li>
<li>唯一 unique</li>
<li>主键 primary</li>
<li>外键 foreign key </li>
<li>联合主键 primary key (key1, key2 ….)</li>
</ul>
<h3 id="2-6-DML"><a href="#2-6-DML" class="headerlink" title="2.6 DML"></a>2.6 DML</h3><blockquote>
<p>用于完成数据表中对数据的插入，删除，修改操作</p>
</blockquote>
<h4 id="2-6-1-插入数据"><a href="#2-6-1-插入数据" class="headerlink" title="2.6.1 插入数据"></a>2.6.1 插入数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> (columnName1,columnName2,....) <span class="keyword">values</span>(value1,value2,...)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>tabName<span class="operator">&gt;</span> <span class="keyword">values</span>(...) ##全添加，且顺序保持一致</span><br></pre></td></tr></table></figure>



<h4 id="2-6-2-删除数据"><a href="#2-6-2-删除数据" class="headerlink" title="2.6.2 删除数据"></a>2.6.2 删除数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>conditions<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span>; ##删除所有数据</span><br></pre></td></tr></table></figure>



<h4 id="2-6-3-修改数据"><a href="#2-6-3-修改数据" class="headerlink" title="2.6.3 修改数据"></a>2.6.3 修改数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> <span class="keyword">set</span> columnName <span class="operator">=</span> <span class="keyword">value</span> <span class="keyword">where</span> conditions</span><br></pre></td></tr></table></figure>







<h3 id="2-7-DQL"><a href="#2-7-DQL" class="headerlink" title="2.7 DQL"></a>2.7 DQL</h3><h4 id="2-7-1-查询基础"><a href="#2-7-1-查询基础" class="headerlink" title="2.7.1 查询基础"></a>2.7.1 查询基础</h4><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c1,c2,c3 <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> </span><br></pre></td></tr></table></figure>



<h4 id="2-7-2-where子句"><a href="#2-7-2-where子句" class="headerlink" title="2.7.2 where子句"></a>2.7.2 where子句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> <span class="keyword">where</span> conditions;</span><br><span class="line"><span class="keyword">update</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> set... <span class="keyword">where</span> conditions;</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> <span class="keyword">where</span> conditions;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#: <span class="operator">=</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> stu_num<span class="operator">=</span><span class="string">&#x27;001&#x27;</span>;</span><br><span class="line">#: <span class="operator">!=</span> 和 <span class="operator">&lt;&gt;</span>效果一样,都标示不等于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> stu_num<span class="operator">!=</span><span class="string">&#x27;001&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> stu_num<span class="operator">&lt;&gt;</span><span class="string">&#x27;001&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#多条件查询:<span class="keyword">and</span> <span class="keyword">or</span> </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students modify stu_gender <span class="type">char</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> students <span class="keyword">where</span> stu_age<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">and</span> stu_gender<span class="operator">=</span><span class="string">&#x27;male&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> students <span class="keyword">where</span> stu_age<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">or</span> stu_gender<span class="operator">=</span><span class="string">&#x27;male&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">between</span> <span class="keyword">and</span>(闭区间，<span class="keyword">not</span> ; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> students <span class="keyword">where</span> stu_age <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">22</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> students <span class="keyword">where</span> stu_age <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">22</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-7-3-模糊查询-like"><a href="#2-7-3-模糊查询-like" class="headerlink" title="2.7.3 模糊查询 like"></a>2.7.3 模糊查询 like</h4><p>%: 任意多个字符</p>
<p>_: 任意一个字符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> <span class="keyword">where</span> valueName <span class="keyword">like</span> <span class="string">&#x27;%o%&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> <span class="keyword">where</span> valueName <span class="keyword">like</span> <span class="string">&#x27;_o_&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-7-4-对查询结果进行处理"><a href="#2-7-4-对查询结果进行处理" class="headerlink" title="2.7.4 对查询结果进行处理"></a>2.7.4 对查询结果进行处理</h4><p><strong>计算列</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询学生年龄，姓名</span><br><span class="line"><span class="keyword">select</span> stu_name,<span class="number">2022</span><span class="operator">-</span>stu_age <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure>

<p><strong>字段别名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#为查询结果的列取语义性更强的别名</span><br><span class="line"><span class="keyword">select</span> stu_name <span class="keyword">as</span> 姓名 ,stu_age <span class="keyword">as</span> 年龄 <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure>

<p><strong>消除重复行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> stu_age <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure>







<h4 id="2-7-5-排序"><a href="#2-7-5-排序" class="headerlink" title="2.7.5 排序"></a>2.7.5 排序</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> <span class="keyword">where</span> conditions <span class="keyword">order</span> <span class="keyword">by</span> columnName <span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#多字段排序，若第一个排序的值相同再按第二个值排序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stus <span class="keyword">where</span> stu_age<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> stu_gender <span class="keyword">asc</span>, stu_age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>



<h4 id="2-7-6-聚合函数"><a href="#2-7-6-聚合函数" class="headerlink" title="2.7.6 聚合函数"></a>2.7.6 聚合函数</h4><ul>
<li><strong>count( )</strong> :统计满足条件的字段的值的个数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#统计学生个数</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(stu_num) <span class="keyword">from</span> stus;</span><br><span class="line">#统计男生个数</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(stu_num) <span class="keyword">from</span> stus <span class="keyword">where</span> stu_gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>max( )</strong> :找出满足条件的记录中指定列的最大值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(stu_age) <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>min( )</strong>: 同上，找出最小值</p>
</li>
<li><p><strong>sum( )</strong> ;查询满足条件的记录中，指定列的值的综合</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(stu_age) <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure>

<ul>
<li>avg( ) :求平均值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(stu_age) <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure>





<h4 id="2-7-7-日期函数和字符串函数"><a href="#2-7-7-日期函数和字符串函数" class="headerlink" title="2.7.7 日期函数和字符串函数"></a>2.7.7 日期函数和字符串函数</h4><ul>
<li>日期函数</li>
</ul>
<blockquote>
<p>当我们向日期类型的列添加数据时，卡哇伊通过字符串类型赋值：格式:aaaa-bb-cc dd:ee:ff</p>
<p>用now（） 和sysdate（） 获取当前时间</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stus(entrance_time) <span class="keyword">values</span>(<span class="string">&#x27;2022-01-02 11:22:33&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stus(entrance_time) <span class="keyword">values</span>(now())</span><br></pre></td></tr></table></figure>



<ul>
<li><p>字符串函数</p>
<ul>
<li>​	concat</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(stu_name,stu_age) <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure>

<ul>
<li>upper &#x2F; lower</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(stu_name) <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure>

<ul>
<li>substring</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#截取指定字符串的字串</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(stu_tel,<span class="number">7</span>,<span class="number">4</span>) <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-8-分组查询"><a href="#2-7-8-分组查询" class="headerlink" title="2.7.8 分组查询"></a>2.7.8 分组查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#先对查询的学生信息按性别进行分组，然后分别统计每组人数</span><br><span class="line"><span class="keyword">select</span> stu_gender,<span class="built_in">count</span>(stu_num) <span class="keyword">from</span> stus <span class="keyword">group</span> <span class="keyword">by</span> stu_gender;</span><br><span class="line">#先对查询的学生信息按性别进行分组，再计算每一组平均年龄</span><br><span class="line"><span class="keyword">select</span> stu_gender,<span class="built_in">avg</span>(stu_age) <span class="keyword">from</span> stus <span class="keyword">group</span> <span class="keyword">by</span> stu_gender;</span><br><span class="line">#先把学生按年龄分组，再统计学生数量，再对结果排序</span><br><span class="line"><span class="keyword">select</span> stu_age,<span class="built_in">count</span>(stu_num) <span class="keyword">from</span> stus <span class="keyword">group</span> <span class="keyword">by</span> stu_age <span class="keyword">order</span> <span class="keyword">by</span> stu_age <span class="keyword">desc</span>;</span><br><span class="line">#查询所有学生，按年龄分组，然后分别统计每组人数，再筛选当前组人数<span class="operator">&gt;</span><span class="number">1</span>的组，再按年龄升序显示出来</span><br><span class="line"><span class="keyword">select</span> stu_age, <span class="built_in">count</span>(stu_num) <span class="keyword">from</span> stus <span class="keyword">group</span> <span class="keyword">by</span> stu_age <span class="keyword">having</span> <span class="built_in">count</span>(stu_num)<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> stu_age;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-9-分页查询"><a href="#2-7-9-分页查询" class="headerlink" title="2.7.9 分页查询"></a>2.7.9 分页查询</h4><p><strong>语法</strong></p>
<blockquote>
<p>select…<br>from…<br>where…<br>limit param1,param2;</p>
<p>param1:表示获取查询语句的结果中俄第一条数据的索引（索引从0开始）<br>param2: 表示获取的查询记录的条数，如果剩下的记录数小于param2，则返回剩下的记录数</p>
</blockquote>
<p><strong>案例</strong></p>
<p>对学生信息进行分页查询，共有10条数据，每页显示3条<br>总记录数：count 10<br>每页显示：pageSize 3<br>总页数：pageCount &#x3D; count%pageSize &#x3D;&#x3D; 0?count&#x2F;pageSize:count&#x2F;pageSize+1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询第一页</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stus <span class="keyword">where</span> ... limit <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line">#查询第二页</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stus <span class="keyword">where</span> ... limit <span class="number">1</span>,<span class="number">3</span>;</span><br><span class="line">#pageNum表示查询的页码,pageSize表示查询的条数</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tbName<span class="operator">&gt;</span> [<span class="keyword">where</span>] limit (pageNum<span class="number">-1</span>)<span class="operator">*</span>pageSize,pageSize;</span><br></pre></td></tr></table></figure>







<h2 id="三、数据表的关联关系"><a href="#三、数据表的关联关系" class="headerlink" title="三、数据表的关联关系"></a>三、数据表的关联关系</h2><hr>
<h3 id="3-1-关联关系介绍"><a href="#3-1-关联关系介绍" class="headerlink" title="3.1 关联关系介绍"></a>3.1 关联关系介绍</h3><blockquote>
<p>通过在数据表中添加字段建立外键约束建立关联关系</p>
</blockquote>
<p><strong>数据关系分为四种</strong></p>
<ul>
<li>一对一</li>
<li>一对多</li>
<li>多对一</li>
<li>多对多</li>
</ul>
<h3 id="3-2-外键约束"><a href="#3-2-外键约束" class="headerlink" title="3.2 外键约束"></a>3.2 外键约束</h3><p><strong>案例：学生表 与 班级表</strong></p>
<p>1.创建班级表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#建立没关系的表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes(</span><br><span class="line">class_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">class_name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">class_remark <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2.创建学生表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建学生表，在创建时添加外键约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu_info(</span><br><span class="line">stu_num <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">primary</span> key,</span><br><span class="line">stu_name <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">stu_gender <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">stu_age <span class="type">int</span>,</span><br><span class="line">cid <span class="type">int</span>,</span><br><span class="line"><span class="keyword">constraint</span> FK_stu_classes <span class="keyword">foreign</span> key(cid) <span class="keyword">references</span> classes(class_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>级联</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#级联操作</span><br><span class="line">#当class_id被关联，那既不能删除也不能修改，如果一定要修改：</span><br><span class="line"><span class="keyword">update</span> stu_info <span class="keyword">set</span> cid<span class="operator">=</span><span class="keyword">null</span> <span class="keyword">where</span> cid<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">update</span> classes <span class="keyword">set</span> class_id<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> class_id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">#在<span class="keyword">sql</span>中判断是否等于<span class="keyword">null</span>用<span class="keyword">is</span></span><br><span class="line"><span class="keyword">update</span> stu_info <span class="keyword">set</span> cid<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> cid <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">#若用级联操作可以很方便解决</span><br><span class="line">#先删除外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu_info <span class="keyword">drop</span> <span class="keyword">foreign</span> key FK_stu_classes;</span><br><span class="line">#添加外键时添加级联修改和级联删除</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu_info <span class="keyword">add</span> <span class="keyword">constraint</span> FK_stu_classes <span class="keyword">foreign</span> key(cid) <span class="keyword">references</span> classes(class_id)</span><br><span class="line">      <span class="keyword">on</span> <span class="keyword">update</span> CASCADE <span class="keyword">on</span> <span class="keyword">delete</span> CASCADE;</span><br><span class="line">#修改，删除测试</span><br><span class="line"><span class="keyword">update</span> classes <span class="keyword">set</span> class_id<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> class_name<span class="operator">=</span><span class="string">&#x27;Java002&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> classes <span class="keyword">where</span> class_id<span class="operator">=</span><span class="number">2</span>;#删除了id<span class="operator">=</span><span class="number">2</span>的课程后，与其相关联的学生也都被删除了</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="四、连结查询"><a href="#四、连结查询" class="headerlink" title="四、连结查询"></a>四、连结查询</h2><hr>
<h3 id="4-1-内连接"><a href="#4-1-内连接" class="headerlink" title="4.1 内连接"></a>4.1 内连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">inner</span> <span class="keyword">join</span>:</span><br><span class="line">#执行以下语句，会产生两张表的笛卡尔积</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">inner</span> <span class="keyword">join</span> classes;</span><br><span class="line">#先生成笛卡尔积，再用<span class="keyword">where</span>进行过滤（效率很低），所以把<span class="keyword">where</span>改<span class="keyword">on</span>，先判断条件，再链接,所以基本用<span class="keyword">on</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">inner</span> <span class="keyword">join</span> classes <span class="keyword">where</span> stu_info.cid<span class="operator">=</span>classes.class_id;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">inner</span> <span class="keyword">join</span> classes <span class="keyword">on</span> stu_info.cid<span class="operator">=</span>classes.class_id;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">inner</span> <span class="keyword">join</span> classes <span class="keyword">on</span> stu_info.cid<span class="operator">=</span>classes.class_id <span class="keyword">where</span> stu_gender<span class="operator">=</span><span class="string">&#x27;male&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-左连接"><a href="#4-2-左连接" class="headerlink" title="4.2 左连接"></a>4.2 左连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">left</span> <span class="keyword">join</span>:显示左表所有数据，如果有和右表匹配的数据那就匹配，如果没有就显示<span class="keyword">null</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">left</span> <span class="keyword">join</span> classes <span class="keyword">on</span> stu_info.cid<span class="operator">=</span>classes.class_id;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-右连接"><a href="#4-3-右连接" class="headerlink" title="4.3 右连接"></a>4.3 右连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">right</span> <span class="keyword">join</span>:与左链接相反</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">right</span> <span class="keyword">join</span> classes <span class="keyword">on</span> stu_info.cid<span class="operator">=</span>classes.class_id;</span><br></pre></td></tr></table></figure>



<h3 id="4-4-数据表别名"><a href="#4-4-数据表别名" class="headerlink" title="4.4 数据表别名"></a>4.4 数据表别名</h3><blockquote>
<p>当两张表有相同字段时，可以用table.column来区分，但是当表名太长这样不方便时，可以使用数据表别名</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.<span class="operator">*</span>,c.class_name</span><br><span class="line"><span class="keyword">from</span> stu_info s</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> classes c</span><br><span class="line"><span class="keyword">on</span> s.cid<span class="operator">=</span>c.class_id;</span><br></pre></td></tr></table></figure>



<h3 id="4-5-子查询"><a href="#4-5-子查询" class="headerlink" title="4.5 子查询"></a>4.5 子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#子查询<span class="operator">/</span>嵌套查询:第一次查询的结果作为第二次查询的条件</span><br><span class="line">#case1:假设只知道班级名Java001，不知道班级id，去查该班级学生信息，返回单列：<span class="operator">&gt;</span> <span class="operator">&lt;</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">where</span> cid<span class="operator">=</span>(<span class="keyword">select</span> class_id <span class="keyword">from</span> classes <span class="keyword">where</span> class_name<span class="operator">=</span><span class="string">&#x27;Java001&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#case2:查询所有java班级中的学生信息</span><br><span class="line">#function1:<span class="keyword">union</span>:表示将多个查询语句的结果放在一起,</span><br><span class="line"><span class="keyword">select</span> class_id <span class="keyword">from</span> classes <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">&#x27;%Java%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">where</span> cid<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">where</span> cid<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">where</span> cid<span class="operator">=</span><span class="number">3</span></span><br><span class="line">#funtion2:返回多列：<span class="keyword">in</span> , <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">where</span> cid <span class="keyword">in</span> (<span class="keyword">select</span> class_id <span class="keyword">from</span> classes <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">&#x27;%Java%&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#case3:查询所有cid<span class="operator">=</span><span class="number">1</span>的班级中性别为男的学生信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">where</span> stu_gender<span class="operator">=</span><span class="string">&#x27;female&#x27;</span> <span class="keyword">and</span> cid<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">#记得要取别名，不然就有虚拟表和stu表字段重名的错误了</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> stu_info <span class="keyword">where</span> cid<span class="operator">=</span><span class="number">1</span>) t <span class="keyword">where</span> t.stu_gender<span class="operator">=</span><span class="string">&#x27;female&#x27;</span>;</span><br></pre></td></tr></table></figure>





<h2 id="五、存储过程"><a href="#五、存储过程" class="headerlink" title="五、存储过程"></a>五、存储过程</h2><hr>
<h3 id="5-1-存储过程介绍"><a href="#5-1-存储过程介绍" class="headerlink" title="5.1 存储过程介绍"></a>5.1 存储过程介绍</h3><h4 id="5-1-1-SQL指令执行过程"><a href="#5-1-1-SQL指令执行过程" class="headerlink" title="5.1.1 SQL指令执行过程"></a>5.1.1 SQL指令执行过程</h4><img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-03-30 at 23.15.18.png" alt="Screen Shot 2022-03-30 at 23.15.18" style="zoom:50%;" />



<h4 id="5-1-2-存储过程介绍"><a href="#5-1-2-存储过程介绍" class="headerlink" title="5.1.2 存储过程介绍"></a>5.1.2 存储过程介绍</h4><blockquote>
<p>将能够完成特定功能的sql指令进行封装（sql指令集），编译后存储在数据库服务器上，并且为之取一个名字，<br>客户端可以通过这个名字直接调用这个sql指令集，获得执行结果</p>
</blockquote>
<p><strong>优点</strong></p>
<ul>
<li>sql指令无需客户端编写，通过网络传送，既可以节省网络开销，同时避免sql指令在网络传输过程中被恶意篡改<br>保证安全性</li>
<li>存储过程经过编译创建并保存在数据库中的，执行过程无需重复的进行编译操作，对sql指令的性能进行提升</li>
<li>存储过程中多个sql指令之间存在逻辑关系，支持流程控制语句，可以实现更为复杂的业务</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>存储过程时针对不同数据库编写的，当我们切换到其他数据库就要重新进行编写</li>
<li>存储过程受限于数据库产品</li>
<li>如果是高并发业务会增加执行时间</li>
</ul>
<h3 id="5-2-创建存储过程"><a href="#5-2-创建存储过程" class="headerlink" title="5.2 创建存储过程"></a>5.2 创建存储过程</h3><h4 id="5-2-1-存储过程创建语句"><a href="#5-2-1-存储过程创建语句" class="headerlink" title="5.2.1 存储过程创建语句"></a>5.2.1 存储过程创建语句</h4><p><strong>案例</strong></p>
<p>创建存储过程实现加法运算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> proc_test1(<span class="keyword">in</span> a <span class="type">int</span>, <span class="keyword">in</span> b <span class="type">int</span>, <span class="keyword">out</span> c <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">set</span> c <span class="operator">=</span> a<span class="operator">+</span>b;</span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter;</span><br></pre></td></tr></table></figure>



<h3 id="5-3-调用存储过程"><a href="#5-3-调用存储过程" class="headerlink" title="5.3 调用存储过程"></a>5.3 调用存储过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#定义变量m</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">#调用存储过程</span><br><span class="line"><span class="keyword">call</span> proc_test(<span class="number">1</span>,<span class="number">2</span>,<span class="variable">@m</span>)</span><br><span class="line">#显示变量<span class="variable">@m</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@m</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<h3 id="5-4-存储过程中变量的使用"><a href="#5-4-存储过程中变量的使用" class="headerlink" title="5.4 存储过程中变量的使用"></a>5.4 存储过程中变量的使用</h3><blockquote>
<p>存储过程中的变量分为两种，**局部变量 **和 <strong>用户变量</strong></p>
</blockquote>
<h4 id="5-4-1-局部变量"><a href="#5-4-1-局部变量" class="headerlink" title="5.4.1 局部变量"></a>5.4.1 局部变量</h4><blockquote>
<p>定义在存储过程中的变量，只能在存储过程内部使用<br>—–局部变量要定义在存储过程中，而且必须定义在存储过程开始</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test2(<span class="keyword">in</span> a <span class="type">int</span>, <span class="keyword">out</span> r <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> x <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;#定义局部变量</span><br><span class="line">  <span class="keyword">declare</span> y <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">set</span> x <span class="operator">=</span> a<span class="operator">*</span>a;</span><br><span class="line">  <span class="keyword">set</span> y <span class="operator">=</span> a<span class="operator">/</span><span class="number">2</span>;</span><br><span class="line">  <span class="keyword">set</span> r <span class="operator">=</span> x<span class="operator">+</span>y;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h4 id="5-4-2-用户变量"><a href="#5-4-2-用户变量" class="headerlink" title="5.4.2 用户变量"></a>5.4.2 用户变量</h4><blockquote>
<p>用户变量相当于全局变量，定义的用户变量可以通过‘select @name’ 进行查询</p>
<p>–用户变量会存储在mysql数据库的数据字典中（dual）<br>–用户变量定义使用set关键字直接定义变量名要以@开头</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h4 id="5-4-3-给变量赋值"><a href="#5-4-3-给变量赋值" class="headerlink" title="5.4.3 给变量赋值"></a>5.4.3 给变量赋值</h4><blockquote>
<p>无论局部变量还是用户变量，都使用set关键字修改值</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@n</span> <span class="operator">=</span><span class="number">1</span>;           #给用户变量赋值</span><br><span class="line"><span class="keyword">call</span> test2(<span class="number">6</span>,<span class="variable">@n</span>);    #给局部变量赋值</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@n</span> <span class="keyword">from</span> dual; </span><br></pre></td></tr></table></figure>



<h4 id="5-4-4-将查询结果赋值给变量"><a href="#5-4-4-将查询结果赋值给变量" class="headerlink" title="5.4.4 将查询结果赋值给变量"></a>5.4.4 将查询结果赋值给变量</h4><p>在存储过程中使用select..into..给变量赋值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test3(<span class="keyword">out</span> c <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(sid) <span class="keyword">into</span> c <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@num</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">call</span> test3(<span class="variable">@num</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@num</span> <span class="keyword">from</span> dual; </span><br></pre></td></tr></table></figure>



<h4 id="5-4-5-用户变量使用注意事项"><a href="#5-4-5-用户变量使用注意事项" class="headerlink" title="5.4.5 用户变量使用注意事项"></a>5.4.5 用户变量使用注意事项</h4><blockquote>
<p>因为用户变量相当于全局变量，可以在sql指令以及多个存储过程中共享，在开发中<br>建议少使用用户变量，因为用户变量过多，会导致程序不易理解，难以维护。</p>
</blockquote>
<h3 id="5-5-存储过程的参数"><a href="#5-5-存储过程的参数" class="headerlink" title="5.5 存储过程的参数"></a>5.5 存储过程的参数</h3><blockquote>
<p>mysql存储过程的参数共三种：in , out , inout</p>
</blockquote>
<h4 id="5-5-1-in输入参数"><a href="#5-5-1-in输入参数" class="headerlink" title="5.5.1 in输入参数"></a>5.5.1 in输入参数</h4><p>输入参数–在调用存储过程中传递参数给存储过程饿的参数（在调用过程中必须有实际值 或者是字面值）</p>
<h4 id="5-5-2-输出参数"><a href="#5-5-2-输出参数" class="headerlink" title="5.5.2 输出参数"></a>5.5.2 输出参数</h4><p>输出参数–将存储过程中产生的数据返回给过程的调用者，相当于java方法的返回值，<br>                 但不同的是，一个存储过程可以有多个输出参数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test4(<span class="keyword">in</span> stu_id <span class="type">char</span>(<span class="number">5</span>),<span class="keyword">out</span> stu_name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> sname <span class="keyword">into</span> stu_name <span class="keyword">from</span> students <span class="keyword">where</span> stu_id <span class="operator">=</span> sid;</span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@name</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">call</span> test4(<span class="string">&#x27;10001&#x27;</span>,<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@name</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<h4 id="5-5-3-输入输出参数"><a href="#5-5-3-输入输出参数" class="headerlink" title="5.5.3 输入输出参数"></a>5.5.3 输入输出参数</h4><p>不建议使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test5(<span class="keyword">inout</span> str <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> sname <span class="keyword">into</span> str <span class="keyword">from</span> students <span class="keyword">where</span> sid <span class="operator">=</span> str;</span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@name</span> <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"><span class="keyword">call</span> test5(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@name</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>





<h3 id="5-6-存储过程中流程控制"><a href="#5-6-存储过程中流程控制" class="headerlink" title="5.6 存储过程中流程控制"></a>5.6 存储过程中流程控制</h3><blockquote>
<p>在存储过程中支持流程控制语句用于实现流程的控制</p>
</blockquote>
<h4 id="5-6-1-分支语句"><a href="#5-6-1-分支语句" class="headerlink" title="5.6.1 分支语句"></a>5.6.1 分支语句</h4><ul>
<li>If-then-else</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#单分支</span><br><span class="line">if a<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span> </span><br><span class="line">         #<span class="keyword">sql</span>；</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">#双分支</span><br><span class="line">if a<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span> </span><br><span class="line">        #sql1；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        #sql2；</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>case</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> a <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">case</span> a </span><br><span class="line"> <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> </span><br><span class="line">         #sql1;</span><br><span class="line"> <span class="keyword">when</span> <span class="number">2</span> <span class="keyword">then</span> </span><br><span class="line">         #sql2;</span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">         #sql3; 如果a的值和<span class="keyword">when</span>的选项都不匹配，则执行此语句</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-2-循环语句"><a href="#5-6-2-循环语句" class="headerlink" title="5.6.2 循环语句"></a>5.6.2 循环语句</h4><ul>
<li>while</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> a <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">while i <span class="operator">&lt;</span> a do</span><br><span class="line">#<span class="keyword">sql</span>;这里如果想用i，要用concat(‘str’,i)的操作</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>repeat</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> a <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">repeat </span><br><span class="line">#<span class="keyword">sql</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">until i<span class="operator">&gt;=</span>a</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure>

<ul>
<li>Loop</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> a <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">myloop:loop</span><br><span class="line">#<span class="keyword">sql</span>;</span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  if i <span class="operator">=</span> a <span class="keyword">then</span> </span><br><span class="line">        leave myloop;</span><br><span class="line">  <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> loop;</span><br></pre></td></tr></table></figure>





<h3 id="5-7-存储过程管理"><a href="#5-7-存储过程管理" class="headerlink" title="5.7 存储过程管理"></a>5.7 存储过程管理</h3><h4 id="5-7-1-查询存储过程"><a href="#5-7-1-查询存储过程" class="headerlink" title="5.7.1 查询存储过程"></a>5.7.1 查询存储过程</h4><blockquote>
<p>存储过程属于某个数据库，所以我们创建存储过程在某个数据库中时，只可以在这个数据库中调用此存储过程<br>存储过程在多个数据库中不共享</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#根据数据库名查询当前数据库所有存储过程</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> status <span class="keyword">where</span> db <span class="operator">=</span><span class="string">&#x27;&lt;db_mybatis&#x27;</span>;</span><br><span class="line">#查询存储过程创建细节</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> db_mybatis.test3;</span><br></pre></td></tr></table></figure>

<h4 id="5-7-2-修改存储过程"><a href="#5-7-2-修改存储过程" class="headerlink" title="5.7.2 修改存储过程"></a>5.7.2 修改存储过程</h4><blockquote>
<p>修改存储过程的特称&#x2F;特性<br>存储过程的特征参数：</p>
<ul>
<li><strong>CONTAINS SQL</strong> :表示子程序包含sql语句，但不包含读或写的语句</li>
<li><strong>No SQL</strong> :表示子程序中不包含sql语句</li>
<li><strong>READS SQL DATA</strong> :表示子程序中包含读数据语句</li>
<li><strong>MODIFIES SQL DATA</strong> :表示子程序中包含写数据语句</li>
<li><strong>SQL SECURITY</strong> :指明谁有权限来执行</li>
<li><strong>DEFINER</strong> :表示只有定义者自己才能执行</li>
<li><strong>INVOKER</strong> :表示调用者可以执行</li>
<li><strong>COMMENT ‘string’</strong> :表示注解信息</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">procedure</span> test3 <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA;</span><br></pre></td></tr></table></figure>



<h4 id="5-7-3-删除存储过程"><a href="#5-7-3-删除存储过程" class="headerlink" title="5.7.3 删除存储过程"></a>5.7.3 删除存储过程</h4><p>从可视化界面删除，或者:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> test;</span><br></pre></td></tr></table></figure>







<h3 id="5-8-存储过程案例"><a href="#5-8-存储过程案例" class="headerlink" title="5.8 存储过程案例"></a>5.8 存储过程案例</h3><blockquote>
<p>使用存储过程解决项目开发过程中的问题</p>
<p>使用存储过程，完成借书操作</p>
</blockquote>
<h4 id="5-8-1-数据准备"><a href="#5-8-1-数据准备" class="headerlink" title="5.8.1 数据准备"></a>5.8.1 数据准备</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> books(</span><br><span class="line">book_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">book_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">book_author <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">book_price <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">book_stock <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">book_desc <span class="type">varchar</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> books(book_id,book_name,book_author,book_price,book_stock,book_desc)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;java程序设计&#x27;</span>,<span class="string">&#x27;亮亮&#x27;</span>,<span class="number">38.80</span>,<span class="number">12</span>,<span class="string">&#x27;亮亮带你学java&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> books(book_id,book_name,book_author,book_price,book_stock,book_desc)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;java王者之路&#x27;</span>,<span class="string">&#x27;威哥&#x27;</span>,<span class="number">44.40</span>,<span class="number">9</span>,<span class="string">&#x27;java王者领路人&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> i_students(</span><br><span class="line">stu_num <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">primary</span> key,</span><br><span class="line">stu_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">stu_gender <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">stu_age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> i_students(stu_num,stu_name,stu_gender,stu_age)<span class="keyword">values</span>(<span class="string">&#x27;1001&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> i_students(stu_num,stu_name,stu_gender,stu_age)<span class="keyword">values</span>(<span class="string">&#x27;1002&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> i_students(stu_num,stu_name,stu_gender,stu_age)<span class="keyword">values</span>(<span class="string">&#x27;1003&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>



<h4 id="5-8-2-业务分析"><a href="#5-8-2-业务分析" class="headerlink" title="5.8.2 业务分析"></a>5.8.2 业务分析</h4><blockquote>
<p>创建存储过程实现借书的操作：哪个学生借哪本书，借多少本</p>
<p>操作：</p>
<ul>
<li>保存图书记录</li>
<li>修改图书库存</li>
</ul>
<p>条件：</p>
<ul>
<li>判断学生是否存在</li>
<li>判断图书是否存在，库存是否充足？</li>
</ul>
</blockquote>
<p><strong>创建借书记录表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>  records(</span><br><span class="line">rid <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">snum <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">bid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">borrow_num <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">is_return <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>, #<span class="number">0</span>表示未归还，<span class="number">1</span>表示归还</span><br><span class="line">borrow_date <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">constraint</span> FK_records_students <span class="keyword">foreign</span> key(snum) <span class="keyword">references</span> i_students(stu_num),</span><br><span class="line"><span class="keyword">constraint</span> FK_records_books <span class="keyword">foreign</span> key(bid) <span class="keyword">references</span> books(book_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="5-8-3-创建存储过程–借书"><a href="#5-8-3-创建存储过程–借书" class="headerlink" title="5.8.3 创建存储过程–借书"></a>5.8.3 创建存储过程–借书</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#参数<span class="number">1</span>:学号</span><br><span class="line">#参数<span class="number">2</span>:图书编号</span><br><span class="line">#参数<span class="number">3</span>：借书数量</span><br><span class="line">#参数<span class="number">4</span>:借书状态 （<span class="number">1</span>成功，<span class="number">2</span>学号不存在，<span class="number">3</span>图书不存在，<span class="number">4</span>库存不够）</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> proc_boorrow_book(<span class="keyword">in</span> a <span class="type">char</span>(<span class="number">8</span>), <span class="keyword">in</span> b <span class="type">int</span>, <span class="keyword">in</span> m <span class="type">int</span>,<span class="keyword">out</span> state <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> stu_count <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">declare</span> book_count <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">declare</span> stock <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">#判断学号是否存在</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(stu_num) <span class="keyword">into</span> stu_count <span class="keyword">from</span> i_students <span class="keyword">where</span> stu_num<span class="operator">=</span>a;</span><br><span class="line">if stu_count<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">	#学号存在,则判断图书id是否存在</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">count</span>(book_id) <span class="keyword">into</span> book_count <span class="keyword">from</span> books <span class="keyword">where</span> book_id<span class="operator">=</span>b;</span><br><span class="line">	if book_count <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">		#图书存在,则查询图书库存是否充足</span><br><span class="line">		<span class="keyword">select</span> book_stock <span class="keyword">into</span> stock <span class="keyword">from</span> books <span class="keyword">where</span> book_id <span class="operator">=</span> b;</span><br><span class="line">		if stock <span class="operator">&gt;=</span> m <span class="keyword">then</span> </span><br><span class="line">			#执行借书</span><br><span class="line">			#操作<span class="number">1</span>:生成借书记录，即在借书记录表中添加记录</span><br><span class="line">			<span class="keyword">insert</span> <span class="keyword">into</span> records(snum,bid,borrow_num,is_return,borrow_date) <span class="keyword">values</span>(a,b,m,<span class="number">0</span>,sysdate());</span><br><span class="line">			#操作<span class="number">2</span>：修改图书库存</span><br><span class="line">			<span class="keyword">update</span> books <span class="keyword">set</span> book_stock <span class="operator">=</span> stock<span class="operator">-</span>m <span class="keyword">where</span> book_id <span class="operator">=</span> b;</span><br><span class="line">			#借书成功</span><br><span class="line">			<span class="keyword">set</span> state <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			#库存不足</span><br><span class="line">			<span class="keyword">set</span> state <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		#图书不存在</span><br><span class="line">		<span class="keyword">set</span> state <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  #学号不存在</span><br><span class="line">	<span class="keyword">set</span> state <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span> if; </span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>



<h4 id="5-8-4-创建存储过程–还书"><a href="#5-8-4-创建存储过程–还书" class="headerlink" title="5.8.4 创建存储过程–还书"></a>5.8.4 创建存储过程–还书</h4><h3 id="5-9-游标"><a href="#5-9-游标" class="headerlink" title="5.9 游标"></a>5.9 游标</h3><blockquote>
<p>如果要创建一个存储过程，需要返回查询语句查询到的多条语句，如何实现？</p>
</blockquote>
<p><strong>查询一条数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test6(<span class="keyword">in</span> id <span class="type">int</span> ,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> bname <span class="type">varchar</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">declare</span> bauthor <span class="type">varchar</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">declare</span> bprice <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">select</span> book_name,book_author,book_price <span class="keyword">into</span> bname,bauthor,bprice <span class="keyword">from</span> books <span class="keyword">where</span> book_id <span class="operator">=</span> id;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> concat_ws(<span class="string">&#x27;~&#x27;</span>,bname,bauthor,bprice);</span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@r</span> <span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">call</span> test6(<span class="number">1</span>,<span class="variable">@r</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@r</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<h4 id="5-1-1-游标概念"><a href="#5-1-1-游标概念" class="headerlink" title="5.1.1 游标概念"></a>5.1.1 游标概念</h4><blockquote>
<p>游标可以用来依次取出查询结果集中的每一条数据–逐条读取查询结果集中的记录</p>
</blockquote>
<h4 id="5-1-2-游标使用步骤"><a href="#5-1-2-游标使用步骤" class="headerlink" title="5.1.2 游标使用步骤"></a>5.1.2 游标使用步骤</h4><ul>
<li>声明游标</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">cursor</span> <span class="keyword">for</span> select_statement;</span><br><span class="line">#示例</span><br><span class="line"><span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> book_name,book_author,book_price <span class="keyword">from</span> books;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开游标</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="keyword">open</span> cursor_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用游标,提取游标当前指向的记录，提取后游标自动下移</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">while i<span class="operator">&lt;</span>num do</span><br><span class="line">	<span class="keyword">fetch</span> mycursor <span class="keyword">into</span> bname,bauthor,bprice;</span><br><span class="line">	<span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">	#<span class="keyword">set</span> str <span class="operator">=</span> concat_ws(<span class="string">&#x27;~&#x27;</span>,bname,bauthor,bprice)</span><br><span class="line">	<span class="keyword">select</span> concat_ws(<span class="string">&#x27;~&#x27;</span>,bname,bauthor,bprice) <span class="keyword">into</span> str;</span><br><span class="line">	<span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> concat(<span class="string">&#x27;,&#x27;</span>,<span class="keyword">result</span>,str);</span><br><span class="line">	<span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭游标</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">close</span> cursor_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整代码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test7(<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> bname <span class="type">varchar</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">declare</span> bauthor <span class="type">varchar</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">declare</span> bprice <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">declare</span> num <span class="type">int</span>;</span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"><span class="keyword">declare</span> str <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line">#此查询语句返回一个结果集合，使用游标遍历查询的结果集合</span><br><span class="line"><span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> book_name,book_author,book_price <span class="keyword">from</span> books;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">into</span> num <span class="keyword">from</span> books;</span><br><span class="line">#打开游标</span><br><span class="line"><span class="keyword">open</span> mycursor;</span><br><span class="line">#使用游标要结合循环语句</span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">while i<span class="operator">&lt;</span>num do</span><br><span class="line">	<span class="keyword">fetch</span> mycursor <span class="keyword">into</span> bname,bauthor,bprice;</span><br><span class="line">	<span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">	#<span class="keyword">set</span> str <span class="operator">=</span> concat_ws(<span class="string">&#x27;~&#x27;</span>,bname,bauthor,bprice)</span><br><span class="line">	<span class="keyword">select</span> concat_ws(<span class="string">&#x27;~&#x27;</span>,bname,bauthor,bprice) <span class="keyword">into</span> str;</span><br><span class="line">	<span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> concat_ws(<span class="string">&#x27;,&#x27;</span>,<span class="keyword">result</span>,str);</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line">	#关闭游标</span><br><span class="line">	<span class="keyword">close</span> mycursor;</span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@r</span> <span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">call</span> test7(<span class="variable">@r</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@r</span> <span class="keyword">from</span> dual;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="六、触发器"><a href="#六、触发器" class="headerlink" title="六、触发器"></a>六、触发器</h3><hr>
<h4 id="6-1-触发器概念"><a href="#6-1-触发器概念" class="headerlink" title="6.1 触发器概念"></a>6.1 触发器概念</h4><blockquote>
<p>触发器是一种特殊的存储过程。触发器和存储过程一样是一个能够完成特定功能，存储在数据库服务器上的SQL<br>片段，但触发器无需调用，当对数据表中的数据执行DML操作时会自动触发SQL片段的执行，而无需手动调用</p>
<p>在mysql中，只有执行insert&#x2F;delete&#x2F;update操作才能触发触发器的执行</p>
</blockquote>
<h3 id="6-2-触发器的使用"><a href="#6-2-触发器的使用" class="headerlink" title="6.2 触发器的使用"></a>6.2 触发器的使用</h3><h4 id="6-2-1-案例说明"><a href="#6-2-1-案例说明" class="headerlink" title="6.2.1 案例说明"></a>6.2.1 案例说明</h4><p><strong>案例：日志信息表，记录对学生信息的操作（某时间对某学生进行某操作）</strong>，数据同5.1</p>
<ul>
<li>手动日志记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#日志信息表，记录对学生信息的操作（某时间对某学生进行某操作）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stulogs(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">logtime <span class="type">timestamp</span>,</span><br><span class="line">logtext <span class="type">varchar</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#当向学生表添加一条信息时，同时向日志表添加一条操作日志</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> i_students(stu_num,stu_name,stu_gender,stu_age) <span class="keyword">values</span>(<span class="string">&#x27;1004&#x27;</span>,<span class="string">&#x27;小丽&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(<span class="type">time</span>,logtext) <span class="keyword">values</span>(now(),<span class="string">&#x27;添加1004学生信息&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="6-2-2-创建触发器"><a href="#6-2-2-创建触发器" class="headerlink" title="6.2.2 创建触发器"></a>6.2.2 创建触发器</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_name </span><br><span class="line"><span class="operator">&lt;</span>before<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>after<span class="operator">&gt;</span>      #定义触发时机</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span><span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span><span class="keyword">delete</span><span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span><span class="keyword">update</span><span class="operator">&gt;</span> #定义触发类型</span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>      #声明为行级触发器，即只要操作一条记录就触发触发器一次</span><br><span class="line">sql_statement     #触发器操作</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#示例</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test1</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> i_students</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(logtime,logtext) <span class="keyword">values</span>(now(),concat(<span class="string">&#x27;添加&#x27;</span>,new.stu_num,<span class="string">&#x27;学生信息&#x27;</span>));</span><br></pre></td></tr></table></figure>



<h4 id="6-2-3-查看触发器"><a href="#6-2-3-查看触发器" class="headerlink" title="6.2.3 查看触发器"></a>6.2.3 查看触发器</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure>



<h4 id="6-2-3-测试触发器"><a href="#6-2-3-测试触发器" class="headerlink" title="6.2.3 测试触发器"></a>6.2.3 测试触发器</h4><ul>
<li>创建的触发器是在students表发生insert操作时触发，所以只需执行学生信息的添加操作</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#可同时添加多条或一条</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> i_students(stu_num,stu_name,stu_gender,stu_age) </span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;1006&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">21</span>),(<span class="string">&#x27;1007&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h4 id="6-2-4-删除触发器"><a href="#6-2-4-删除触发器" class="headerlink" title="6.2.4 删除触发器"></a>6.2.4 删除触发器</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> <span class="operator">&lt;</span>trigger_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-NEW-amp-OLD"><a href="#6-3-NEW-amp-OLD" class="headerlink" title="6.3 NEW &amp; OLD"></a>6.3 NEW &amp; OLD</h3><blockquote>
<p>触发器用于监听对数据表中数据的insert、delete、update操作，在触发器中通常处理这种DML的关联操作，我们可以<br>使用&#x3D;&#x3D;new&#x3D;&#x3D;和&#x3D;&#x3D;old&#x3D;&#x3D;关键字在触发器中获取触发这个触发器的DML操作的数据</p>
<ul>
<li>new  在触发器中用于获取insert操作添加的数据、或update操作修改后的数据</li>
<li>old  在触发器中用于获取delete操作删除前的数据,或update操作修改前的数据</li>
</ul>
</blockquote>
<h4 id="6-3-1-NEW"><a href="#6-3-1-NEW" class="headerlink" title="6.3.1 NEW"></a>6.3.1 NEW</h4><ul>
<li>insert操作中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test1</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> i_students</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(logtime,logtext) <span class="keyword">values</span>(now(),concat(<span class="string">&#x27;添加&#x27;</span>,new.stu_num,<span class="string">&#x27;学生信息&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>update操作中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test2</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> i_students <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(logtime,logtext) <span class="keyword">values</span>(now(),concat(<span class="string">&#x27;修改学生信息为&#x27;</span>,new.stu_num,new.stu_name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> i_students <span class="keyword">set</span> stu_name <span class="operator">=</span> <span class="string">&#x27;李雷&#x27;</span> <span class="keyword">where</span> stu_num <span class="operator">=</span> <span class="string">&#x27;1007&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-2-OLD"><a href="#6-3-2-OLD" class="headerlink" title="6.3.2 OLD"></a>6.3.2 OLD</h4><ul>
<li>delete操作中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test3</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> i_students <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(logtime,logtext) <span class="keyword">values</span>(now(),concat(<span class="string">&#x27;删除学生信息为&#x27;</span>,old.stu_num,old.stu_name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> i_students <span class="keyword">where</span> stu_num <span class="operator">=</span> <span class="string">&#x27;1007&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>update操作中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test4</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> i_students <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(logtime,logtext) <span class="keyword">values</span>(now(),concat(<span class="string">&#x27;将学生信息从&#x27;</span>,old.stu_name,<span class="string">&#x27;修改为&#x27;</span>,new.stu_name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> i_students <span class="keyword">set</span> stu_name <span class="operator">=</span> <span class="string">&#x27;李lei&#x27;</span> <span class="keyword">where</span> stu_num <span class="operator">=</span> <span class="string">&#x27;1006&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="6-4-触发器使用总结"><a href="#6-4-触发器使用总结" class="headerlink" title="6.4 触发器使用总结"></a>6.4 触发器使用总结</h3><h4 id="6-4-1-优点"><a href="#6-4-1-优点" class="headerlink" title="6.4.1 优点"></a>6.4.1 优点</h4><ul>
<li>触发器是自动执行的,当对触发器相关表执行相应DML操作会立即触发触发器</li>
<li>触发器可以实现表中的级联操作(关联操作),有利于保证数据的完整性</li>
<li>触发器可以对DML操作的数据更为复杂的合法性进行校验</li>
</ul>
<h4 id="6-4-2-缺点"><a href="#6-4-2-缺点" class="headerlink" title="6.4.2 缺点"></a>6.4.2 缺点</h4><ul>
<li>使用触发器实现的业务逻辑如果出现问题将难于定位,后期维护困难</li>
<li>如果大量使用触发器,导致代码结构杂乱,增加程序复杂性</li>
<li>当触发器处操作的数据量比较大时,执行效率会降低</li>
</ul>
<h4 id="6-4-3-使用建议"><a href="#6-4-3-使用建议" class="headerlink" title="6.4.3 使用建议"></a>6.4.3 使用建议</h4><ul>
<li>在互联网项目中,应避免使用触发器</li>
<li>对于并发量不大的项目可以选择使用存储过程,但在互联网使用存储过程<ul>
<li>原因是存储过程将实现业务逻辑交给数据库处理,增加了数据库负载,不利于数据库迁移</li>
</ul>
</li>
</ul>
<h2 id="七、视图"><a href="#七、视图" class="headerlink" title="七、视图"></a>七、视图</h2><hr>
<h3 id="7-1-视图的概念"><a href="#7-1-视图的概念" class="headerlink" title="7.1 视图的概念"></a>7.1 视图的概念</h3><blockquote>
<p>视图,&#x3D;&#x3D;就是数据库中一张表或多张表根据特定的条件查询出的数据构造成的虚拟表&#x3D;&#x3D;</p>
</blockquote>
<h3 id="7-2-视图的作用"><a href="#7-2-视图的作用" class="headerlink" title="7.2 视图的作用"></a>7.2 视图的作用</h3><ul>
<li><strong>安全性</strong> : 如果直接将数据表授权给用户操作,那么用户可以CRUD数据表中所有数据,假如我们想要对数据表中的数据进行保护<br>可以将公开的数据生成视图,授权用户访问视图,用户通过查询视图可以获取数据表中公开的数据,从而达到将数据表中的部分<br>数据对客户隐藏.</li>
<li><strong>简单性</strong> : 如果我们需要查询的数据来源于多张数据表,可以使用多表连结查询实现,我们通过视图将这些连结查询的结果对用户<br>开放,用户可以直接捅过查询视图获取多表数据,操作更便捷.</li>
</ul>
<h3 id="7-3-创建视图"><a href="#7-3-创建视图" class="headerlink" title="7.3 创建视图"></a>7.3 创建视图</h3><h4 id="7-3-1-语法"><a href="#7-3-1-语法" class="headerlink" title="7.3.1 语法"></a>7.3.1 语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">select_statement</span><br></pre></td></tr></table></figure>

<h4 id="7-3-2-示例"><a href="#7-3-2-示例" class="headerlink" title="7.3.2 示例"></a>7.3.2 示例</h4><ul>
<li>示例1</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#将学生表中性别为男的学生组成一个视图,这样女生信息将被“保护”起来</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_test1</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> i_students <span class="keyword">where</span> stu_gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> view_test1;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例二</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询学生借书信息,学生名,图书名,借书数量</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_test2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> s.stu_name , b.book_name , borrow_num</span><br><span class="line"><span class="keyword">from</span> i_students s <span class="keyword">inner</span> <span class="keyword">join</span> books b <span class="keyword">inner</span> <span class="keyword">join</span> records r</span><br><span class="line"><span class="keyword">on</span> r.bid <span class="operator">=</span> b.book_id <span class="keyword">and</span> r.snum <span class="operator">=</span> s.stu_num;</span><br><span class="line">#测试</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> view_test2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-4-视图数据的特性"><a href="#7-4-视图数据的特性" class="headerlink" title="7.4 视图数据的特性"></a>7.4 视图数据的特性</h3><blockquote>
<p>视图是虚拟表,查询视图的数据是来源于数据表的.当对视图数据进行操作时,对原数据表的数据是否有影响呢?</p>
</blockquote>
<p><strong>查询操作</strong>:如果在数据表中添加了新的数据,且这个数据满足创建视图时查询语句的条件,<br>               通过查询视图也可以查询出新增的数据,当删除原表中满足查询条件的数据时,<br>               也会从视图中删除.</p>
<p><strong>新增数据</strong>: 如果在视图中添加数据,那么数据会被添加到原表</p>
<p><strong>删除数据</strong>: 如果从视图删除数据也将从原表中删除</p>
<p><strong>修改数据</strong>: 如果在视图中修改数据原表也会修改</p>
<p>&#x3D;&#x3D;视图的使用建议&#x3D;&#x3D;: 对复杂查询简化操作,并且不会对数据进行修改的情况下可以使用视图,如果是多表联合查询,则不会成功</p>
<h3 id="7-5-查询视图结构"><a href="#7-5-查询视图结构" class="headerlink" title="7.5 查询视图结构"></a>7.5 查询视图结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> view_name;</span><br></pre></td></tr></table></figure>



<h3 id="7-6-修改视图"><a href="#7-6-修改视图" class="headerlink" title="7.6 修改视图"></a>7.6 修改视图</h3><ul>
<li>方式1–重新创建,覆盖原视图</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> view_test1</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> i_students <span class="keyword">where</span> stu_gender <span class="operator">=</span>&quot;女&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式2–使用alter view语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_test1</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> i_students <span class="keyword">where</span> stu_gender <span class="operator">=</span>&quot;男&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="7-7-删除视图"><a href="#7-7-删除视图" class="headerlink" title="7.7 删除视图"></a>7.7 删除视图</h3><p><strong>删除数据表时会同时删除数据表中数据,删除视图时不会影响原数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_test1;</span><br></pre></td></tr></table></figure>





<h2 id="八、索引"><a href="#八、索引" class="headerlink" title="八、索引"></a>八、索引</h2><hr>
<blockquote>
<p>数据库是用来存储数据的,在互联应用中数据库中存储的数据会很多(大数据),数据表中数据的查询速度会随着<br>数据量的增长逐渐变慢,从而导致相应用户请求的速度变慢—-用户体验很差,如何提高数据的查询效率呢?</p>
</blockquote>
<h3 id="8-1索引介绍"><a href="#8-1索引介绍" class="headerlink" title="8.1索引介绍"></a>8.1索引介绍</h3><blockquote>
<p>索引,就是将数据表中的某一列或某几列的值取出来构造成B+树结构进行存储,生成数据表的&#x3D;&#x3D;目录&#x3D;&#x3D;</p>
<p>当我们进行数据查找时现在目录中进行查找,得到对应的数据地址,然后再到数据表中根据地址快<br>速获取数据记录避免全表扫描</p>
</blockquote>
<h3 id="8-2-索引的分类"><a href="#8-2-索引的分类" class="headerlink" title="8.2 索引的分类"></a>8.2 索引的分类</h3><p>mysql中的索引,根据创建索引的列的不同分为:</p>
<ul>
<li>主键索引 : 在数据表的主键字段创建的索引,这个字段必须被primary key修饰,每张表只能有一个主键</li>
<li>唯一索引 : 在数据表中的唯一列创建的索引,此列的值只能出现一次,可以为null</li>
<li>普通索引 : 在普通字段上添加的索引,没有唯一限制</li>
<li>组合索引 : 两个及以上字段联合起来创建的索引</li>
</ul>
<p>&#x3D;&#x3D;说明&#x3D;&#x3D; :<br>1.在创建表时,将字段声明为主键,会自动在主键字段创建主键索引<br>2.在创建表时,将字段声明为唯一键(unique),会自动在唯一字段创建唯一索引</p>
<h3 id="8-3-创建索引"><a href="#8-3-创建索引" class="headerlink" title="8.3 创建索引"></a>8.3 创建索引</h3><h4 id="8-3-1-唯一索引"><a href="#8-3-1-唯一索引" class="headerlink" title="8.3.1 唯一索引"></a>8.3.1 唯一索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">create</span> <span class="keyword">unique</span> index <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(column_name);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index_test1 <span class="keyword">on</span> tb_testindex(tid);</span><br></pre></td></tr></table></figure>

<h4 id="8-3-2-普通索引"><a href="#8-3-2-普通索引" class="headerlink" title="8.3.2 普通索引"></a>8.3.2 普通索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">create</span> index <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(column_name);</span><br><span class="line"><span class="keyword">create</span> index index_test2 <span class="keyword">on</span> tb_testindex(sid);</span><br></pre></td></tr></table></figure>

<h4 id="8-3-3-组合索引"><a href="#8-3-3-组合索引" class="headerlink" title="8.3.3 组合索引"></a>8.3.3 组合索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">create</span> index <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(col1,col2);</span><br><span class="line"><span class="keyword">create</span> index index_test <span class="keyword">on</span> tb_testindex(sid,name);</span><br></pre></td></tr></table></figure>

<h4 id="8-3-4-全文索引"><a href="#8-3-4-全文索引" class="headerlink" title="8.3.4 全文索引"></a>8.3.4 全文索引</h4><blockquote>
<p>Mysql5.6 版本新增的索引,可以通过此索引进行全文检索操作,因为mysql全文检索不支持中文,因此<br>这个全文索引不被关注,在应用开发中通常是通过搜索引擎(数据库中间件)实现全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> fulltext index <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(col);</span><br></pre></td></tr></table></figure>



<h3 id="8-4-索引的使用"><a href="#8-4-索引的使用" class="headerlink" title="8.4 索引的使用"></a>8.4 索引的使用</h3><blockquote>
<p>索引创建成功后,无需调用,当根据创建索引的列进行查询的时候会自动使用索引</p>
<p>组合索引需要根据创建索引的所有字段进行查询时触发</p>
</blockquote>
<ul>
<li>在命令行窗口中可以查看查询语句的查询规划</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> tb_testindex <span class="keyword">where</span> tid <span class="operator">=</span> <span class="number">20000</span>\G;</span><br></pre></td></tr></table></figure>





<h3 id="8-5-查看索引"><a href="#8-5-查看索引" class="headerlink" title="8.5 查看索引"></a>8.5 查看索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#命令行查询语句</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tb_testindex\G;</span><br><span class="line"></span><br><span class="line">#可视化出窗口</span><br><span class="line"><span class="keyword">show</span> indexes <span class="keyword">from</span> tb_testindex;</span><br><span class="line"><span class="keyword">show</span> keys <span class="keyword">from</span> tb_testindex;</span><br></pre></td></tr></table></figure>



<h3 id="8-6-删除索引"><a href="#8-6-删除索引" class="headerlink" title="8.6 删除索引"></a>8.6 删除索引</h3><p>由于不同表中可能存在相同名的索引,所以删除索引时需要指定表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>





<h3 id="8-7-索引的使用总结"><a href="#8-7-索引的使用总结" class="headerlink" title="8.7 索引的使用总结"></a>8.7 索引的使用总结</h3><h4 id="8-7-1-优点"><a href="#8-7-1-优点" class="headerlink" title="8.7.1 优点"></a>8.7.1 优点</h4><ul>
<li>索引大大降低了数据库服务器在执行查询操作时扫描的数据量,提高查询效率</li>
<li>索引可以避免服务器进行排序、将随机的IO变成顺序IO</li>
<li>加锁</li>
</ul>
<h4 id="8-7-2-缺点"><a href="#8-7-2-缺点" class="headerlink" title="8.7.2 缺点"></a>8.7.2 缺点</h4><ul>
<li>索引是根据数据表列的值创建的,当数据表中数据发生DML操作时,索引页会更新</li>
<li>索引文件也会占用磁盘空间</li>
</ul>
<h4 id="8-7-3-使用注意事项"><a href="#8-7-3-使用注意事项" class="headerlink" title="8.7.3 使用注意事项"></a>8.7.3 使用注意事项</h4><ul>
<li>数据表中数据不多时,全表扫描可能更快,不建议使用索引</li>
<li>数据量很大,但DML操作频繁,不建议使用索引</li>
<li>不要在数据重复度高的列上创建索引(性别)</li>
<li>创建索引后要注意sql语句的编写,避免索引失效</li>
</ul>
<h2 id="九、数据库事务"><a href="#九、数据库事务" class="headerlink" title="九、数据库事务"></a>九、数据库事务</h2><hr>
<h3 id="9-1-数据库事务介绍"><a href="#9-1-数据库事务介绍" class="headerlink" title="9.1 数据库事务介绍"></a>9.1 数据库事务介绍</h3><ul>
<li>把完成特定业务的多个数据库DML操作步骤称之为一个事务</li>
<li>事务,就是完成同一个业务的多个DML操作</li>
<li>比如,借书和修改库存</li>
</ul>
<h3 id="9-2-数据库事务特性-ACID"><a href="#9-2-数据库事务特性-ACID" class="headerlink" title="9.2 数据库事务特性(ACID)"></a>9.2 数据库事务特性(ACID)</h3><ul>
<li>原子性(Atomicity) : 一个事务中的多个DML操作,要么同时执行成功,要么执行失败</li>
<li>一致性(Consistency) : 事务执行前后的数据库中的数据是一致的,完整性和一致性不被破坏</li>
<li>隔离型(Isolation) : 数据库允许多个事务同时执行,多个并行的事务不能相互影响.</li>
<li>持久性(Durability) : 事务完成后会数据的操作是永久的</li>
</ul>
<h3 id="9-3-MySQL事务管理"><a href="#9-3-MySQL事务管理" class="headerlink" title="9.3 MySQL事务管理"></a>9.3 MySQL事务管理</h3><h4 id="9-3-1-自动提交与手动提交"><a href="#9-3-1-自动提交与手动提交" class="headerlink" title="9.3.1 自动提交与手动提交"></a>9.3.1 自动提交与手动提交</h4><ul>
<li>在mysql中,默认DML指令的执行是自动提交的,当我们执行一个DML指令后,自动同步到数据库中</li>
</ul>
<img src="/Users/lei/Desktop/Screen Shot 2022-04-04 at 00.00.54.png" alt="Screen Shot 2022-04-04 at 00.00.54" style="zoom:50%;" />

<h4 id="9-3-2-事务管理"><a href="#9-3-2-事务管理" class="headerlink" title="9.3.2 事务管理"></a>9.3.2 事务管理</h4><blockquote>
<p>开启事务,就是关闭自动提交</p>
</blockquote>
<ul>
<li>在开始事务的第一个操作之前,执行 start transaction 开启事务</li>
<li>依次执行事务中每个DML操作</li>
<li>如果在执行过程中任何步骤出现异常,则执行 rollback 回滚事务</li>
<li>如果事务所有DML操作都成功,执行 commit 提交事务</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#开启事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">#操作<span class="number">1</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> records(snum,bid,borrow_num,is_return,borrow_date) <span class="keyword">values</span>(<span class="string">&#x27;1007&#x27;</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,sysdate());</span><br><span class="line">#回滚</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line">#操作<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> books <span class="keyword">set</span> book_stock <span class="operator">=</span> book_stock<span class="number">-2</span> <span class="keyword">where</span> book_id <span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">#提交事务 </span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>



<h3 id="9-4-事务隔离级别"><a href="#9-4-事务隔离级别" class="headerlink" title="9.4 事务隔离级别"></a>9.4 事务隔离级别</h3><blockquote>
<p>数据库允许多个事务并行,多个事务之间是隔离的、相互独立的;如果多个事务之间不隔离,操作同一数据时<br>可能会导致数据的一致性被破坏</p>
</blockquote>
<p>mysql数据库事务隔离级别</p>
<ul>
<li><strong>读未提交(read uncommitted)</strong> : t2可以读取t1执行但未提交的数据,可能会导致脏读</li>
</ul>
<blockquote>
<p>脏读: 一个事务读取到了另一个事务中未提交的数据,因为未提交的数据可能会回滚</p>
</blockquote>
<ul>
<li><strong>读已提交(red committed)</strong> : t2只能读区t1已经提交的数据,避免了脏读,但可能会导致虚读</li>
</ul>
<blockquote>
<p>不可重复读(虚读) : 同一个事务中两次查询到的价格不一致</p>
<p>例如: t2查询数据后, t1 修改了数据,t2第二次查询的数据与第一次查询的数据不一致</p>
</blockquote>
<ul>
<li><strong>可重复读(repeatable read)</strong> : t2执行第一次查询后,在事务结束之前其他事务不能修改对应数据,<br>避免了虚读,但可能会导致幻读</li>
</ul>
<blockquote>
<p>幻读: t2把所有商品价格修改为1元,然后t1向表中新增一个3元的商品,t2再查询时会以为查询出<br>了与修改不一致的商品</p>
</blockquote>
<ul>
<li>串行化(serializable) : 同时只允许一个事务对数据表进行操作;避免了脏读,虚读,幻读问题</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读(虚读)</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Read committed</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Serializable</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<h4 id="9-4-1-设置事务隔离级别"><a href="#9-4-1-设置事务隔离级别" class="headerlink" title="9.4.1 设置事务隔离级别"></a>9.4.1 设置事务隔离级别</h4><blockquote>
<p>我们可以通过设置数据库默认的事务隔离级别来控制事务之间的隔离性<br>也可以通过客户端与数据库连接来设置事务隔离性(在应用程序中);</p>
<p>MySql数据库默认隔离级别是&#x3D;&#x3D;可重复读&#x3D;&#x3D;</p>
</blockquote>
<ul>
<li>查看mysql数据库默认的隔离级别</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#在mysql8<span class="number">.0</span><span class="number">.3</span>以前</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx_isolation</span>;</span><br><span class="line">#之后</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置mysql默认隔离级别</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level read committed;</span><br></pre></td></tr></table></figure>









<h2 id="十、数据库设计"><a href="#十、数据库设计" class="headerlink" title="十、数据库设计"></a>十、数据库设计</h2><hr>
<blockquote>
<p>mysql数据库作为数据存储的介质为应用系统提供数据存储的服务,我们如何设计出合理的数据库、数据表<br>以满足应用系统的数据存储需求呢?</p>
</blockquote>
<h3 id="10-1-数据库设计流程"><a href="#10-1-数据库设计流程" class="headerlink" title="10.1 数据库设计流程"></a>10.1 数据库设计流程</h3><blockquote>
<p>数据库是为应用系统服务的,数据库存储什么样的数据也是由应用系统决定的 </p>
<p>当我们进行应用系统开发时,首先要明确应用系统功能需求–系统需求分析</p>
</blockquote>
<ol>
<li><p><strong>根据应用系统的功能,分析数据实体</strong>(就是要存储的数据对象)</p>
<ol>
<li>电商系统:商品、用户、订单….</li>
<li>教务管理系统: 学生、课程、成绩….</li>
</ol>
</li>
<li><p><strong>提取实体的数据项</strong>(就是实体的属性)</p>
<ol>
<li>商品(商品名称、商品图片、商品描述….)</li>
<li>用户(姓名、登录名、登陆密码….)</li>
</ol>
</li>
<li><p><strong>根据数据库设计三范式规范视图的数据项</strong></p>
<ol>
<li>如果实体数据项不满足三范式,可能会导致数据冗余,从而引起数据维护困难,破坏数据一致性等问题</li>
</ol>
</li>
<li><p><strong>绘制E-R图</strong>(实体关系图,直观的展示实体与实体之间的关系)</p>
</li>
<li><p><strong>数据库建模</strong></p>
<ol>
<li>三线图进行数据表设计</li>
<li>PowerDesigner</li>
<li>PDMan</li>
</ol>
</li>
<li><p><strong>建库建表,编写sql语句</strong></p>
</li>
<li><p><strong>添加测试数据</strong></p>
</li>
</ol>
<h3 id="10-2-数据库设计案例"><a href="#10-2-数据库设计案例" class="headerlink" title="10.2 数据库设计案例"></a>10.2 数据库设计案例</h3><blockquote>
<p>学校图书馆管理系统(借书)</p>
</blockquote>
<h4 id="10-2-1-数据实体"><a href="#10-2-1-数据实体" class="headerlink" title="10.2.1 数据实体"></a>10.2.1 数据实体</h4><ul>
<li>学生</li>
<li>图书</li>
<li>类别</li>
<li>借书记录</li>
<li>管理员</li>
</ul>
<h4 id="10-2-2-提取数据项"><a href="#10-2-2-提取数据项" class="headerlink" title="10.2.2 提取数据项"></a>10.2.2 提取数据项</h4><ul>
<li>学生(学号、姓名、性别、年龄、院系编号、院系名称、院系说明…)</li>
<li>院系(id、名称…)</li>
<li>图书(图书id、图书名称、图书作者、图书封面、图书价格、图书库存…)</li>
<li>类别(类别id、类别名称、类别描述…)</li>
<li>借书记录(记录id、学号、图书编号、是否归还、还书日期…)</li>
<li>管理员(管理员id、登录名、登陆密码、员工编号、员工姓名、练习方式(手机、qq]邮箱)…)</li>
<li>员工(id、姓名、手机、qq、邮箱)</li>
</ul>
<h4 id="10-2-3-三范式"><a href="#10-2-3-三范式" class="headerlink" title="10.2.3 三范式"></a>10.2.3 三范式</h4><ul>
<li><p><strong>第一范式</strong> : 要求数据表中的字段不可再分</p>
</li>
<li><p><strong>第二范式</strong> : 不存在非关键字段对关键字段的部分依赖,</p>
<p>以下表不满足第二范式</p>
</li>
</ul>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-04 at 16.52.51.png" alt="Screen Shot 2022-04-04 at 16.52.51" style="zoom:50%;" />

<pre><code>  改造后:
</code></pre>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-04 at 16.54.33.png" alt="Screen Shot 2022-04-04 at 16.54.33" style="zoom:50%;" />

<ul>
<li><strong>第三范式</strong> : 不存在非关键字段之间的传递依赖</li>
</ul>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-04 at 16.57.46.png" alt="Screen Shot 2022-04-04 at 16.57.46" style="zoom:50%;" />

<p>改造后</p>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-04 at 17.01.48.png" alt="Screen Shot 2022-04-04 at 17.01.48" style="zoom:50%;" />





<h4 id="4-2-4绘制E-R图"><a href="#4-2-4绘制E-R图" class="headerlink" title="4.2.4绘制E-R图"></a>4.2.4绘制E-R图</h4><blockquote>
<p>Entity-Relationship: 实体关系图,用于直观体现实体与实体之间关联关系</p>
</blockquote>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-04 at 17.11.18.png" alt="Screen Shot 2022-04-04 at 17.11.18" style="zoom:50%;" />





<h4 id="4-2-5-数据库建模-PD"><a href="#4-2-5-数据库建模-PD" class="headerlink" title="4.2.5 数据库建模(PD)"></a>4.2.5 数据库建模(PD)</h4><blockquote>
<p>E-R图实际就是数据库建模的一部分:</p>
<ul>
<li>E-R图 数据表设计 建表</li>
<li>PowerDesigner建模工具,到处数据表</li>
<li>PDMan 建模工具</li>
</ul>
</blockquote>
<ol>
<li>下载并安装PowerDesigner建模工具</li>
<li>PowerDesigner使用<ol>
<li>概念数据模型,(选择workspace右键new–conceptual data model),相当于E-R图</li>
<li>逻辑数据模型(tools – generate data model),体现了实体的主外键关联</li>
<li>物理数据模型(tools– generate physical data model) <ol>
<li>可以对物理数据模型进行微调</li>
<li>生成建库建表的sql语句(tatabase– generate database–生成sql文件–在sql ui中执行sql文件)</li>
</ol>
</li>
<li>面向对象模型<ol>
<li>生成实体类</li>
<li>如果想要借助建模工具生成java代码,在创建实体名属性名都要符合java规范</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>在企业项目开发基本不使用建模工具生成数据表和实体类因为有代码规范问题</p>
</blockquote>
<h4 id="4-2-6-PDMan"><a href="#4-2-6-PDMan" class="headerlink" title="4.2.6 PDMan"></a>4.2.6 PDMan</h4><ul>
<li>新建项目创建数据表</li>
<li>生成关系图</li>
</ul>
<h1 id="Java与数据库连接"><a href="#Java与数据库连接" class="headerlink" title="Java与数据库连接"></a>Java与数据库连接</h1><h2 id="一、JDBC"><a href="#一、JDBC" class="headerlink" title="一、JDBC"></a>一、JDBC</h2><hr>
<h3 id="1-1-JDBC简介"><a href="#1-1-JDBC简介" class="headerlink" title="1.1 JDBC简介"></a>1.1 JDBC简介</h3><blockquote>
<p>JDBC : java database connectivity .—-java与数据库的连接,数据库编程</p>
<p>JDBC时java语言(JDK) 为完成数据库访问操作提供的一套标准</p>
</blockquote>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-04 at 22.07.20.png" alt="Screen Shot 2022-04-04 at 22.07.20" style="zoom:50%;" />





<h3 id="1-2-JDBC步骤"><a href="#1-2-JDBC步骤" class="headerlink" title="1.2 JDBC步骤"></a>1.2 JDBC步骤</h3><hr>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-04 at 22.15.40.png" alt="Screen Shot 2022-04-04 at 22.15.40" style="zoom:50%;" />





<h2 id="二、JDBC案例"><a href="#二、JDBC案例" class="headerlink" title="二、JDBC案例"></a>二、JDBC案例</h2><hr>
<blockquote>
<p>是使用java代码完成数据访问的规范</p>
</blockquote>
<h3 id="2-1-加载驱动"><a href="#2-1-加载驱动" class="headerlink" title="2.1 加载驱动"></a>2.1 加载驱动</h3><h4 id="2-1-1-下载驱动jar包"><a href="#2-1-1-下载驱动jar包" class="headerlink" title="2.1.1 下载驱动jar包"></a>2.1.1 下载驱动jar包</h4><ul>
<li>maven repository</li>
<li>版本选择<br>mysql版本为5.x 建议使用5.1.47<br>mysql版本为8.x 建议使用8.0.x</li>
<li>点击jar文件下载</li>
</ul>
<h4 id="2-1-2-将驱动文件添加到Java应用"><a href="#2-1-2-将驱动文件添加到Java应用" class="headerlink" title="2.1.2 将驱动文件添加到Java应用"></a>2.1.2 将驱动文件添加到Java应用</h4><ul>
<li>在java应用中创建lib文件夹(根目录下)</li>
<li>将下载好的jar文件拷本-粘贴到lib目录</li>
<li>将驱动jar文件设置为java库:右键jar,选择最后add as library</li>
</ul>
<h4 id="2-1-3-注册驱动"><a href="#2-1-3-注册驱动" class="headerlink" title="2.1.3 注册驱动"></a>2.1.3 注册驱动</h4><blockquote>
<p>通过反射机制,将驱动jar文件中提供的驱动类载入到JVM中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="comment">//这个包在导入的jar中找到</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-创建连接"><a href="#2-2-创建连接" class="headerlink" title="2.2 创建连接"></a>2.2 创建连接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.创建链接 :通过数据库连结管理器 DriverManager</span></span><br><span class="line">       <span class="comment">// JDBC 是java提供的数据库连结规范 都在java.sql包中</span></span><br><span class="line">       <span class="comment">//java.sql.Connection接口，一个对象就表示一个数据库连接</span></span><br><span class="line">       <span class="comment">//通常用三个参数的connection</span></span><br><span class="line">       <span class="comment">//url：数据库的同一资源定位器（定位数据库连结资源）可用问号加参数</span></span><br><span class="line">       <span class="comment">// characterEncoding 设置编码</span></span><br><span class="line">       <span class="comment">// useSSL = true 使用ssl通信</span></span><br><span class="line">       <span class="comment">// useTimeZone = true 设置客户端和服务端时区转换</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;YES&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-3-编写sql指令"><a href="#2-3-编写sql指令" class="headerlink" title="2.3 编写sql指令"></a>2.3 编写sql指令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.编写要执行的sql指令 sql指令中需要的参数可以用字符串拼接形式传进来（但会导致sql注入问题）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(book_id,book_name,book_author,book_price,book_stock,book_desc) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;values(&#x27;&quot;</span>+id+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+name+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+author+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+price+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+stock+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+desc+<span class="string">&quot;&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-加载sql指令"><a href="#2-4-加载sql指令" class="headerlink" title="2.4 加载sql指令"></a>2.4 加载sql指令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 加载sql指令:获取sql指令的加载器</span></span><br><span class="line">        <span class="comment">// java.sql.statement对象 可以理解为sql指令的加载器</span></span><br><span class="line">        <span class="comment">//java.sql.preparedStatement对象，sql指令的预编译加载器</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br></pre></td></tr></table></figure>



<h3 id="2-5-执行sql、获取结果"><a href="#2-5-执行sql、获取结果" class="headerlink" title="2.5 执行sql、获取结果"></a>2.5 执行sql、获取结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.执行sql，获取执行结果</span></span><br><span class="line">        <span class="comment">//a 如果sql指令为DQL语句，则 Result rs = statement.executeQuery(sql); rs表示查询结果</span></span><br><span class="line">        <span class="comment">//b 如果sql指令为DML指令， 则 Int i = statement.executeUpdate(sql); i表示操作影响的数据行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate(sql);<span class="comment">//其中i&gt;0表示执行成功，如果i=0表示dml操作对数据表无影响</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-处理结果"><a href="#2-6-处理结果" class="headerlink" title="2.6 处理结果"></a>2.6 处理结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6 处理结果</span></span><br><span class="line">        <span class="comment">//添加：i&gt;0 添加成功，否则失败</span></span><br><span class="line">        <span class="comment">//修改操作 i&gt;0 修改有影响 ， i&lt;=0 表示对数据库无影响，但不一定是失败的，取决于操作条件</span></span><br><span class="line">        <span class="comment">//删除操作 i&gt;0 删除有影响 ， i&lt;=0 表示对数据库无影响</span></span><br><span class="line">        <span class="comment">//查询操作: 从rs中取出查询结果，封装到定义的java对象中</span></span><br><span class="line">        System.out.println(i&gt;<span class="number">0</span>?<span class="string">&quot;添加成功&quot;</span>:<span class="string">&quot;添加失败&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-7-关闭连接"><a href="#2-7-关闭连接" class="headerlink" title="2.7 关闭连接"></a>2.7 关闭连接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 7 关闭连接</span></span><br><span class="line">        <span class="comment">//如果执行dml操作要关闭statement和connection</span></span><br><span class="line">        <span class="comment">//如果执行查询操作，需要关闭ResultSet，statement和connection</span></span><br><span class="line">        <span class="comment">//关闭之前先判空,由小到大关闭</span></span><br><span class="line">        <span class="keyword">if</span>(!statement.isClosed() &amp;&amp; statement != <span class="literal">null</span>)&#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





<h2 id="三、JDBC操作实例"><a href="#三、JDBC操作实例" class="headerlink" title="三、JDBC操作实例"></a>三、JDBC操作实例</h2><hr>
<h3 id="3-1-insert操作"><a href="#3-1-insert操作" class="headerlink" title="3.1 insert操作"></a>3.1 insert操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInsertBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;1011&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Java进阶之路&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">20.01</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="string">&quot;good&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过jdbc将上述信息存储到数据库中</span></span><br><span class="line">        <span class="comment">// 1.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建链接 :通过数据库连结管理器 DriverManager</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.编写要执行的sql指令 sql指令中需要的参数可以用字符串拼接形式传进来（但会导致sql注入问题）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(book_id,book_name,book_author,book_price,book_stock,book_desc) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;values(&#x27;&quot;</span>+id+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+name+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+author+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+price+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+stock+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+desc+<span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line">        <span class="comment">// 4. 加载sql指令:获取sql指令的加载器</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="comment">// 5.执行sql，获取执行结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">        <span class="comment">// 6 处理结果</span></span><br><span class="line">        System.out.println(i&gt;<span class="number">0</span>?<span class="string">&quot;添加成功&quot;</span>:<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        <span class="comment">// 7 关闭连接       </span></span><br><span class="line">        <span class="keyword">if</span>(!statement.isClosed() &amp;&amp; statement != <span class="literal">null</span>)&#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-delete操作"><a href="#3-2-delete操作" class="headerlink" title="3.2 delete操作"></a>3.2 delete操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeleteBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bid</span> <span class="operator">=</span> <span class="number">1011</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用JDBC规范，根据图书id删除图书信息</span></span><br><span class="line">        <span class="comment">// 1 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 2 创建连结</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="comment">// 3 编写sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from books where book_id=&quot;</span>+bid;</span><br><span class="line">        <span class="comment">// 4 获取sql加载器</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="comment">// 5 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">        <span class="comment">// 6 处理结果</span></span><br><span class="line">        System.out.println(i&gt;<span class="number">0</span>?<span class="string">&quot;删除成功&quot;</span>:<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        <span class="comment">// 7 关闭连接</span></span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="literal">null</span> &amp;&amp; !statement.isClosed())&#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-3-update操作"><a href="#3-3-update操作" class="headerlink" title="3.3 update操作"></a>3.3 update操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUpdateBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="comment">//根据主键修改其他字段</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1011</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Java进阶之路&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">20.01</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="string">&quot;good&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update books set book_name=&#x27;&quot;</span>+name+<span class="string">&quot;&#x27;,book_author=&#x27;&quot;</span>+author+<span class="string">&quot;&#x27;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;book_price=&#x27;&quot;</span>+price+<span class="string">&quot;&#x27;,book_stock=&#x27;&quot;</span>+stock+<span class="string">&quot;&#x27;,book_desc=&#x27;&quot;</span>+desc+<span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;where book_id=&quot;</span>+id;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">        System.out.println(i&gt;<span class="number">0</span>?<span class="string">&quot;修改成功&quot;</span>:<span class="string">&quot;修改失败&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="literal">null</span> &amp;&amp; !statement.isClosed())&#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-4-select操作"><a href="#3-4-select操作" class="headerlink" title="3.4 select操作"></a>3.4 select操作</h3><blockquote>
<p>查询的信息以set结构返回</p>
</blockquote>
<ul>
<li>查询单个信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据图书id查询一本图书信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bid</span> <span class="operator">=</span> <span class="number">1011</span>;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from books where book_id=&quot;</span>+bid;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="comment">//通过executeQuery执行sql查询语句</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">        <span class="comment">//处理结果，从rs中获取结果，rs是一个指向结果集合的指针</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;book_id&quot;</span>);<span class="comment">//这里的名字是查询语句范围的列名，即如果取了别名就用别名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_author&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;book_price&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;book_stock&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_desc&quot;</span>);</span><br><span class="line">            System.out.println(id+<span class="string">&quot;\t&quot;</span>+name+<span class="string">&quot;\t&quot;</span>+author+<span class="string">&quot;\t&quot;</span>+price+<span class="string">&quot;\t&quot;</span>+stock+<span class="string">&quot;\t&quot;</span>+desc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连结,结果集也需要关闭</span></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span> &amp;&amp; !rs.isClosed())&#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="literal">null</span> &amp;&amp; !statement.isClosed())&#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询多个信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bid</span> <span class="operator">=</span> <span class="number">1011</span>;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from books&quot;</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;book_id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_author&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;book_price&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;book_stock&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_desc&quot;</span>);</span><br><span class="line">            System.out.println(id+<span class="string">&quot;\t&quot;</span>+name+<span class="string">&quot;\t&quot;</span>+author+<span class="string">&quot;\t&quot;</span>+price+<span class="string">&quot;\t&quot;</span>+stock+<span class="string">&quot;\t&quot;</span>+desc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span> &amp;&amp; !rs.isClosed())&#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="literal">null</span> &amp;&amp; !statement.isClosed())&#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





<h2 id="四、JDBC核心类与接口"><a href="#四、JDBC核心类与接口" class="headerlink" title="四、JDBC核心类与接口"></a>四、JDBC核心类与接口</h2><hr>
<blockquote>
<p>java.sql.DriverManager 类 驱动管理器<br>java.sql.Connection 接口 数据库连接<br>java.sql.Statement 接口 sql指令的加载&#x2F;执行器<br>java.sqlResultSet 接口 结果集</p>
</blockquote>
<h3 id="4-1-DriverManager类"><a href="#4-1-DriverManager类" class="headerlink" title="4.1 DriverManager类"></a>4.1 DriverManager类</h3><blockquote>
<ul>
<li>注册驱动</li>
<li>创建数据库连接</li>
</ul>
</blockquote>
<ul>
<li>注册驱动</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jc.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//在Driver类中静态初始化块中,注册驱动:DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">//应用程序中手动注册驱动的代码也可以省略</span></span><br><span class="line"><span class="comment">//如果没有手动注册,驱动管理器在获取连接的时候发现没有注册驱动,则读取驱动jar!/META-INF/services/java.sql.Driver文件中配置的</span></span><br><span class="line"><span class="comment">//驱动类路径进行注册</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;YES&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="4-2-Connection接口"><a href="#4-2-Connection接口" class="headerlink" title="4.2 Connection接口"></a>4.2 Connection接口</h3><blockquote>
<p>Connection对象表示java应用程序与数据库之间的连接</p>
<ul>
<li>通过Connection接口对象,获取执行sql语句的statement对象</li>
<li>完成数据库的事务管理</li>
</ul>
</blockquote>
<h4 id="4-2-1-获取Statement对象"><a href="#4-2-1-获取Statement对象" class="headerlink" title="4.2.1 获取Statement对象"></a>4.2.1 获取Statement对象</h4><ul>
<li>Statement接口:编译执行静态sql指令</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> Connection.createStatement();</span><br></pre></td></tr></table></figure>

<ul>
<li>PrepareStatement接口:预编译动态sql指令(解决sql注入问题)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrepaareStatement</span> <span class="variable">prepareStatement</span> <span class="operator">=</span> Connection.prepareStatement(sql);</span><br></pre></td></tr></table></figure>

<ul>
<li>CallableStatement接口(),继承了PreparedStatement接口,且可以调用存储过程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CallableStatement</span> <span class="variable">callableStatement</span> <span class="operator">=</span> connection.prepareCall(sql);</span><br></pre></td></tr></table></figure>



<h4 id="4-2-2-事务管理"><a href="#4-2-2-事务管理" class="headerlink" title="4.2.2 事务管理"></a>4.2.2 事务管理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启事务--取消自动提交</span></span><br><span class="line">        connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update books set book_name=&#x27;&quot;</span>+name+<span class="string">&quot;&#x27;,book_author=&#x27;&quot;</span>+author+<span class="string">&quot;&#x27;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;book_price=&#x27;&quot;</span>+price+<span class="string">&quot;&#x27;,book_stock=&#x27;&quot;</span>+stock+<span class="string">&quot;&#x27;,book_desc=&#x27;&quot;</span>+desc+<span class="string">&quot;&#x27;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;where book_id=&quot;</span>+id;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">        <span class="comment">//事务回滚</span></span><br><span class="line">        connection.rollback();</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        connection.commit();</span><br></pre></td></tr></table></figure>







<h3 id="4-3-Statement接口"><a href="#4-3-Statement接口" class="headerlink" title="4.3 Statement接口"></a>4.3 Statement接口</h3><blockquote>
<p>用于编译执行sql指令</p>
</blockquote>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-05 at 22.53.03.png" alt="Screen Shot 2022-04-05 at 22.53.03" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行DML操作sql指令</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line"><span class="comment">//执行DQL操作sql指令</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br></pre></td></tr></table></figure>



<h3 id="4-4-ResultSet接口"><a href="#4-4-ResultSet接口" class="headerlink" title="4.4 ResultSet接口"></a>4.4 ResultSet接口</h3><blockquote>
<p>ResultSet接口对象,表示查询操作返回的结果集</p>
</blockquote>
<ul>
<li>判断结果集中是否还有数据未取出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rs.next();</span><br></pre></td></tr></table></figure>

<ul>
<li>获取结果集中某行数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rs.getInt(colName);</span><br><span class="line">rs.getDouble(colName);</span><br><span class="line">rs.getDate(colName);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>







<h2 id="五、SQL注入问题"><a href="#五、SQL注入问题" class="headerlink" title="五、SQL注入问题"></a>五、SQL注入问题</h2><hr>
<h3 id="5-1-什么是SQL注入"><a href="#5-1-什么是SQL注入" class="headerlink" title="5.1 什么是SQL注入"></a>5.1 什么是SQL注入</h3><blockquote>
<p>在JDBC操作sql指令编写过程中,如果sql指令需要数据,可以通过字符串拼接形式拼接到指令中<br>如 : String sql &#x3D; “delete from books where book_id &#x3D;”+s;<br>这种形式可能导致&#x3D;&#x3D;因变量值的改变导致SQL指令原意发生改变&#x3D;&#x3D;,被称为sql注入</p>
<p>例如:</p>
<ol>
<li>如果s为1 ; sql为: delete from books where book_id where book_id &#x3D;1;</li>
<li>如果s为 1 or 1&#x3D;1 ; sql 为: delete from books where book_id where book_id &#x3D;1 or 1&#x3D;1;</li>
</ol>
</blockquote>
<h3 id="5-2-解决sql注入问题"><a href="#5-2-解决sql注入问题" class="headerlink" title="5.2 解决sql注入问题"></a>5.2 解决sql注入问题</h3><blockquote>
<p>使用PreparedStatement进行SQL预编译解决sql注入问题</p>
<ol>
<li><p>如果sql指令需要参数,一律使用&#x3D;&#x3D;?&#x3D;&#x3D;参数占位符</p>
</li>
<li><p>如果sql指令有&#x3D;&#x3D;?&#x3D;&#x3D;,在jdbc操作步骤中,从connection对象获取preparedStatement对sql进行预编译</p>
<p>String sql &#x3D; “delete from books where book_id&#x3D;?”;<br>PreparedStatement statement &#x3D; connection.prepareStatement(sql);</p>
</li>
<li><p>预编译完成后,通过PreparedStatement对象给预编译后sql指令的&#x3D;&#x3D;?&#x3D;&#x3D;赋值</p>
</li>
<li><p>sql指令中的&#x3D;&#x3D;?&#x3D;&#x3D;完成赋值之后,通过preparedStatement对象执行sql,但不再加载,因为加载过了<br>int i &#x3D; statement.executeUpdate();</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>,name);</span><br><span class="line">        statement.setString(<span class="number">2</span>,author);</span><br><span class="line">        statement.setDouble(<span class="number">3</span>,price);</span><br><span class="line">        statement.setInt(<span class="number">4</span>,stock);</span><br><span class="line">        statement.setString(<span class="number">5</span>,desc);</span><br><span class="line"> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate();</span><br></pre></td></tr></table></figure>





<h3 id="5-3-PreparedStatement案例"><a href="#5-3-PreparedStatement案例" class="headerlink" title="5.3 PreparedStatement案例"></a>5.3 PreparedStatement案例</h3><ul>
<li>insert</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInsertBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;1011&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Java进阶之路&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">20.01</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="string">&quot;good&quot;</span>;</span><br><span class="line">      </span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;</span>;   </span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>,name);</span><br><span class="line">        statement.setString(<span class="number">2</span>,author);</span><br><span class="line">        statement.setDouble(<span class="number">3</span>,price);</span><br><span class="line">        statement.setInt(<span class="number">4</span>,stock);</span><br><span class="line">        statement.setString(<span class="number">5</span>,desc);       </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate();/</span><br><span class="line">        System.out.println(i&gt;<span class="number">0</span>?<span class="string">&quot;添加成功&quot;</span>:<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!statement.isClosed() &amp;&amp; statement != <span class="literal">null</span>)&#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果sql需要参数,使用preparedStatement,不需要参数就用statemnt</strong><br><strong>因为statement效率要高一点</strong></p>
<h2 id="六、工具类封装"><a href="#六、工具类封装" class="headerlink" title="六、工具类封装"></a>六、工具类封装</h2><hr>
<h3 id="6-1-工具类封装"><a href="#6-1-工具类封装" class="headerlink" title="6.1 工具类封装"></a>6.1 工具类封装</h3><h4 id="6-1-1-数据库连接"><a href="#6-1-1-数据库连接" class="headerlink" title="6.1.1 数据库连接"></a>6.1.1 数据库连接</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">           connection = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;注册驱动失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;创建连接失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-1-2-关闭连接"><a href="#6-1-2-关闭连接" class="headerlink" title="6.1.2 关闭连接"></a>6.1.2 关闭连接</h4><p><strong>需要四个参数不同的关闭</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">(PreparedStatement statement, Connection connection)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!statement.isClosed() &amp;&amp; statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">(Statement statement, Connection connection)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!statement.isClosed() &amp;&amp; statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-1-3-优化"><a href="#6-1-3-优化" class="headerlink" title="6.1.3 优化"></a>6.1.3 优化</h4><ol>
<li>每次获取connection都要注册一次数据库,所以写在静态初始化块中</li>
<li>把创建连接时需要的URL,DRIVER,USERNAME,PASSWORD等参数提前声明好</li>
<li>父接口做参数子接口也可以往里面传</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;YES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册驱动只需一次，因此放在静态初始化块中完成</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;注册驱动失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DriverManager.getConnection(URL,USERNAME,PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建连接失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">(Statement statement, Connection connection)</span>&#123;</span><br><span class="line">        closeConnection(<span class="literal">null</span>,statement,connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">(ResultSet resultSet,Statement statement, Connection connection)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!resultSet.isClosed() &amp;&amp; resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!statement.isClosed() &amp;&amp; statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h2 id="七、DAO与DTO的封装"><a href="#七、DAO与DTO的封装" class="headerlink" title="七、DAO与DTO的封装"></a>七、DAO与DTO的封装</h2><hr>
<blockquote>
<p>DAO : Data Access Object 数据访问对象</p>
<p>DTO : Data Transfer Object 数据传输对象</p>
</blockquote>
<h3 id="7-1-CRUD方法的封装"><a href="#7-1-CRUD方法的封装" class="headerlink" title="7.1 CRUD方法的封装"></a>7.1 CRUD方法的封装</h3><blockquote>
<p>将能完成某个CRUD操作的代码单独定义成一个方法</p>
</blockquote>
<h3 id="7-2-DTO实体类封装"><a href="#7-2-DTO实体类封装" class="headerlink" title="7.2 DTO实体类封装"></a>7.2 DTO实体类封装</h3><blockquote>
<p>在封装CRUD操作时,对于查询操作而言,需要将查询到的数据库数据返回给调用者,但一个查询方法只能返回一个值,<br>而一条数据库记录有多个值,如何将一条数据库记录的多个值返回呢?</p>
<p>处理;在java程序中,创建一个属性与数据库表匹配的类,通过此类的对象封装查询到的数据,我们把用于传递JDBC<br>CRUD操作的数据的类称之为数据传输对象</p>
</blockquote>
<p><strong>实体类创建规则及实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类中的属性的个数和类型与对应的数据表保持一致</span></span><br><span class="line"><span class="comment">//提供所有属性的get和set方法 command+n</span></span><br><span class="line"><span class="comment">//提供类的全参构造器</span></span><br><span class="line"><span class="comment">//提供无参构造器</span></span><br><span class="line"><span class="comment">//重写toString方法</span></span><br><span class="line"><span class="comment">//暂略：重写hashcode，和equals</span></span><br><span class="line"><span class="comment">//实现：序列化接口 Serializable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中的属性的个数和类型与对应的数据表保持一致</span></span><br><span class="line">    <span class="comment">//提供所有属性的get和set方法 command+n</span></span><br><span class="line">    <span class="comment">//提供类的全参构造器</span></span><br><span class="line">    <span class="comment">//提供无参构造器</span></span><br><span class="line">    <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="comment">//暂略：重写hashcode，和equals</span></span><br><span class="line">    <span class="comment">//实现：序列化接口 Serializable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bookId;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> String bookAuthor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bookPrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bookStock;</span><br><span class="line">    <span class="keyword">private</span> String bookDesc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;bookId=&quot;</span> + bookId +</span><br><span class="line">                <span class="string">&quot;, bookName=&#x27;&quot;</span> + bookName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, bookAuthor=&#x27;&quot;</span> + bookAuthor + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, bookPrice=&quot;</span> + bookPrice +</span><br><span class="line">                <span class="string">&quot;, bookStock=&quot;</span> + bookStock +</span><br><span class="line">                <span class="string">&quot;, bookDesc=&#x27;&quot;</span> + bookDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(<span class="type">int</span> bookId, String bookName, String bookAuthor, <span class="type">double</span> bookPrice, <span class="type">int</span> bookStock, String bookDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookId = bookId;</span><br><span class="line">        <span class="built_in">this</span>.bookName = bookName;</span><br><span class="line">        <span class="built_in">this</span>.bookAuthor = bookAuthor;</span><br><span class="line">        <span class="built_in">this</span>.bookPrice = bookPrice;</span><br><span class="line">        <span class="built_in">this</span>.bookStock = bookStock;</span><br><span class="line">        <span class="built_in">this</span>.bookDesc = bookDesc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//get 和 set方法太多了,省略 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用实体类封装查询数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSelectBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TestSelectBook</span> <span class="variable">testSelectBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestSelectBook</span>();</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> testSelectBook.queryBook(<span class="number">2</span>);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">queryBook</span><span class="params">(<span class="type">int</span> bid)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBHelper.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from books where book_id=&quot;</span>+bid;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="comment">//通过executeQuery执行sql查询语句</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">        <span class="comment">//处理结果，从rs中获取结果，rs是一个指向结果集合的指针</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;book_id&quot;</span>);<span class="comment">//这里的名字是查询语句范围的列名，即如果取了别名就用别名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_author&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;book_price&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;book_stock&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_desc&quot;</span>);</span><br><span class="line">            book = <span class="keyword">new</span> <span class="title class_">Book</span>(id,name,author,price,stock,desc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连结,结果集也需要关闭</span></span><br><span class="line">        DBHelper.closeConnection(rs,statement,connection);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="7-3-封装多条查询数据"><a href="#7-3-封装多条查询数据" class="headerlink" title="7.3 封装多条查询数据"></a>7.3 封装多条查询数据</h3><blockquote>
<p>把结果放在List里,如:List<Book></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">queryBook</span><span class="params">(<span class="type">int</span> bid)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBHelper.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from books where book_id=&quot;</span>+bid;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="comment">//通过executeQuery执行sql查询语句</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">        <span class="comment">//处理结果，从rs中获取结果，rs是一个指向结果集合的指针</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;book_id&quot;</span>);<span class="comment">//这里的名字是查询语句范围的列名，即如果取了别名就用别名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_author&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;book_price&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;book_stock&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;book_desc&quot;</span>);</span><br><span class="line">            <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(id,name,author,price,stock,desc);</span><br><span class="line">          list.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连结,结果集也需要关闭</span></span><br><span class="line">        DBHelper.closeConnection(rs,statement,connection);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-4-实体类参数传递"><a href="#7-4-实体类参数传递" class="headerlink" title="7.4 实体类参数传递"></a>7.4 实体类参数传递</h3><h4 id="7-4-1-添加操作"><a href="#7-4-1-添加操作" class="headerlink" title="7.4.1 添加操作"></a>7.4.1 添加操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBHelper.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>,book.getBookName());</span><br><span class="line">        statement.setString(<span class="number">2</span>,book.getBookAuthor());</span><br><span class="line">        statement.setDouble(<span class="number">3</span>,book.getBookPrice());</span><br><span class="line">        statement.setInt(<span class="number">4</span>,book.getBookStock());</span><br><span class="line">        statement.setString(<span class="number">5</span>,book.getBookDesc());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate();</span><br><span class="line">        DBHelper.closeConnection(statement,connection);</span><br><span class="line">        flag =i&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="7-5-DAO封装"><a href="#7-5-DAO封装" class="headerlink" title="7.5 DAO封装"></a>7.5 DAO封装</h3><blockquote>
<p>我们将数据库同一张表JDBC操作方法封装到一个类中,这个类就是访问此数据表的入口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDAO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBHelper.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>,book.getBookName());</span><br><span class="line">        statement.setString(<span class="number">2</span>,book.getBookAuthor());</span><br><span class="line">        statement.setDouble(<span class="number">3</span>,book.getBookPrice());</span><br><span class="line">        statement.setInt(<span class="number">4</span>,book.getBookStock());</span><br><span class="line">        statement.setString(<span class="number">5</span>,book.getBookDesc());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate();</span><br><span class="line">        DBHelper.closeConnection(statement,connection);</span><br><span class="line">        flag =i&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-6-DAO类中代码优化"><a href="#7-6-DAO类中代码优化" class="headerlink" title="7.6 DAO类中代码优化"></a>7.6 DAO类中代码优化</h3><blockquote>
<ol>
<li>应用程序开发中,如果代码抛出异常且自己可以处理,则通过try&#x2F;catch处理,别throw</li>
<li>JDBC操作方法的连接需要放在finally里关闭,否则出现异常时连接不会被关闭 </li>
<li>将数据库连接Connection、Statement、ResultMap等需要关闭的数据库对象放在try之前</li>
<li>因为所有JDBC操作都要Connection、Statement对象,查询方法都要ResultSet,因此在DAO中可以将这些<br>对象定义成类的成员变量</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDAO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Statement statement;</span><br><span class="line">    <span class="keyword">private</span> ResultSet resultSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DBHelper.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">            statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setString(<span class="number">1</span>,book.getBookName());</span><br><span class="line">            statement.setString(<span class="number">2</span>,book.getBookAuthor());</span><br><span class="line">            statement.setDouble(<span class="number">3</span>,book.getBookPrice());</span><br><span class="line">            statement.setInt(<span class="number">4</span>,book.getBookStock());</span><br><span class="line">            statement.setString(<span class="number">5</span>,book.getBookDesc());</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate();</span><br><span class="line">            flag =i&gt;<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBHelper.closeConnection(statement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="八、JDBC综合案例"><a href="#八、JDBC综合案例" class="headerlink" title="八、JDBC综合案例"></a>八、<strong>JDBC综合案例</strong></h2><hr>
<h3 id="8-1-JDBC数据库编程步骤"><a href="#8-1-JDBC数据库编程步骤" class="headerlink" title="8.1 JDBC数据库编程步骤"></a>8.1 JDBC数据库编程步骤</h3><ul>
<li>创建数据表: i_students</li>
<li>创建Java项目</li>
<li>创建JDBC工具类:DBHelper</li>
<li>创建DTO类(用于封装参数及查询结果)</li>
<li>创建DAO类(用于完成CRUD操作)</li>
</ul>
<h3 id="8-2-创建JDBC工具类"><a href="#8-2-创建JDBC工具类" class="headerlink" title="8.2 创建JDBC工具类"></a>8.2 创建JDBC工具类</h3><ul>
<li>在src下创建package: com.WL.jdbc.utils</li>
<li>在包中创建工具类: DBHelper</li>
<li>编写工具类<ul>
<li>添加驱动jar文件<ol>
<li>项目根目录下新建目录directory名:lib</li>
<li>复制从maven下载好的connecterJ的驱动到lib下</li>
<li>右键jar文件,选择最后一个:add as library</li>
</ol>
</li>
<li>编写DBHelper代码<ol>
<li>定义数据库连接信息</li>
<li>静态初始化块注册驱动</li>
<li>创建数据库连接方法</li>
<li>关闭连接方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBHelper</span> &#123;</span><br><span class="line">    <span class="comment">//1 声明常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="comment">//2 静态快初始化驱动</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 创建数据库连结</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DriverManager.getConnection(URL,USERNAME,PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4 关闭连结</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">(ResultSet resultSet, Statement statement,Connection connection)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(resultSet != <span class="literal">null</span> &amp;&amp; !resultSet.isClosed()) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(statement != <span class="literal">null</span> &amp;&amp; !statement.isClosed()) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed()) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="8-3-创建DTO类"><a href="#8-3-创建DTO类" class="headerlink" title="8.3 创建DTO类"></a>8.3 创建DTO类</h3><ul>
<li>新建dto包</li>
<li>包中创建数据表对应的实体类: Student<ol>
<li>声明字段,和数据表对应</li>
<li>提供set &#x2F; get</li>
<li>提供有参数和无参数构造器</li>
<li>提供toString方法</li>
</ol>
</li>
</ul>
<h3 id="8-4-创建DAO类"><a href="#8-4-创建DAO类" class="headerlink" title="8.4 创建DAO类"></a>8.4 创建DAO类</h3><blockquote>
<p>创建DAO类完成JDBC操作</p>
</blockquote>
<ul>
<li>创建package :dao</li>
<li>在包中创建类: StudentDAO (想对students表做什么操作,就在student表写什么样的方法)</li>
<li>创建 插入,查询方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDAO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Statement statement;</span><br><span class="line">    <span class="keyword">private</span> PreparedStatement preparedStatement;</span><br><span class="line">    <span class="keyword">private</span> ResultSet resultSet;</span><br><span class="line">    <span class="comment">//添加学生信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertStudent</span><span class="params">(Student student)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DBHelper.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into students(stu_num,stu_name,stu_gender,stu_age) values(?,?,?,?)&quot;</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>,student.getStuNum());</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>,student.getStuName());</span><br><span class="line">            preparedStatement.setString(<span class="number">3</span>,student.getStuGender());</span><br><span class="line">            preparedStatement.setInt(<span class="number">4</span>,student.getStuAge());</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line">            flag = i&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBHelper.closeConnection(<span class="literal">null</span>,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据学号，查询一个学生记录</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">queryStudent</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DBHelper.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select stu_num,stu_name,stu_gender,stu_age from students where stu_num = ?&quot;</span>;</span><br><span class="line">            preparedStatement =  connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>,num);</span><br><span class="line">            resultSet = preparedStatement.executeQuery();</span><br><span class="line">            <span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">stuNum</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;stu_num&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">stuName</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;stu_Name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">stuGender</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;stu_gender&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">stuAge</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;stu_age&quot;</span>);</span><br><span class="line">                student = <span class="keyword">new</span> <span class="title class_">Student</span>(stuNum,stuName,stuGender,stuAge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBHelper.closeConnection(resultSet,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询多个学生信息</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">listStudents</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Student&gt; studentsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DBHelper.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select stu_num,stu_name,stu_gender,stu_age from students&quot;</span>;</span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line">            resultSet = statement.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">stuNum</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;stu_num&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">stuName</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;stu_Name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">stuGender</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;stu_gender&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">stuAge</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;stu_age&quot;</span>);</span><br><span class="line">                <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(stuNum,stuName,stuGender,stuAge);</span><br><span class="line">                studentsList.add(student);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBHelper.closeConnection(resultSet,statement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> studentsList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="8-5测试DAO方法"><a href="#8-5测试DAO方法" class="headerlink" title="8.5测试DAO方法"></a>8.5测试DAO方法</h3><blockquote>
<p>使用junit对DAO中创建的方法进行测试</p>
</blockquote>
<h4 id="8-5-1-下载导入junit依赖"><a href="#8-5-1-下载导入junit依赖" class="headerlink" title="8.5.1 下载导入junit依赖"></a>8.5.1 下载导入junit依赖</h4><ul>
<li>从maven repository下载jar包 <ul>
<li>junit 4.12</li>
<li>hamcrest-core-1.3(如果junit时4.0+版本)</li>
</ul>
</li>
<li>copy到lib文件夹下</li>
<li>右键 add as library</li>
</ul>
<h4 id="8-5-2-创建单元测试类"><a href="#8-5-2-创建单元测试类" class="headerlink" title="8.5.2 创建单元测试类"></a>8.5.2 创建单元测试类</h4><blockquote>
<p>如果我们需要对某个类中的方法进行单元测试,我们需要创建这个类的测试类</p>
<p>StudentDAO ——-&gt; StudentDAOTest </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDAOTest</span> &#123;</span><br><span class="line">    <span class="comment">//1.定义成员变量：被测试类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">StudentDAO</span> <span class="variable">studentDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentDAO</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 创建测试方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;1008&quot;</span>,<span class="string">&quot;狗&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        flag = studentDAO.insertStudent(student);</span><br><span class="line">        <span class="comment">//断言</span></span><br><span class="line">        assertTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">snum</span> <span class="operator">=</span> <span class="string">&quot;1008&quot;</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentDAO.queryStudent(snum);</span><br><span class="line">        assertEquals(<span class="string">&quot;狗&quot;</span>,student.getStuName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListStudents</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = studentDAO.listStudents();</span><br><span class="line">        assertEquals(<span class="number">7</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="九、JDBC事务管理"><a href="#九、JDBC事务管理" class="headerlink" title="九、JDBC事务管理"></a>九、JDBC事务管理</h2><hr>
<h3 id="9-1-JDBC实现借书操作"><a href="#9-1-JDBC实现借书操作" class="headerlink" title="9.1 JDBC实现借书操作"></a>9.1 JDBC实现借书操作</h3><blockquote>
<ol>
<li>向records添加借书记录</li>
<li>修改books表中的库存</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDAO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">borrowBook</span><span class="params">(String stuNum,<span class="type">int</span> bookId, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 1. 向records添加借书记录</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBHelper.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;insert into records(snum,bid,borrow_num,is_return,borrow_date)&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;values(?,?,?,0,sysdate())&quot;</span>;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql1);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>,stuNum);</span><br><span class="line">            preparedStatement.setInt(<span class="number">2</span>,bookId);</span><br><span class="line">            preparedStatement.setInt(<span class="number">3</span>,num);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> preparedStatement.executeUpdate();<span class="comment">//自动提交</span></span><br><span class="line">            <span class="comment">// 2. 修改books表中的库存</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection1</span> <span class="operator">=</span> DBHelper.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update books set book_stock=book_stock-? where book_id=?&quot;</span>;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">preparedStatement1</span> <span class="operator">=</span> connection1.prepareStatement(sql2);</span><br><span class="line">            preparedStatement1.setInt(<span class="number">1</span>,num);</span><br><span class="line">            preparedStatement1.setInt(<span class="number">2</span>,bookId);</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">            flag = i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>:</p>
<ul>
<li>借书业务由两个数据库操作完成,这两个数据库操作要么同时成功,要么同时失败,构成一个数据库事务</li>
<li>JDBC的DML操作默认自动提交,因此添加借书记录操作完成之后,无论修改库存是否成功,借书记录都会添加到数据库</li>
<li>JDBC改如何做事务管理呢</li>
</ul>
<h3 id="9-2-JDBC事务管理"><a href="#9-2-JDBC事务管理" class="headerlink" title="9.2 JDBC事务管理"></a>9.2 JDBC事务管理</h3><hr>
<blockquote>
<ol>
<li>一个是事务中的多个DML操作需要基于同一个数据库连接</li>
<li>创建连接后,设置事务为手动提交–关闭自动提交</li>
<li>当所有事务的所有DML操作完成后手动提交</li>
<li>当事务的任何DML步骤出现异常,在catch代码块中执行事务回滚</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDAO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">borrowBook</span><span class="params">(String stuNum,<span class="type">int</span> bookId, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 1. 向records添加借书记录</span></span><br><span class="line">            <span class="comment">//关闭自动提交</span></span><br><span class="line">            connection = DBHelper.getConnection();</span><br><span class="line">            connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;insert into records(snum,bid,borrow_num,is_return,borrow_date)&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;values(?,?,?,0,sysdate())&quot;</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql1);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>,stuNum);</span><br><span class="line">            preparedStatement.setInt(<span class="number">2</span>,bookId);</span><br><span class="line">            preparedStatement.setInt(<span class="number">3</span>,num);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line">            <span class="comment">// 2. 修改books表中的库存</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update books set book_stock=book_stock-? where book_id=?&quot;</span>;</span><br><span class="line">            preparedStatement1 = connection.prepareStatement(sql2);</span><br><span class="line">            preparedStatement1.setInt(<span class="number">1</span>,num);</span><br><span class="line">            preparedStatement1.setInt(<span class="number">2</span>,bookId);</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> preparedStatement1.executeUpdate();</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">            flag = i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//一旦事务提交异常就执行回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBHelper.closeConnection(<span class="literal">null</span>,preparedStatement,<span class="literal">null</span>);</span><br><span class="line">            DBHelper.closeConnection(<span class="literal">null</span>,preparedStatement1,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="9-3-基于Service层的事务管理"><a href="#9-3-基于Service层的事务管理" class="headerlink" title="9.3 基于Service层的事务管理"></a>9.3 基于Service层的事务管理</h3><blockquote>
<p>DAO只负责数据库的操作,业务由service进行管理</p>
</blockquote>
<h4 id="9-3-1-Service分层介绍"><a href="#9-3-1-Service分层介绍" class="headerlink" title="9.3.1 Service分层介绍"></a>9.3.1 Service分层介绍</h4><blockquote>
<ul>
<li>DAO负责特定的数据库操作</li>
<li>service进行业务处理,Service业务处理过程中调用DAO数据库操作</li>
</ul>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-07 at 22.53.59.png" alt="Screen Shot 2022-04-07 at 22.53.59" style="zoom:50%;" /></h3><h4 id="9-3-2-service分层实现"><a href="#9-3-2-service分层实现" class="headerlink" title="9.3.2 service分层实现"></a>9.3.2 service分层实现</h4><ul>
<li>RecordDAO</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加借书记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertRecord</span><span class="params">(String snum, <span class="type">int</span> bid, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DBHelper.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into records(snum,bid,borrow_num,is_return,borrow_date)&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;values(?,?,?,0,sysdate())&quot;</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>,snum);</span><br><span class="line">            preparedStatement.setInt(<span class="number">2</span>,bid);</span><br><span class="line">            preparedStatement.setInt(<span class="number">3</span>,num);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line">            flag = i&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBHelper.closeConnection(<span class="literal">null</span>,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BookDAO</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改库存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateStock</span><span class="params">(<span class="type">int</span> bid,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DBHelper.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update books set book_stock=book_stock-? where book_id=?&quot;</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setInt(<span class="number">1</span>, num);</span><br><span class="line">            preparedStatement.setInt(<span class="number">2</span>, bid);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line">            flag = i&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBHelper.closeConnection(<span class="literal">null</span>,preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建service包,在包下创建bookService类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecordDAO</span> <span class="variable">recordDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecordDAO</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDAO</span> <span class="variable">bookDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDAO</span>();</span><br><span class="line">    <span class="comment">//图书管理业务类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">borrowBook</span><span class="params">(String stuNum, <span class="type">int</span> bookId, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="comment">//1 添加借书记录</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> recordDAO.insertRecord(stuNum,bookId,num);</span><br><span class="line">        <span class="comment">//2 修改图书库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> bookDAO.updateStock(bookId,num);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> b1 &amp;&amp; b2;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>: 测试时用的学号一定要在books所关联的学生表中存在,否则会报错.</p>
<h4 id="9-3-3-service层事务管理"><a href="#9-3-3-service层事务管理" class="headerlink" title="9.3.3 service层事务管理"></a>9.3.3 service层事务管理</h4><blockquote>
<p>service层中多个数据库DML操作是相互独立的,为保证所有操作同时成功或失败:<br>需要保证以下条件:</p>
<ul>
<li>多个DML操作必须使用同一个数据库连接</li>
<li>第一个DML操作之前关闭自动提交</li>
<li>所有操作完成后才能提交事务</li>
<li>执行出现异常就rollback</li>
</ul>
</blockquote>
<ul>
<li><p><strong>如何让service事务中多个DML操作使用同一个数据库连接</strong></p>
<ol>
<li>在service中获取连接对象,将连接对象传递到DAO中(企业开发中相对较少)</li>
</ol>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-08 at 17.29.33.png" alt="Screen Shot 2022-04-08 at 17.29.33" style="zoom:50%;" /></li>
</ul>
<p><strong>分析:</strong> DAO类对象需要通过service传递进来,这种传递本身无可厚非,但是当我们通过面向接口开发时(为了能灵活的定义实现类)<br>        容易造成接口的冗余—接口污染</p>
<ul>
<li>&#x3D;&#x3D;<strong>使用ThreadLocal容器,实现多个DML操作使用相同的连接</strong>&#x3D;&#x3D;</li>
</ul>
<img src="/Users/lei/Desktop/Typora笔记/图片/Screen Shot 2022-04-08 at 22.26.14.png" alt="Screen Shot 2022-04-08 at 22.26.14" style="zoom:50%;" />



<ul>
<li>方式一:自己声明container</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DBHelper中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//从容器中获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> container.size()&gt;<span class="number">0</span>?container.get(<span class="number">0</span>):<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(connection == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果容器中没有连接就创建连接</span></span><br><span class="line">                connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">                <span class="comment">//将连接假如到容器中</span></span><br><span class="line">                container.add(connection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//borrowService中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecordDAO</span> <span class="variable">recordDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecordDAO</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDAO</span> <span class="variable">bookDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDAO</span>();</span><br><span class="line">    <span class="comment">//图书管理业务类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">borrowBook</span><span class="params">(String stuNum, <span class="type">int</span> bookId, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBHelper.getConnection();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//1 添加借书记录</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> recordDAO.insertRecord(stuNum,bookId,num);</span><br><span class="line">            <span class="comment">//2 修改图书库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> bookDAO.updateStock(bookId,num);</span><br><span class="line">            flag = b1 &amp;&amp; b2;</span><br><span class="line">            <span class="comment">//3 提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBHelper.closeConnection(<span class="literal">null</span>,<span class="literal">null</span>,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>存储connection的容器可以使用list集合,但在多线程并发编程中会出现资源竞争问题,多个并发线程使用同一个数据库连接对象<br>而我们的要求只是同一个事务使用同一个连接,而非多个线程共享连接. </p>
<p>为了解决并发编程连接共享问题,我们使用ThreadLocal对象作为数据库连接对象的容器(threadlocal内部维护了一个map集合)<br>不同线程获取的是不同连接,同一个线程多次获取的是同一个连接</p>
</blockquote>
<ul>
<li>方式二 ThreadLocal</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;YES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;() ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 静态快初始化驱动</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 创建数据库连结</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//从容器中获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> local.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(connection == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果容器中没有连接就创建连接</span></span><br><span class="line">                connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">                <span class="comment">//将连接假如到容器中</span></span><br><span class="line">                local.set(connection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-4-ThreadLocal下的关闭连接"><a href="#9-4-ThreadLocal下的关闭连接" class="headerlink" title="9.4 ThreadLocal下的关闭连接"></a>9.4 ThreadLocal下的关闭连接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取当前数据库使用连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> local.get();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed())&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将关闭后的connection从容器中移除</span></span><br><span class="line">                local.remove();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>:</p>
<ol>
<li>DAO中的方法关闭时就不需要关闭connection了,可以重写方法,也可以把DAO关闭的connection赋null</li>
<li>colseConnection中别忘了最后把connection从local中移除</li>
</ol>
<h2 id="十、数据库连接池"><a href="#十、数据库连接池" class="headerlink" title="十、数据库连接池"></a>十、数据库连接池</h2><hr>
<h3 id="10-1-什么是数据库连接池"><a href="#10-1-什么是数据库连接池" class="headerlink" title="10.1 什么是数据库连接池"></a>10.1 什么是数据库连接池</h3><blockquote>
<p>如果每个JDBC操作都需要数据库连接且重新创建,用完后都销毁,JVM会因频繁的创建、销毁连接而占<br>用额外的系统资源.</p>
<p>数据库连接本质上是可被重用的资源(当一个JDBC操作完成后,其创建的连接可被其他JDBC操作使用)</p>
<ul>
<li><p>基于这个特性,可以创建一个存放数据库连接的容器(连接池),数据库连接池是有最大容量的,当进行<br>JDBC操作时,不用创建连接,直接从这个容器中获取连接</p>
<ul>
<li><p>如果容器中没有数据库连接,或没有空闲的数据库连接,则创建新的数据库连接存入连接池并给<br>这个操作使用,使用完成后无需关闭连接,直接归还到这个容器中即可</p>
</li>
<li><p>如果容器中有空闲连接,则无需创建新连接,直接从容器中获取连接并使用</p>
</li>
<li><p>如果容器中没有空闲的连接,且连接池数量已经达最大值,当前操作就会等待.等待连接池某个连<br>接被归还,归还后再使用</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>连接池:存放数据库连接对象的容器</strong></p>
<p><strong>连接池作用: 对数据库连接进行管理,减少因重复创建、销毁数据库连接导致的系统开销</strong></p>
<h3 id="10-2-常用的连接池"><a href="#10-2-常用的连接池" class="headerlink" title="10.2 常用的连接池"></a>10.2 常用的连接池</h3><blockquote>
<p>我们可以编程实现: 创建一个数组、集合来存放数据库连接</p>
<p>目前市面上已有多种数据库连接池,我们只需引用</p>
</blockquote>
<table>
<thead>
<tr>
<th>功能</th>
<th>dpcp</th>
<th>druid</th>
<th>c3p0</th>
<th>HikariCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否支持PSCache</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>监控</td>
<td>jmx</td>
<td>jmx&#x2F;log&#x2F;http</td>
<td>jmx,log</td>
<td>jmx</td>
</tr>
<tr>
<td>扩展性</td>
<td>弱</td>
<td>好</td>
<td>弱</td>
<td>弱</td>
</tr>
<tr>
<td>SQL拦截及解析</td>
<td>无</td>
<td>支持</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>代码</td>
<td>简单</td>
<td>中等</td>
<td>复杂</td>
<td>简单</td>
</tr>
<tr>
<td>特点</td>
<td>依赖于common-pool</td>
<td>开源,全面</td>
<td>历史久远,逻辑复杂,不易维护</td>
<td>功能简单,起源于BoneCP</td>
</tr>
<tr>
<td>连接池管理</td>
<td>LinkedBlockingDeque</td>
<td>数组</td>
<td></td>
<td>ThreadLocal</td>
</tr>
</tbody></table>
<ul>
<li>Druid是目前使用最广泛的</li>
<li>Hikari在SpringBoot中默认集成,性能诸多竞品中最好的</li>
</ul>
<h3 id="10-3-使用数据库连接池"><a href="#10-3-使用数据库连接池" class="headerlink" title="10.3 使用数据库连接池"></a>10.3 使用数据库连接池</h3><h4 id="10-3-1-创建java应用"><a href="#10-3-1-创建java应用" class="headerlink" title="10.3.1 创建java应用"></a>10.3.1 创建java应用</h4><h4 id="10-3-2-创建连接池属性配置文件"><a href="#10-3-2-创建连接池属性配置文件" class="headerlink" title="10.3.2 创建连接池属性配置文件"></a>10.3.2 创建连接池属性配置文件</h4><ol>
<li>src下创建package : com.WL.jdbc.utils</li>
<li>在包中创建druid.properties文件</li>
<li>创建lib,导入mysql包</li>
<li>配置druid连接池属性</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据库连接信息</span></span><br><span class="line"><span class="attr">driverClassName</span> = <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">password</span> = <span class="string">YES</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#连接池属性</span></span><br><span class="line"><span class="attr">initialSize</span> = <span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span> = <span class="string">50</span></span><br><span class="line"><span class="attr">minIdle</span> = <span class="string">5</span></span><br><span class="line"><span class="attr">maxWait</span> = <span class="string">30000</span></span><br></pre></td></tr></table></figure>



<h4 id="10-3-3-创建连接池工具类"><a href="#10-3-3-创建连接池工具类" class="headerlink" title="10.3.3 创建连接池工具类"></a>10.3.3 创建连接池工具类</h4><ol>
<li>下载并导入druid的jar文件</li>
<li>创建DruidUtils工具类(工具类与属性文件druid.properties在同一目录下)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 定义DruidDataSource对象，就表示数据库连接池(数据源类）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DruidDataSource druidDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 静态代码块，初始化DruidDataSource对象</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取druid.properties文件中配置的属性</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidUtils.class.getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(is);</span><br><span class="line">            <span class="comment">//使用属性文件初始化druidDataSource</span></span><br><span class="line">            druidDataSource =(DruidDataSource)DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建静态方法，从连接池获取连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = druidDataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="十一、通用JDBC操作封装"><a href="#十一、通用JDBC操作封装" class="headerlink" title="十一、通用JDBC操作封装"></a>十一、通用JDBC操作封装</h2><hr>
<blockquote>
<p>在DAO层JDBC操作中,对数据表的增删改查操作存在代码的冗余,我们可以对其公共部分进行封装<br>实现代码复用</p>
</blockquote>
<h3 id="11-1-DML操作封装"><a href="#11-1-DML操作封装" class="headerlink" title="11.1 DML操作封装"></a>11.1 DML操作封装</h3><blockquote>
<p>对于数据库DML操作:</p>
<ul>
<li>参数不同</li>
<li>SQL不同</li>
<li>SQL参数赋值不同</li>
</ul>
</blockquote>
<ul>
<li>通用的DML操作方法<ol>
<li>在utils包中创建CommonDAO类</li>
<li>在类中创建update方法</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(String sql,Object... args)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DruidUtils.getConnection();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">                preparedStatement.setObject(i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line">            flag=i&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="11-2-DQL操作封装"><a href="#11-2-DQL操作封装" class="headerlink" title="11.2 DQL操作封装"></a>11.2 DQL操作封装</h3><ul>
<li>通用的DQL操作方法<br>注:<ol>
<li>Object… args表示范型参数,随意参数类型和个数</li>
<li>此查询公用方法可以用于查询不同的实体类,则不同实体类返回的参数不同,为了解决这一问题,使用类范型解决问题<br>在类CommonDAO后面加上<T>表示范型,即在声明此类的对象时必须指定一个类型,来限定查询操作返回的参数类型</li>
<li>由于方法返回的是一个范型集合,因此RowMapper中的getRow方法也必须返回一个与之对应的对象</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonDAO</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">//注意1</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">query</span><span class="params">(String sql,RowMapper&lt;T&gt; rowMapper,Object... args)</span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DruidUtils.getConnection();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">                preparedStatement.setObject(i+<span class="number">1</span>,args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">                <span class="comment">//从查询结果中取出值，封装到实体类中</span></span><br><span class="line">                <span class="comment">//getRow就是方法调用者在调用方法时，传递进来的用于映射查询结果的方法</span></span><br><span class="line">              <span class="comment">//注意3</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> rowMapper.getRow(resultSet);</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RowMapper接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RowMapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getRow</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="11-3-基于通用JDBC操作案例"><a href="#11-3-基于通用JDBC操作案例" class="headerlink" title="11.3 基于通用JDBC操作案例"></a>11.3 基于通用JDBC操作案例</h3><blockquote>
<p>对图书信息进行JDBC操作</p>
<ul>
<li>创建图书实体类Book(相当于BookDTO)</li>
<li>创建BookDAO</li>
<li></li>
</ul>
</blockquote>
<h4 id="11-3-1-创建实体类"><a href="#11-3-1-创建实体类" class="headerlink" title="11.3.1 创建实体类"></a>11.3.1 创建实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bookId;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> String bookAuthor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bookPrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bookStock;</span><br><span class="line">    <span class="keyword">private</span> String bookDesc;</span><br><span class="line">  <span class="comment">//无参构造器</span></span><br><span class="line">  <span class="comment">//有参构造器</span></span><br><span class="line">  <span class="comment">//toString</span></span><br><span class="line">  <span class="comment">//get和set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-3-2-创建DAO"><a href="#11-3-2-创建DAO" class="headerlink" title="11.3.2 创建DAO"></a>11.3.2 创建DAO</h4><blockquote>
<p>DAO中的操作都是调用CommonDAO实现的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDAO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CommonDAO&lt;Book&gt; commonDAO = <span class="keyword">new</span> <span class="title class_">CommonDAO</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertBook</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert books(book_name,book_Author,book_price,book_stock,book_desc) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> commonDAO.update(sql,</span><br><span class="line">                   book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc());</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteBook</span><span class="params">(<span class="type">int</span> bookId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot; delete from books where book_id = ?&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> commonDAO.update(sql, bookId);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> commonDAO.update(sql, book.getBookName(),</span><br><span class="line">                book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc(),book.getBookId());</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">queryBook</span><span class="params">(<span class="type">int</span> bookId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from books where book_id = ?&quot;</span>;</span><br><span class="line">        RowMapper&lt;Book&gt; rowMapper= <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Book <span class="title function_">getRow</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">book_id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;book_id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">book_name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">book_author</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_author&quot;</span>);</span><br><span class="line">                <span class="type">double</span> <span class="variable">book_price</span> <span class="operator">=</span> resultSet.getDouble(<span class="string">&quot;book_price&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">book_stock</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;book_stock&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">book_desc</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_desc&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Book</span>(book_id,book_name,book_author,book_price,book_stock,book_desc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Book&gt; list = commonDAO.query(sql,rowMapper,bookId);</span><br><span class="line">        <span class="keyword">return</span> list.size()&gt;<span class="number">0</span>?list.get(<span class="number">0</span>):<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">listBooks</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from books&quot;</span>;</span><br><span class="line">        <span class="comment">//这里用lambda表达式来插入RowMapper</span></span><br><span class="line">        List&lt;Book&gt; list = commonDAO.query(sql,resultSet -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">book_id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;book_id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">book_name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">book_author</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_author&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">book_price</span> <span class="operator">=</span> resultSet.getDouble(<span class="string">&quot;book_price&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">book_stock</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;book_stock&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">book_desc</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_desc&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Book</span>(book_id,book_name,book_author,book_price,book_stock,book_desc);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="十二、Apache-DBUtils"><a href="#十二、Apache-DBUtils" class="headerlink" title="十二、Apache DBUtils"></a>十二、Apache DBUtils</h2><hr>
<h3 id="12-1-DBUtils介绍"><a href="#12-1-DBUtils介绍" class="headerlink" title="12.1 DBUtils介绍"></a>12.1 DBUtils介绍</h3><blockquote>
<p>Commons Utils 是Apache 组织提供的一个针对JDBC进行简单封装的开源工具类库,使用DBUtils可以极大简化<br>JDBC应用程序开发,同时不会影响数据库的性能.</p>
</blockquote>
<blockquote>
<p>DBUtils是java编程中数据库访问的轻巧,实用的工具类库</p>
<ul>
<li>提供对数据表通用的DML操作</li>
<li>提供对数据表通用的DQL操作(可以把结果封装成对象,集合等类型)</li>
</ul>
</blockquote>
<blockquote>
<p>DBUtils中的核心类:</p>
<ul>
<li>QueryRunner, 用于执行SQL指令(相当于我们自己封装的CommonDAO类)<ul>
<li>update( )用于执行,DML指令</li>
<li>query( ) 用于执行DQL指令</li>
</ul>
</li>
<li>ResultSetHandler接口,结果集处理,相当于我们自己封装的RowMapper接口<ul>
<li>BeanHandler实现类,当查询语句返回一条结果时,它将结果转换成一个对象</li>
<li>BeanListHandler实现类,当查询语句返回多条结果时,它将结果转换成一个集合</li>
<li>ScalarHandler实现类,当查询语句返回一个值时,它将结果转换为java变量</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="12-2-DBUtils使用准备"><a href="#12-2-DBUtils使用准备" class="headerlink" title="12.2 DBUtils使用准备"></a>12.2 DBUtils使用准备</h3><ol>
<li><p>新建java工程</p>
</li>
<li><p>添加依赖</p>
<ul>
<li>mysql驱动jar</li>
<li>dbutils的jar </li>
<li>druid(Apache DNUtils简历数据库连接是依赖数据源(连接池)的)的jar</li>
</ul>
</li>
<li><p>配置Druid属性文件</p>
<ul>
<li><p>src下创建utils包</p>
</li>
<li><p>包内创建druid.properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据库连接信息</span></span><br><span class="line"><span class="attr">driverClassName</span> = <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">jdbc:mysql://localhost:3306/db_mybatis?characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">password</span> = <span class="string">YES</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#连接池属性</span></span><br><span class="line"><span class="attr">initialSize</span> = <span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span> = <span class="string">50</span></span><br><span class="line"><span class="attr">minIdle</span> = <span class="string">5</span></span><br><span class="line"><span class="attr">maxWait</span> = <span class="string">30000创建Druid连接池工具类</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建Druid连接池工具类</p>
<ul>
<li><p>在utils包创建DruidUtils工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DruidDataSource druidDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidUtils.class.getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(is);</span><br><span class="line"></span><br><span class="line">             druidDataSource  = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = druidDataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="12-3-DBUtils使用"><a href="#12-3-DBUtils使用" class="headerlink" title="12.3 DBUtils使用"></a>12.3 DBUtils使用</h3><blockquote>
<p>完成图书信息的数据库操作</p>
</blockquote>
<h4 id="12-3-1-添加操作"><a href="#12-3-1-添加操作" class="headerlink" title="12.3.1 添加操作"></a>12.3.1 添加操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDAO</span> &#123;</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertBook</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 编写sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot; insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">            <span class="comment">//2 准备参数</span></span><br><span class="line">            Object[] params =</span><br><span class="line">                    &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc()&#125;;</span><br><span class="line">            <span class="comment">//3 调用Commons-Utils中的QueryRunner执行sql</span></span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(DruidUtils.getDataSource());</span><br><span class="line">            <span class="comment">//基本上只用querryrunner的update和query两个</span></span><br><span class="line">            i = queryRunner.update(sql,params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-3-2-删除操作"><a href="#12-3-2-删除操作" class="headerlink" title="12.3.2 删除操作"></a>12.3.2 删除操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteBook</span><span class="params">(<span class="type">int</span> bookId)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from books where book_id = ?&quot;</span>;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(DruidUtils.getDataSource());</span><br><span class="line">            i = queryRunner.update(sql, bookId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>



<h4 id="12-3-3-修改操作"><a href="#12-3-3-修改操作" class="headerlink" title="12.3.3 修改操作"></a>12.3.3 修改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=?&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;where book_id=?&quot;</span>;</span><br><span class="line">            Object[] params = &#123; book.getBookName(),</span><br><span class="line">                    book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc(),book.getBookId()&#125;;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(DruidUtils.getDataSource());</span><br><span class="line">            i = queryRunner.update(sql,params);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-3-4-查询操作"><a href="#12-3-4-查询操作" class="headerlink" title="12.3.4 查询操作"></a>12.3.4 查询操作</h4><ul>
<li><p><strong>查询一条记录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案二</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">queryBook</span><span class="params">(<span class="type">int</span> bookId)</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select book_id bookId,book_name bookName,book_author bookAuthor,&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;book_price bookPrice,book_stock bookStock,book_desc bookDesc from books where book_id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(DruidUtils.getDataSource());</span><br><span class="line">            <span class="comment">//对于查询操作，我们需要通过queryRunner对象调用query方法执行</span></span><br><span class="line">            <span class="comment">//所有的query方法都需一个ResultSerHandler参数，通过此参数指定query方法返回类型</span></span><br><span class="line">            <span class="comment">//如果sql指令执行后返回一行结果，我们通过beanHandler指定查询结果 封装的实体类类型</span></span><br><span class="line">            <span class="comment">//要求查询结果集的字段名必须与指定的实体类属性名匹配！！</span></span><br><span class="line">            <span class="comment">//方案一：创建实体类时，实体类中属性名与数据表的列名相同（通常做不到）</span></span><br><span class="line">            <span class="comment">//方案二： 查询语句字段取别名，与实体类属性名一致</span></span><br><span class="line">          <span class="comment">//方案三:自定义结果处理</span></span><br><span class="line">          <span class="comment">//这里会调用无参构造器,注意</span></span><br><span class="line">            book = queryRunner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;Book&gt;(Book.class), bookId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//方案三</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">queryBook</span><span class="params">(<span class="type">int</span> bookId)</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from books where book_id = ?&quot;</span>;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(DruidUtils.getDataSource());</span><br><span class="line">            ResultSetHandler&lt;Book&gt; resultSetHandler = <span class="keyword">new</span> <span class="title class_">ResultSetHandler</span>&lt;Book&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Book <span class="title function_">handle</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">book_id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;book_id&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">book_name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_name&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">book_author</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_author&quot;</span>);</span><br><span class="line">                        <span class="type">double</span> <span class="variable">book_price</span> <span class="operator">=</span> resultSet.getDouble(<span class="string">&quot;book_price&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">book_stock</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;book_stock&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">book_desc</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;book_desc&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Book</span>(book_id,book_name,book_author,book_price,book_stock,book_desc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> book;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            book = queryRunner.query(sql, resultSetHandler, bookId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询多条记录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">listBooks</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Book&gt; booksList = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select book_id bookId,book_name bookName,book_author bookAuthor,&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;book_price bookPrice,book_stock bookStock,book_desc bookDesc from books&quot;</span>;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(DruidUtils.getDataSource());</span><br><span class="line">            <span class="comment">//如果sql返回多条记录，我们通过BeanListHandler&lt;&gt; 指定查询结果封装的实体类的集合类型</span></span><br><span class="line">            BeanListHandler&lt;Book&gt; beanListHandler = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;Book&gt;(Book.class);</span><br><span class="line">            booksList = queryRunner.query(sql, beanListHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> booksList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询返回一个值</strong></p>
<blockquote>
<p>例如在做分页时,需要查询数据的总记录数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(1) from books&quot;</span>;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(DruidUtils.getDataSource());</span><br><span class="line">            <span class="comment">//如果返回一个值，用ScalarHandler指定返回类型</span></span><br><span class="line">            <span class="comment">//queryRunner在处理统计函数时，是以long类型操作的，所以不能直接转Integer</span></span><br><span class="line">            <span class="comment">//如果我们确定值在int范围内，可以把long强转到int</span></span><br><span class="line">            <span class="comment">//但是建议直接把count定义成long</span></span><br><span class="line">            ScalarHandler&lt;Long&gt; scalarHandler = <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>&lt;&gt;();</span><br><span class="line">            <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> queryRunner.query(sql, scalarHandler);</span><br><span class="line">            count = (<span class="type">int</span>)l;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="MySQL进阶"><a href="#MySQL进阶" class="headerlink" title="MySQL进阶"></a>MySQL进阶</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h2 id="索引-6-7"><a href="#索引-6-7" class="headerlink" title="索引 6 7"></a>索引 6 7</h2><h2 id="sql执行方式-10"><a href="#sql执行方式-10" class="headerlink" title="sql执行方式 10"></a>sql执行方式 10</h2><h2 id="表的连接"><a href="#表的连接" class="headerlink" title="表的连接"></a>表的连接</h2>]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="基础排序"><a href="#基础排序" class="headerlink" title="基础排序"></a>基础排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p>思想：每次选择一个数组中最小的元素放在数组的前面。</p>
<p>实现：嵌套for循环，外层循环定义循环次数，内层循环找出最小的值，额外写一个swap方法实现数组的元素交换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;e &gt; <span class="number">0</span>; e--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; e; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    swap(arr, i, i+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//参见2.1.1 用异或交换两值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j )</span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote>
<p>虽然和冒泡排序和选择排序一样时间复杂度都是O（n^2），但是插入排序受数据质量影响，有时候会表现的更好</p>
<p>思想：从0–0有序到0–N有序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123; <span class="comment">// 0到i想要有序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="number">1</span>]; j--)&#123; <span class="comment">//每次和i相邻的元素开始比较</span></span><br><span class="line">                swap(arr, j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j )</span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="进阶排序"><a href="#进阶排序" class="headerlink" title="进阶排序"></a>进阶排序</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote>
<p>思想：利用递归分治的思想，要想arr整体有序，那么中点左侧和中点右侧都要有序，以此类推，而在递归过程中会调用merge方法使得此数组的小部分有序，而merge方法则是利用双指针法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       process(arr, left, mid);</span><br><span class="line">       process(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">       merge(arr, left, mid, right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">       <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">           help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">           help[i++] = arr[p1++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (p2 &lt;= right)&#123;</span><br><span class="line">           help[i++] = arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//注意是help.length</span></span><br><span class="line">       <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">           <span class="comment">//这一步很容易错</span></span><br><span class="line">           arr[left + i] = help[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并应用"><a href="#归并应用" class="headerlink" title="归并应用"></a>归并应用</h3><blockquote>
<p>归并排序的拓展：求小和问题、求逆序对个数</p>
<p>求小和：<br>一个数组中某一个元素的左边所有比它小的元素和就是这个元素的小和，求某一数组的小和？</p>
<p>思想：在归并排序的基础上实现：转换思路从左往右看，如果右边的数比左边的数小就会产生一个左边数的这样一个小和，在此基础上，如果左右若干数的小和已经求和完毕，那么就可可以排序，这样小和可以直接按索引个数计算。和归并的不同点是，如果左右指针相同那么必须先拷贝右边的元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arr既要排序又要求小和</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">( <span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( left == right)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> process(arr, left, middle)</span><br><span class="line">               + process(arr, middle + <span class="number">1</span>, right)</span><br><span class="line">               + merge(arr, left, middle, right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> middle, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">       <span class="type">int</span> help[] = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> middle + <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (p1 &lt;= middle &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">           res += arr[p1] &lt; arr[p2] ? (right - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">           help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (p1 &lt;= middle)&#123;</span><br><span class="line">           help[i++] = arr[p1++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (p2 &lt;= right)&#123;</span><br><span class="line">           help[i++] = arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">           arr[left + i] = help[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote>
<p>思想：</p>
<p>快排1.0版本：<br>取数组的最后一个数作为枢纽，然后将小于等于枢纽的数放数组的左半边，大于枢纽的数放右半边，最后将枢纽和右半边区域的第一个数做一个交换，然后将左边和右边分割，继续重复上述过程。</p>
<p>快排2.0版本：<br>和快排1.0的区别是，将等于枢纽的数放中间，将数组分割成3个部分</p>
<p>时间复杂度：最差O（n^2）<br>最差的情况是{1,2,3,4,5}每次都几乎没动，因此诞生了快排3.0版本</p>
<p>快排3.0版本：<br>随机选一个数作为枢纽，时间复杂度：O（N*logN）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//随机选一个位置和最右边的位置做交换</span></span><br><span class="line">            swap(arr, left + (<span class="type">int</span>)(Math.random() * (right - left +<span class="number">1</span>)), right);</span><br><span class="line">            <span class="type">int</span> p[] = partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回的是一个等于区域的左边界和右边界组成的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> left - <span class="number">1</span>;<span class="comment">//小于区边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> right;<span class="comment">//大于区边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[left] &lt; arr[right])&#123;</span><br><span class="line">                swap(arr, ++less, left++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &gt; arr[right])&#123;</span><br><span class="line">                swap(arr, --more, left);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, more, right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j )</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>堆结构：</p>
<p>堆是一个完全二叉树；<br>完全二叉树：<br>i的左子树：（2<em>i+1），i的右子树：（2</em>i+2），i的父节点：（（i-1）&#x2F;2）</p>
<p>堆分为大根堆和小根堆：<br>大根堆：任何一个节点是以这个节点为根节点的子树的最大值这样的堆<br>小根堆：任何一个节点是以这个节点为根节点的子树的最小值这样的堆</p>
</blockquote>
<ul>
<li><p>关于堆的常用算法：</p>
</li>
<li><p>算法一：将一个数组从0开始调整成大根堆或小根堆的算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>])&#123;</span><br><span class="line">          <span class="comment">//这里包含了一个逻辑，index只要大于0，那么其判断的终点之一就是index为0，不大于自己</span></span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法二：将已经是大根堆的数组的最大值去调之后调整剩下的数组使其仍然是一个大根堆（log（N））</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//heapSize:用来指代堆的有效长度，不一定是数组的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//左子树既可以来判断有无越界，又可以通过+1来获取右子树的值</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">            <span class="comment">//找出两个孩子中较大的那个，并把索引赋给largest</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">largetst</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">//比较左右孩子的最大值和index节点的值，并把大的那个的索引返回给largest</span></span><br><span class="line">            largetst = arr[largetst] &gt; arr[index] ? largetst : index;</span><br><span class="line">            <span class="comment">//此时largest代表的是待比较节点和左右孩子中最大的节点的索引，如果这个节点就是index，那就不同下沉</span></span><br><span class="line">            <span class="keyword">if</span>(largetst == index)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果largest不是index，那么需要将此时的子树根节点下沉</span></span><br><span class="line">            swap(arr, largetst, index);</span><br><span class="line">            <span class="comment">//索引下沉</span></span><br><span class="line">            index = largetst;</span><br><span class="line">            <span class="comment">//指针下沉，让while循环继续</span></span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>堆排序的整体思想：<br>调用算法一将一个数组从根的size&#x3D;&#x3D;0开始慢慢调整成大&#x2F;小根堆，调整好后将第一个元素与最后一个元素做交换，同时将堆的size–，然后执行算法二将堆调整成大&#x2F;小根堆，再继续执行交换操作即可得到一个排好序的数组。<br>当然，如果数据是一开始就准备好的，那么也可以在调整至大&#x2F;小根堆的时候从最后一个节点开始根堆调整操作</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for( int i = 0; i &lt; arr.length; i++)&#123; // 0(N)</span></span><br><span class="line"><span class="comment">//            heapInsert(arr, i); // O(logN)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//如果数据是一开始就已经有了，不用一个一个加那么可以直接从最后一个子树的根结点开始进行子树调整操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            heapify(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">        <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>)&#123; <span class="comment">// O(N)</span></span><br><span class="line">            heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// o(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//heapSize:用来指代堆的有效长度，不一定是数组的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//左子树既可以来判断有无越界，又可以通过+1来获取右子树的值</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">            <span class="comment">//找出两个孩子中较大的那个，并把索引赋给largest</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">largetst</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">//比较左右孩子的最大值和index节点的值，并把大的那个的索引返回给largest</span></span><br><span class="line">            largetst = arr[largetst] &gt; arr[index] ? largetst : index;</span><br><span class="line">            <span class="comment">//此时largest代表的是待比较节点和左右孩子中最大的节点的索引，如果这个节点就是index，那就不同下沉</span></span><br><span class="line">            <span class="keyword">if</span>(largetst == index)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果largest不是index，那么需要将此时的子树根节点下沉</span></span><br><span class="line">            swap(arr, largetst, index);</span><br><span class="line">            <span class="comment">//索引下沉</span></span><br><span class="line">            index = largetst;</span><br><span class="line">            <span class="comment">//指针下沉，让while循环继续</span></span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//这里有个小知识：-1/2在编程中仍为0</span></span><br><span class="line">        <span class="keyword">while</span>(arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>])&#123;<span class="comment">//这里包含了一个逻辑，index只要大于0，那么其判断的终点之一就是index为0，不大于自己</span></span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="堆排序扩展"><a href="#堆排序扩展" class="headerlink" title="堆排序扩展"></a>堆排序扩展</h3><blockquote>
<p>已知一个几乎有序的数组，几乎有序是指如果把数组排好序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说很小，请选择一个合适的算法对这个数组进行排序。</p>
<p>思想：假设k&#x3D;&#x3D;6，那么先将数组的前7个数拿出来调整成小根堆，由于几乎有序且k为6，所以0位置的那个数一定是数组的最小值，然后指针后移，将第八个数加入到堆并调整成小根堆，同理，又能找出剩下元素的最小值，以此类推。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heatSortDistanceLessK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//默认小根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//取出前k个数进小根堆，之所以与数组长度比较是因为害怕k的质量不行，比数组长度还大</span></span><br><span class="line">        <span class="keyword">for</span>(; index &lt; Math.min(arr.length, k); index++)&#123;</span><br><span class="line">            queue.add(arr[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//声明排序指针</span></span><br><span class="line">        <span class="keyword">for</span> (; index &lt; arr.length; i++, index++)&#123;</span><br><span class="line">            queue.add(arr[index]); <span class="comment">//继续将数组中的元素添加至小根堆</span></span><br><span class="line">            arr[i] = queue.poll(); <span class="comment">// 将小根堆的最小值弹出至数组的前端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一定是index到了数组尾而小根堆里还有数字，所以将小根堆的元素弹出</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            arr[i++] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h2 id="特殊排序"><a href="#特殊排序" class="headerlink" title="特殊排序"></a>特殊排序</h2><h3 id="桶排序（基数排序）"><a href="#桶排序（基数排序）" class="headerlink" title="桶排序（基数排序）"></a>桶排序（基数排序）</h3><blockquote>
<p>思想：找出数组中最大数并得到他的位数，然后准备10个桶，第一轮从个位开始比，先将元素按个位数投入到桶中，排序好后倒出，再按十位数重复上述操作，整个过程重复的轮数是最大数的位数。</p>
<p>实际的基数排序代码会对桶这个操作进行优化来模拟出桶的操作，准备一个0到10的数组，初始这个数组的每一个元素的含义是当前基数下个数字的词频，然后会将词频累加，即数组的当前元素与此元素之前的所有元素累加，这是为了模拟出桶的操作，接下来会从右到左遍历待排序数组，根据遍历到的元素的基数去基数词频数组里找，对应找到的元素减一就是该元素应该放的额外数组的位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> digit)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bucket[] = <span class="keyword">new</span> <span class="title class_">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>; d &lt;= digit; d++)&#123; <span class="comment">//有多少位就进出几次</span></span><br><span class="line">            <span class="comment">//词频数组</span></span><br><span class="line">            <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[radix];</span><br><span class="line">            <span class="keyword">for</span>(i = L; i &lt;= R; i++)&#123;</span><br><span class="line">                j = getDIgit(arr[i], d);</span><br><span class="line">                count[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; radix; i++)&#123;</span><br><span class="line">                count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = R; i&gt;=L; i--)&#123;</span><br><span class="line">                j = getDIgit(arr[i], d);</span><br><span class="line">                bucket[count[j] - <span class="number">1</span>] = arr[i];</span><br><span class="line">                count[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++)&#123;</span><br><span class="line">                arr[i] = bucket[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得某个数字的某位的数</span></span><br><span class="line">    <span class="comment">//math.pow返回某个数的几次方</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDIgit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((x / ((<span class="type">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>))) % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出数组中最大数字的位数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxbits</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            max = max &gt; arr[i] ? max : arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(max != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h3 id="按频率将数组升序排列"><a href="#按频率将数组升序排列" class="headerlink" title="按频率将数组升序排列"></a>按频率将数组升序排列</h3><blockquote>
<p>给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。<br>请你返回排序后的数组。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sort-array-by-increasing-frequency">https://leetcode.cn/problems/sort-array-by-increasing-frequency</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] frequencySort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">           map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">           list.add(num);</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.sort(list, (a, b) -&gt; &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> map.get(a), cnt2 = map.get(b);</span><br><span class="line">           <span class="keyword">return</span> cnt1 != cnt2 ? cnt1 - cnt2 : b - a;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           nums[i] = list.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ul>
<li>基于比较的排序暂时没找到时间复杂度在O（N*logN）以下的</li>
<li>空间复杂度在0（N）以下的稳定性都不行</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>选择</td>
<td>N^2</td>
<td>1</td>
<td>no</td>
</tr>
<tr>
<td>冒泡</td>
<td>N^2</td>
<td>1</td>
<td>yes</td>
</tr>
<tr>
<td>插入</td>
<td>N^2</td>
<td>1</td>
<td>yes</td>
</tr>
<tr>
<td>归并</td>
<td>N*logN</td>
<td>N</td>
<td>yes</td>
</tr>
<tr>
<td>快排</td>
<td>N*logN</td>
<td>logN</td>
<td>no</td>
</tr>
<tr>
<td>堆</td>
<td>N*logN</td>
<td>1</td>
<td>no</td>
</tr>
</tbody></table>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><hr>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="局部最小值问题"><a href="#局部最小值问题" class="headerlink" title="局部最小值问题"></a>局部最小值问题</h3><blockquote>
<p>在一个长度为n的无序数组中，相邻的数一定不相等</p>
<p>局部最小的定义：0位置的数若小于1位置的数，就是局部最小，n-1位置的数若小于n-2位置的数，n-1就是局部最小，若某个数位置为i，且比i-1和i+1位置的数都小，那i也是一个局部最小的数</p>
<p>问题：最快找到一个局部最小数？</p>
<p>分析：拿到数组首先单独判断数组的开头和结尾，因为如果开头和结尾都不是局部最小，那么整个数据必定存在局部最小的数，因为如果开头和结尾都不是局部最小数，这意味着arr[0] &gt; arr[1], arr[n-2] &lt; arr[n-1],可参考高数中罗尔定理，这个数组的元素值大小变化必定存在拐点。</p>
</blockquote>
<h3 id="两有序数组排序"><a href="#两有序数组排序" class="headerlink" title="两有序数组排序"></a>两有序数组排序</h3><blockquote>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p>LeetCode 4</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        二分法解题思路</span></span><br><span class="line"><span class="comment">        nums1 和nums2 的长度分别是m 和n</span></span><br><span class="line"><span class="comment">        当m + n 是奇数时，从下标来说，中位数是(m + n) / 2 </span></span><br><span class="line"><span class="comment">        当m + n 是偶数时，从下标来说，中位数是(m + n) / 2 和 (m + n) / 2 - 1</span></span><br><span class="line"><span class="comment">        所以问题就变成了寻找两个数组中第(m + n) / 2 小和(m + n) / 2 - 1小的数</span></span><br><span class="line"><span class="comment">        解题思想就变成了找到两个数组的第k小的数字</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">         <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex</span> <span class="operator">=</span> totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex1</span> <span class="operator">=</span> totalLength / <span class="number">2</span> - <span class="number">1</span>, midIndex2 = totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKthElement</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kthElement</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot1</span> <span class="operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="旋转数组最小数字"><a href="#旋转数组最小数字" class="headerlink" title="旋转数组最小数字"></a>旋转数组最小数字</h3><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。 </p>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>LeetCode 剑指offer 11</p>
</blockquote>
<p>mid的值有以下三种情况</p>
<ul>
<li>当索引mid的值小于high时，说明此时mid所处的位置是最小值及最小值右边的区域<br>此时mid后面的区域可以不要了（不包括mid）</li>
<li>当索引值mid的值大于high时，说明mid所处的位置在最小值的左边，那么mid左边的区域可以不要了（包括mid）</li>
<li>当索引值mid等于high时，由于重复值的存在，不可以鲁莽的舍弃某一区域，所以high–</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (numbers[mid] &lt; numbers[high]) &#123;</span><br><span class="line">               high = mid;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[high]) &#123;</span><br><span class="line">               low = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               high--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="找到K个最接近的元素"><a href="#找到K个最接近的元素" class="headerlink" title="找到K个最接近的元素"></a>找到K个最接近的元素</h3><blockquote>
<p>给定一个 <strong>排序好</strong> 的数组 <code>arr</code> ，两个整数 <code>k</code> 和 <code>x</code> ，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。</p>
<p>LeetCode 658</p>
</blockquote>
<p><strong>比较器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; klist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nums : arr) &#123;</span><br><span class="line">            klist.add(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(klist, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(a - x) != Math.abs(b - x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.abs(a - x) - Math.abs(b - x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a - b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;Integer&gt; ans = klist.subList(<span class="number">0</span>, k);</span><br><span class="line">        Collections.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>双指针: 排除法</strong></p>
<p>因为arr已经是排序好的，所以每次排出的元素一定是在数组的两端，那么只要用双指针移动就好，其中有一个小小优化就是，没必要用Math.abs()函数，直接做差就好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pl</span> <span class="operator">=</span> <span class="number">0</span>, pr = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((pr - pl) &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[pr] - x) &lt; (x - arr[pl])) &#123;</span><br><span class="line">                pl++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pr--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pl; i &lt;= pr; i++) &#123;</span><br><span class="line">            ans.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>二分法</strong></p>
<p>可以知道的是：满足条件的k个数一定是x周围的连续区间内的数，所以可以去维护一个长度为k的“最优区间”<br>需要做的是：通过找到这个最优区间的左端点来做到定位区间<br>初始声明：left &#x3D; 0, right &#x3D; arr.length - k<br> left和right的含义是：最优区间的左端点一定在这个区间范围内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> size - k;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 尝试从长度为 k + 1 的连续子区间删除一个元素</span></span><br><span class="line">            <span class="comment">// 从而定位左区间端点的边界值</span></span><br><span class="line">            <span class="keyword">if</span> (x - arr[mid] &gt; arr[mid + k] - x) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid + 1..right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; left + k; i++) &#123;</span><br><span class="line">            res.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="阶乘后K个0"><a href="#阶乘后K个0" class="headerlink" title="阶乘后K个0"></a>阶乘后K个0</h3><blockquote>
<p><code>f(x)</code> 是 <code>x!</code> 末尾是 0 的数量。回想一下 <code>x! = 1 * 2 * 3 * ... * x</code>，且 <code>0! = 1</code> 。</p>
<ul>
<li>例如， <code>f(3) = 0</code> ，因为 <code>3! = 6</code> 的末尾没有 0 ；而 <code>f(11) = 2</code> ，因为 <code>11!= 39916800</code> 末端有 2 个 0 。</li>
</ul>
<p>给定 <code>k</code>，找出返回能满足 <code>f(x) = k</code> 的非负整数 <code>x</code> 的数量。</p>
<p>LeetCode 793</p>
</blockquote>
<h3 id="袋子里最小数目的球"><a href="#袋子里最小数目的球" class="headerlink" title="袋子里最小数目的球"></a>袋子里最小数目的球</h3><blockquote>
<p>给你一个整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个袋子里球的数目。同时给你一个整数 <code>maxOperations</code> 。</p>
<p>你可以进行如下操作至多 <code>maxOperations</code> 次：</p>
<ul>
<li>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有正整数个球。</li>
<li>比方说，一个袋子里有 <code>5</code> 个球，你可以把它们分到两个新袋子里，分别有 <code>1</code> 个和 <code>4</code> 个球，或者分别有 <code>2</code> 个和 <code>3</code> 个球。</li>
</ul>
<p>你的开销是单个袋子里球数目的 <strong>最大值</strong> ，你想要 <strong>最小化</strong> 开销。</p>
<p>请你返回进行上述操作后的最小开销。</p>
<p>LeetCode 1760</p>
</blockquote>
<p><strong>二分法</strong></p>
<p>一般题目中给出了最大、最小等字样的题目都可以使用二分法来解决问题。<br>二分分的是最大最小之间可能的值，不断减小ans的区间来逼近最终答案<br>此题就是可以将题目改成：<br>存在一个ans使得，在操作数小于maxOpts时让分好后袋子里的球的最大值小于ans<br>此ans的范围在数组的最小值和最大值之间，不断二分，减小ans的存在区间，找到正确答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSize</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> maxOperations)</span> &#123;</span><br><span class="line">        <span class="comment">// 上下界是数组的最大最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 每次二分的mid也就是假设可以在maxO内将袋子里的球分到小于mid的情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">opts</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 计算将每个袋子里的球分到比mid小需要的操作数，并累加</span></span><br><span class="line">                opts += (num - <span class="number">1</span>) / mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果需要的操作数小于max，说明符合情况，那就继续缩小上界</span></span><br><span class="line">            <span class="keyword">if</span> (opts &lt;= maxOperations) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果大于max，那就扩大下界</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="搜索排序旋转数组"><a href="#搜索排序旋转数组" class="headerlink" title="搜索排序旋转数组"></a>搜索排序旋转数组</h3><blockquote>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code>处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p>LeetCode 33 (hot 100)</p>
</blockquote>
<p><strong>核心思想就是一句话，一个数组旋转后，任意分成两部分，一定是一个有序，另一个局部有序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span>  <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 这个if可以判断出当前哪一个区域是有序的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="第一个和最后一个"><a href="#第一个和最后一个" class="headerlink" title="第一个和最后一个"></a>第一个和最后一个</h3><blockquote>
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p>LeetCode 34 (hot 100)</p>
</blockquote>
<p><strong>朴素二分法</strong></p>
<p>这是我拿到题写的方法，用的是最朴素的二分法，找到后两边扩散去寻找边界，简单好理解，但是二分法利用的不是特别好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> mid, r= mid;</span><br><span class="line">                <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; nums[l] == target) &#123;</span><br><span class="line">                    l--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; nums[r] == target) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[<span class="number">0</span>] = l + <span class="number">1</span>;</span><br><span class="line">                ans[<span class="number">1</span>] = r - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>二分法找边界</strong></p>
<p>考虑 target 开始和结束位置，其实我们要找的就是数组中「第一个等于 target 的位置」（记为 leftIdx）和「第一个大于 target 的位置减一」（记为 rightIdx）</p>
<p>二分查找中，寻找 leftIdx\textit{leftIdx}leftIdx 即为在数组中寻找第一个大于等于 target 的下标，寻找 rightIdx 即为在数组中寻找第一个大于 target 的下标，然后将下标减一。两者的判断条件不同，为了代码的复用，我们定义 binarySearch(nums, target, lower) 表示在 nums 数组中二分查找 target 的位置，如果 lower 为 true，则查找第一个大于等于 target 的下标，否则查找第一个大于 target 的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; leftIdx &gt;= <span class="number">0</span> &amp;&amp; rightIdx &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> lower)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 我们需要找到大于target和大于等于target的，所以应该把并集之外的情况摘出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="找规定时间的人"><a href="#找规定时间的人" class="headerlink" title="找规定时间的人"></a>找规定时间的人</h3><blockquote>
<p>给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。</p>
<p>已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。</p>
<p>请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。</p>
<p>LeetCode 1450 </p>
</blockquote>
<p><strong>差分数组</strong></p>
<p>这题当然很简答，正常的一次遍历就可以，而且效率最高，但是在这里介绍一个很妙的算法：差分数组，以endTime最大结束时间 + 2的长度声明一个差分数组，在 startTime[i] 处 +1 ，在 endTime[i + 1] 处 -1，然后从 1到 queryTime求和，即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">busyStudent</span><span class="params">(<span class="type">int</span>[] startTime, <span class="type">int</span>[] endTime, <span class="type">int</span> queryTime)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> startTime.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxEndTime</span> <span class="operator">=</span> Arrays.stream(endTime).max().getAsInt();</span><br><span class="line">        <span class="keyword">if</span> (queryTime &gt; maxEndTime) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[maxEndTime + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[startTime[i]] ++;</span><br><span class="line">            cnt[endTime[i] + <span class="number">1</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= queryTime; i++) &#123;</span><br><span class="line">            ans += cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







































<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><hr>
<blockquote>
<p>用法小结：</p>
<ul>
<li><p>判断奇偶</p>
<p>(x &amp; 1) &#x3D;&#x3D; 0 为真则为奇</p>
</li>
<li></li>
</ul>
</blockquote>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><blockquote>
<p>异或运算：相同为0，不同为N，也可以理解为二进制下无进位相加</p>
<p>异或的性质：</p>
<ol>
<li>0 ^ N &#x3D; N , N ^ N &#x3D; 0</li>
<li>异或运算满足交换律或结合律(用无进位相加去理解)</li>
</ol>
</blockquote>
<h3 id="异或交换两值"><a href="#异或交换两值" class="headerlink" title="异或交换两值"></a>异或交换两值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//能用以下操作进行值交换的前提是两个数在内存中是独立的内存区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j )</span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="出现奇数偶数次的数"><a href="#出现奇数偶数次的数" class="headerlink" title="出现奇数偶数次的数"></a>出现奇数偶数次的数</h3><blockquote>
<p>一个int型数组：</p>
<ol>
<li>有一个数出现了奇数次，其他都出现偶数次，怎么找到这个数？<br>解析：声明一个变量eor为0，来和数组所有的元素依次异或，得到的值即为唯一出现奇数次的那个数。</li>
<li>有两个数（a和b不等）出现了奇数次，其他出现了偶数次，怎么找到这两个数？<br>解析：先声明一个变量eor为0，和第一题一项先和数组的所有元素依次异或一遍，但是这个得到的值是a异或b，由于a和b不等，这也就意味着a和b这两个32为的数上至少有一位不同，即至少有一位（设第i位）的数a和b一个为1一个为0，那么按照这个条件可以把这个数组中的数分为两部分，一部分是第i位为1的数，还有一部分是第i位为0的数，再用一个eor与其中一部分的数分别异或即可得到a或b其中一个，</li>
</ol>
<p>要求空间复杂度 O（1）、时间复杂度O（n）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1.找出出现奇数次的数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findNumOdd</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">            eor = eor ^ cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eor;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2.找到出现奇数次的两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">finNumOdds</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">            eor = eor ^ cur;</span><br><span class="line">        &#125;<span class="comment">//此时得到的eor是 a^b</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor &amp; (~eor +<span class="number">1</span>);<span class="comment">//这里得到的是一个数最右边的1，参见2.2.1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">onlyOne</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur : arr)&#123;</span><br><span class="line">          <span class="comment">//rightOne这个数的二进制一定是一个只有1位是1的数即2的整数次方，所以和rightOne这个数相</span></span><br><span class="line">          <span class="comment">//与的数为0的数，那个位置一定为1，（==1也可以），这样就把数组中的数分成两部分了。</span></span><br><span class="line">            <span class="keyword">if</span>((cur &amp; rightOne) == <span class="number">0</span>)&#123;</span><br><span class="line">                onlyOne ^= cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(onlyOne + <span class="string">&quot; &quot;</span> + (onlyOne ^ eor));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="取反-与"><a href="#取反-与" class="headerlink" title="取反-与"></a>取反-与</h2><h3 id="出现最频繁的偶数"><a href="#出现最频繁的偶数" class="headerlink" title="出现最频繁的偶数"></a>出现最频繁的偶数</h3><blockquote>
<p>给你一个整数数组 <code>nums</code> ，返回出现最频繁的偶数元素。</p>
<p>如果存在多个满足条件的元素，只需要返回 <strong>最小</strong> 的一个。如果不存在这样的元素，返回 <code>-1</code> 。</p>
<p>LeetCode 2404</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mostFrequentEven</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100001</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCnt</span> <span class="operator">=</span> <span class="number">0</span>, maxNum = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++cnt[nums[i]];</span><br><span class="line">            <span class="keyword">if</span> (c &gt; maxCnt || c == maxCnt &amp;&amp; nums[i] &lt; maxNum) &#123;</span><br><span class="line">                maxCnt = c;</span><br><span class="line">                maxNum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="得到数最右的1"><a href="#得到数最右的1" class="headerlink" title="得到数最右的1"></a>得到数最右的1</h3><blockquote>
<p>如何利用位操作得到一个不等于0的数二进制的最右边的1？</p>
<p>解析：先取反，后加1，再与自己相与</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rightOne</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> a &amp; (~a + <span class="number">1</span>);</span><br><span class="line">       System.out.println(right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h3 id="一致字符串数目"><a href="#一致字符串数目" class="headerlink" title="一致字符串数目"></a>一致字符串数目</h3><blockquote>
<p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code> 。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是 <strong>一致字符串</strong> 。</p>
<p>请你返回 <code>words</code> 数组中 <strong>一致字符串</strong> 的数目。</p>
<p>LeetCode 1684</p>
</blockquote>
<p><strong>比较直观的方法：HashSet、Hash数组</strong></p>
<p>此题比较简单，用常规思维的方法很容易写出来，可以利用Set的不重合的特性，也可以利用一个26位大小的计数数组来做，总体比较简单就不写在这里了</p>
<p><strong>牛逼方法：掩码位运算</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countConsistentStrings</span><span class="params">(String allowed, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allowed.length(); i++) &#123;</span><br><span class="line">            flag |= <span class="number">1</span> &lt;&lt;(allowed.charAt(i) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                temp |= <span class="number">1</span> &lt;&lt; (word.charAt(i) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((flag | temp) == flag) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















<h2 id="位运算应用"><a href="#位运算应用" class="headerlink" title="位运算应用"></a>位运算应用</h2><h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><blockquote>
<p>N皇后问题的位运算解法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不超过32的N皇后问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> n == <span class="number">32</span> ? -<span class="number">1</span> : (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; <span class="comment">//将limit的后N位设置为全0模式</span></span><br><span class="line">        <span class="keyword">return</span> process2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int limit, 表示可以在哪些位置上去尝试放皇后</span></span><br><span class="line">    <span class="comment">//int colLim, 表示列限制</span></span><br><span class="line">    <span class="comment">//int leftDiaLim, 表示左斜线限制</span></span><br><span class="line">    <span class="comment">//int rightDiaLim，表示右斜线限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">process2</span><span class="params">(<span class="type">int</span> limit,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> colLim,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> leftDiaLim,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> rightDiaLim)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (colLim == limit) &#123; <span class="comment">// 当列限制和limit一样时说明所有位置都被填满了，即完成了一种可能性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mostRightOne</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//列限制、左斜线限制和右斜线限制求或得到了不可以摆皇后的位置都是1的一个数</span></span><br><span class="line">        <span class="comment">//再求反得到了一个没有限制的位为1的数</span></span><br><span class="line">        <span class="comment">//再和limit求与得到了一个后N为能放皇后的位为1的数</span></span><br><span class="line">        <span class="comment">//即pos就是所有候选皇后位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">            mostRightOne = pos &amp; (~pos + <span class="number">1</span>); <span class="comment">// 提取出候选皇后位置最右边的1出来</span></span><br><span class="line">            pos = pos - mostRightOne; <span class="comment">// 试完后将该位置的1减去，这样继续试下一个位置的1</span></span><br><span class="line">            res += process2(limit,</span><br><span class="line">                    colLim | mostRightOne, <span class="comment">//或运算得到列限制</span></span><br><span class="line">                    (leftDiaLim | mostRightOne) &lt;&lt; <span class="number">1</span>, <span class="comment">//左移左斜线限制</span></span><br><span class="line">                    (rightDiaLim | mostRightOne) &gt;&gt; <span class="number">1</span>); <span class="comment">//右移右斜线限制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><blockquote>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p>
<p>LeetCode 剑指offer 15</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="至少在两个数组出现"><a href="#至少在两个数组出现" class="headerlink" title="至少在两个数组出现"></a>至少在两个数组出现</h3><blockquote>
<p>给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 <strong>元素各不相同的</strong> 数组，且由 <strong>至少</strong>在 <strong>两个</strong> 数组中出现的所有值组成<em>。</em>数组中的元素可以按 <strong>任意</strong> 顺序排列。</p>
<p>LeetCode 2032</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">twoOutOfThree</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            map.put(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) | <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) | <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> ((v &amp; (v - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="第一个出现2次的字母"><a href="#第一个出现2次的字母" class="headerlink" title="第一个出现2次的字母"></a>第一个出现2次的字母</h3><blockquote>
<p>给你一个由小写英文字母组成的字符串 <code>s</code> ，请你找出并返回第一个出现 <strong>两次</strong> 的字母。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果 <code>a</code> 的 <strong>第二次</strong> 出现比 <code>b</code> 的 <strong>第二次</strong> 出现在字符串中的位置更靠前，则认为字母 <code>a</code> 在字母 <code>b</code> 之前出现两次。</li>
<li><code>s</code> 包含至少一个出现两次的字母。</li>
</ul>
<p>LeetCode 2351</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">repeatedCharacter</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">seen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> ((seen &amp; (<span class="number">1</span> &lt;&lt; x)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">            seen |= (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// impossible</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















<h2 id="数学应用"><a href="#数学应用" class="headerlink" title="数学应用"></a>数学应用</h2><h3 id="打印32位数每一位"><a href="#打印32位数每一位" class="headerlink" title="打印32位数每一位"></a>打印32位数每一位</h3><blockquote>
<p>java的int类型数字是32位的，写一个方法打印所有位的数字</p>
</blockquote>
<p><strong>思路</strong></p>
<p>1 左移 31位的结果是，将 1 向左移动了31位，且低位补 0，这样和 num 相与的话其他位都是 0，所以就看移动的那一位的了<br>（一个数左移一位相当于乘2）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEvery</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> num &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            System.out.print(x == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>























<h1 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h1><hr>
<h2 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h2><p>$$<br>T(N) &#x3D; a \times T(\frac N b) +O(N^d)\<br>\</p>
<p>(1): \log_b^a &lt; d \Rightarrow O(N^d)\<br>(2): \log_b^a &gt; d \Rightarrow O(N^{d\times\log_b^a})\<br>(3): \log_b^a &#x3D; d \Rightarrow O(N^d)\<br>$$</p>
<ul>
<li>用来求递归的时间复杂度，但需要满足此结构</li>
<li>N ：母问题的数据量是N级别的</li>
<li>a ：子问题的调用次数</li>
<li>N&#x2F;b ：子问题的规模</li>
<li>O指的是除了子问题的调用之外，剩下的过程时间复杂度是多少</li>
</ul>
<h2 id="简单递归"><a href="#简单递归" class="headerlink" title="简单递归"></a>简单递归</h2><h3 id="递归获取最大值"><a href="#递归获取最大值" class="headerlink" title="递归获取最大值"></a>递归获取最大值</h3><blockquote>
<p>用递归方法获取一个数组的最大值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> Process(arr, left, middle);</span><br><span class="line">        <span class="comment">//middle+1很重要，有点像while循环里的循环指针的变化，否则递归就会死掉</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> Process(arr, middle+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxNum</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Process(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="逆序栈"><a href="#逆序栈" class="headerlink" title="逆序栈"></a>逆序栈</h3><blockquote>
<p>给定一个栈，逆序这个栈，不能申请额外的数据结构，使用递归完成需求</p>
<p>此题是为了练习递归，所以用递归实现了以下几个方法</p>
<ul>
<li>f(  ) : 递归实现从栈底拿数据 </li>
<li>Reverse( ): 实现反转栈</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> f(stack); <span class="comment">//每次递归拿到最底层的数</span></span><br><span class="line">        reverse(stack);</span><br><span class="line">        stack.push(bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归实现实现拿到栈底元素</span></span><br><span class="line">    <span class="comment">//return返回的东西是每次递归之间沟通的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123; <span class="comment">//如果是栈底就返回</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> f(stack); <span class="comment">//last用来存放最后弹出的那个数的</span></span><br><span class="line">            stack.push(result); <span class="comment">//把每次递归弹出的栈顶元素再弹回去</span></span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="装袋最大重量"><a href="#装袋最大重量" class="headerlink" title="装袋最大重量"></a>装袋最大重量</h3><blockquote>
<p>给定两个长度为N的数组weights[i] 和 values[i] 分别代表i号物品的重量和价值，给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量，返回你能装下最多的价值是多少？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不带value方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> values[], <span class="type">int</span> i, <span class="type">int</span> alreadyWeight, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alreadyWeight &gt; bag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == weights.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(</span><br><span class="line">                process1(weights, values, i + <span class="number">1</span>, alreadyWeight, bag),</span><br><span class="line">                values[i] + process1(weights, values, i + <span class="number">1</span>, alreadyWeight + weights[i], bag)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//带value方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> values[], <span class="type">int</span> i, <span class="type">int</span> alreadyWeight, <span class="type">int</span> alreadyValue, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alreadyWeight &gt; bag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == weights.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> alreadyValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(</span><br><span class="line">        process2(weights, values, i + <span class="number">1</span>, alreadyWeight, alreadyValue, bag), <span class="comment">//不要i号货</span></span><br><span class="line">        process2(weights, values, i + <span class="number">1</span>, alreadyWeight + weights[i],</span><br><span class="line">                alreadyValue + values[i], bag) <span class="comment">//要i号货</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">       <span class="comment">//递归</span></span><br><span class="line">       <span class="keyword">if</span> (list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">           list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除链表特定节点"><a href="#删除链表特定节点" class="headerlink" title="删除链表特定节点"></a>删除链表特定节点</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-30%2022.20.33.png" style="zoom:50%;" />



<p><strong>递归做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125; </span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="判断回文单链表"><a href="#判断回文单链表" class="headerlink" title="判断回文单链表"></a>判断回文单链表</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-30%2023.18.37.png" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">frontNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        frontNode = head;</span><br><span class="line">        <span class="keyword">return</span> checkProcess(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkProcess</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!checkProcess(head.next)) &#123; <span class="comment">// // 只要后面返回一个false就会一直返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.val != frontNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontNode = frontNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><blockquote>
<p>暴力递归就是尝试。它还有很多其他的叫法：分治、回溯、迭代。。。。</p>
<ol>
<li>把问题转化为规模缩小了的同类问题的子问题</li>
<li>有明确的不需要继续进行递归的条件（base case）</li>
<li>要有当得到了子问题的结果之后的决策或成</li>
<li>不记录每一个子问题的最优解</li>
</ol>
<p>一定要学会怎么去尝试，这是动态规划的基础</p>
</blockquote>
<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><blockquote>
<p>给定i层汉诺塔，以及若干棍子（通常为3根），要求打印出最优轨迹</p>
<p>将这个问题分解成子问题时，先别太着急，想一下子找到最优解，先慢慢来，把棍子看成from，to，和other，把0 到 i-1层的汉诺塔看成整体，最后一层汉诺塔单独看成整体，因为最后一层汉诺塔是最大的，它不可以压其他层，然后这个问题就可以分解为以下几个步骤：</p>
<ol>
<li>第一步：1 ～ i-1：看成 form 到 other 的行为，因为都要给最大的那一个让步，最大的那一层必须第一个到目标也就是to棍子</li>
<li>第二步：i ： 看成 from 到 to 的行为</li>
<li>第三步：1～i-1:看成剩下的棍子到to棍子的行为</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//假设游戏规则是将所有圆盘从左移动到右，中间则是other棍子</span></span><br><span class="line">            func(n, <span class="string">&quot;左&quot;</span>, <span class="string">&quot;右&quot;</span>, <span class="string">&quot;中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i, String start, String end, String other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; <span class="comment">// base case</span></span><br><span class="line">            System.out.println(<span class="string">&quot; Move 1 from &quot;</span> + start + <span class="string">&quot; to &quot;</span> + end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            func(i - <span class="number">1</span>, start, other, end);</span><br><span class="line">            System.out.println(<span class="string">&quot; Move &quot;</span> + i + <span class="string">&quot; from &quot;</span> + start + <span class="string">&quot; to &quot;</span> + end);</span><br><span class="line">            func(i - <span class="number">1</span>, other, end, start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h3><blockquote>
<p>打印一个字符串的全部子序列，包括空字符串</p>
<p>思路：从第一个字符开始，打印的时候有两种选择：打印或者不打印，这样就形成了一条从根节点到叶子节点的打印二叉树</p>
</blockquote>
<p><strong>最经典的做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line">       process(chs, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Character&gt;());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当前来到i位置，要和不要，两条路</span></span><br><span class="line">   <span class="comment">//res:之前的选择形成的表</span></span><br><span class="line">   <span class="comment">//其实就是去遍历这个选择字符所形成的二叉树，不同的是，只有遍历待到叶子节点的时候才打印整个选择表</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i, List&lt;Character&gt; res)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">           printList(res);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Character&gt; resKeep = copyList(res);</span><br><span class="line">       resKeep.add(str[i]);</span><br><span class="line">       process(str, i + <span class="number">1</span>, resKeep); <span class="comment">//走要当前字符的路</span></span><br><span class="line">       List&lt;Character&gt; resNoKeep = copyList(res);</span><br><span class="line">       process(str, i + <span class="number">1</span>, resNoKeep);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;Character&gt; list)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (Character cha : list) &#123;</span><br><span class="line">           System.out.println(cha.charValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Character&gt; <span class="title function_">copyList</span><span class="params">(List&lt;Character&gt; list)</span> &#123;</span><br><span class="line">       List&lt;Character&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Character cha : list) &#123;</span><br><span class="line">           list1.add(cha);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>省空间的做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAllSubsequence</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line">        process1(chs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//来到当前i位置，要和不要，走两条路</span></span><br><span class="line">    <span class="comment">//之前的选择，所形成的结果，是str</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">            System.out.println(String.valueOf(str));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process1(str, i + <span class="number">1</span>); <span class="comment">//要当前字符的路</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> str[i];</span><br><span class="line">        str[i] = <span class="number">0</span>;</span><br><span class="line">        process1(str, i + <span class="number">1</span>); <span class="comment">//不要当前字符的路</span></span><br><span class="line">        str[i] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="字符串全排列"><a href="#字符串全排列" class="headerlink" title="字符串全排列"></a>字符串全排列</h3><blockquote>
<p>打印一个字符串的全部排列，要求不出现重复</p>
<p>思路：假设字符串有N个字符，则第一个字符有N中可能，第二个字符有N-1种可能，慢慢往下试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">Permutation</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line">        process(chs, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//str[i...]范围上，所有的字符，都可以在i位置上，后续都去尝试</span></span><br><span class="line">    <span class="comment">//str[0~i-1]范围上，是之前做的选择，</span></span><br><span class="line">    <span class="comment">//请把所有的字符串形成的全排列，加到res里去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i, ArrayList&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">            res.add(String.valueOf(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>]; <span class="comment">//假设是26个小写字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; str.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[str[j] - <span class="string">&#x27;a&#x27;</span>]) &#123;  <span class="comment">//分支限界,试过的字符就不试了</span></span><br><span class="line">                visit[str[j] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">                swap(str, i, j);</span><br><span class="line">                process(str, i + <span class="number">1</span>, res);</span><br><span class="line">                swap(str, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chs[i];</span><br><span class="line">        chs[i] = chs[j];</span><br><span class="line">        chs[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="左右纸牌游戏"><a href="#左右纸牌游戏" class="headerlink" title="左右纸牌游戏"></a>左右纸牌游戏</h3><blockquote>
<p>给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，玩家A和玩家B都绝顶聪明。返回最后获胜者的分数。</p>
<p>【举例】<br>arr&#x3D;[1，2，100，4] 。<br>开始时，玩家A只能拿走1或4。如果开始时玩家A拿走1，则排列变为[2，100，4]，接下来玩家B可以拿走2或4，然然后继续轮到玩家A.<br>如果开始时玩家A拿走4，则排列变为[1，2，100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A<br>玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，让排列变为[2，100，4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101</p>
<p>arr&#x3D;[1，100，2] 。<br>开始时，玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100。所以返回100。</p>
<p>思路：定义两个函数：先手函数 f( ) 和后手函数 s( )<br>先手函数在arr[l] + s(arr, l + 1, r) 和 arr[r] + s(arr, L, r - 1) 中挑选最大值，后手函数在 f(arr, l + 1, r) 和 f(arr, l, r- 1)中取最小值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//0 到lenth - 1先手是玩家A</span></span><br><span class="line">       <span class="comment">//0 到length - 1后手是玩家B</span></span><br><span class="line">       <span class="comment">//谁大谁是赢家</span></span><br><span class="line">       <span class="keyword">return</span> Math.max(f(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>), s(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == j) &#123; <span class="comment">//当只剩一张牌了且先手，那就拿这张牌</span></span><br><span class="line">           <span class="keyword">return</span> arr[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(arr[i] + s(arr, i + <span class="number">1</span>, j), arr[j] + s(arr, i, j - <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">s</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == j) &#123; <span class="comment">// 当只剩一张牌且后手，那就没得拿了，就返回0</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.min(f(arr, i + <span class="number">1</span>, j), f(arr, i, j - <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h3 id="N皇后问题-1"><a href="#N皇后问题-1" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><blockquote>
<p>N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行不同列也不在同一斜线上</p>
<p>给定一个整数n，返回n皇后的的摆法有多少种<br>给定1，返回1<br>n为2或3，2皇后和3皇后无论怎么摆都不可以，返回0<br>n&#x3D;8，返回92</p>
<p>思路：</p>
<ol>
<li>暴力法，保留每次存放的皇后位置，递归去其他位置</li>
<li>位运算法，不超过32位可以申请一个32位的二进制数，几皇后问题就将后几位设置为0，每一列不能摆皇后的位置设为1<br>设置三个变量分别表示列限制，左斜线限制和右斜线限制，这三个变量求或就是对下一行的整体限制</li>
</ol>
</blockquote>
<p><strong>经典解法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// record[i]表示第i行的皇后放在哪一列</span></span><br><span class="line">       <span class="keyword">return</span> process1(<span class="number">0</span>, record, n);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//目前来到了第i行</span></span><br><span class="line">   <span class="comment">//record[0...i-1]表示之前放过的皇后位置信息,且这些皇后一定不共行不共列不共斜线</span></span><br><span class="line">   <span class="comment">//record的作用是为了在判断的皇后位置是否合法的时候起作用，并不真正详细记录每一种皇后摆放的方法</span></span><br><span class="line">   <span class="comment">//一共n行</span></span><br><span class="line">   <span class="comment">//返回值是摆完所有的皇后，合理的摆法有多少种</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] record, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">//当前行在第i行，尝试i行所有列</span></span><br><span class="line">           <span class="keyword">if</span> (isValid(record, i, j)) &#123;</span><br><span class="line">               record[i] = j;</span><br><span class="line">               res += process1(i + <span class="number">1</span>, record, n);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//只需要检查0到i-1的皇后</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span>[] record, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">           <span class="comment">//先判断是否共列，再判断鞋履是否相等，即纵坐标的差是否等于横坐标的差</span></span><br><span class="line">           <span class="keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>还有一种列运算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不超过32的N皇后问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> n == <span class="number">32</span> ? -<span class="number">1</span> : (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; <span class="comment">//将limit的后N位设置为全0模式</span></span><br><span class="line">        <span class="keyword">return</span> process2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int limit, 表示可以在哪些位置上去尝试放皇后</span></span><br><span class="line">    <span class="comment">//int colLim, 表示列限制</span></span><br><span class="line">    <span class="comment">//int leftDiaLim, 表示左斜线限制</span></span><br><span class="line">    <span class="comment">//int rightDiaLim，表示右斜线限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">process2</span><span class="params">(<span class="type">int</span> limit,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> colLim,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> leftDiaLim,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> rightDiaLim)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (colLim == limit) &#123; <span class="comment">// 当列限制和limit一样时说明所有位置都被填满了，即完成了一种可能性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mostRightOne</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//列限制、左斜线限制和右斜线限制求或得到了不可以摆皇后的位置都是1的一个数</span></span><br><span class="line">        <span class="comment">//再求反得到了一个没有限制的位为1的数</span></span><br><span class="line">        <span class="comment">//再和limit求与得到了一个后N为能放皇后的位为1的数</span></span><br><span class="line">        <span class="comment">//即pos就是所有候选皇后位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">            mostRightOne = pos &amp; (~pos + <span class="number">1</span>); <span class="comment">// 提取出候选皇后位置最右边的1出来</span></span><br><span class="line">            pos = pos - mostRightOne; <span class="comment">// 试完后将该位置的1减去，这样继续试下一个位置的1</span></span><br><span class="line">            res += process2(limit,</span><br><span class="line">                    colLim | mostRightOne, <span class="comment">//或运算得到列限制</span></span><br><span class="line">                    (leftDiaLim | mostRightOne) &lt;&lt; <span class="number">1</span>, <span class="comment">//左移左斜线限制</span></span><br><span class="line">                    (rightDiaLim | mostRightOne) &gt;&gt; <span class="number">1</span>); <span class="comment">//右移右斜线限制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>













<h2 id="二维矩阵问题"><a href="#二维矩阵问题" class="headerlink" title="二维矩阵问题"></a>二维矩阵问题</h2><h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><blockquote>
<p>力扣：<a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/</a></p>
<p>题目描述<br>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
</blockquote>
<p><strong>暴力递归</strong></p>
<p>本题的尝试套路比较简单，就是四个方向去试，但是有两个问题需要注意，一个是base case，在判断了不满足条件的情况后，跟上一个判对的条件，否则递归只会返回fasle，还有一个是，由于一个格子不允许使用两次，所以有一个小技巧防止四个方向的尝试会使用之前节点的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] str = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (process(board, str, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] str, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.length </span><br><span class="line">            || col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].length </span><br><span class="line">            || board[row][col] != str[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == str.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//将当前值改为一个不可能的字符，防止二次使用</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> board[row][col];</span><br><span class="line">        board[row][col] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> process(board, str, row + <span class="number">1</span>, col, index + <span class="number">1</span>) </span><br><span class="line">        || process(board, str, row - <span class="number">1</span>, col, index + <span class="number">1</span>)</span><br><span class="line">        || process(board, str, row, col + <span class="number">1</span>, index + <span class="number">1</span>)</span><br><span class="line">        || process(board, str, row, col - <span class="number">1</span>, index + <span class="number">1</span>);</span><br><span class="line">        board[row][col] = temp; <span class="comment">// 递归结束后将值改回来</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="二维数组特殊位置"><a href="#二维数组特殊位置" class="headerlink" title="二维数组特殊位置"></a>二维数组特殊位置</h3><blockquote>
<p>给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。</p>
<p>特殊位置 定义：如果 mat[i][j] &#x3D;&#x3D; 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/special-positions-in-a-binary-matrix">https://leetcode.cn/problems/special-positions-in-a-binary-matrix</a></p>
</blockquote>
<p><strong>数组缓存和</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSpecial</span><span class="params">(<span class="type">int</span>[][] mat)</span> &#123;</span><br><span class="line">        <span class="comment">// 采用求和的方式快速判断是否是特殊位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] rowSum = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="type">int</span>[] colSum = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                rowSum[i] += mat[i][j];</span><br><span class="line">                colSum[j] += mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">1</span> &amp;&amp; rowSum[i] == <span class="number">1</span> &amp;&amp; colSum[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>标记列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSpecial</span><span class="params">(<span class="type">int</span>[][] mat)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                count += mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 防止第一行重复累加</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mat[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        mat[<span class="number">0</span>][j] += count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : mat[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><h3 id="特殊的二进制序列"><a href="#特殊的二进制序列" class="headerlink" title="特殊的二进制序列"></a>特殊的二进制序列</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-17%2011.01.23.png"  style="zoom:50%;" />













<h2 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h2><h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-17%2016.25.36.png" alt="截屏2022-08-17 16.25.36" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;State, Map&lt;CharType, State&gt;&gt;();</span><br><span class="line">        Map&lt;CharType, State&gt; initialMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_INITIAL);</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INITIAL, initialMap);</span><br><span class="line">        Map&lt;CharType, State&gt; intSignMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INT_SIGN, intSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; integerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INTEGER, integerMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT, pointMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);</span><br><span class="line">        Map&lt;CharType, State&gt; fractionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_FRACTION, fractionMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP, expMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expSignMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_SIGN, expSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expNumberMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);</span><br><span class="line">        Map&lt;CharType, State&gt; endMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_END, endMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> State.STATE_INITIAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">CharType</span> <span class="variable">type</span> <span class="operator">=</span> toCharType(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = transfer.get(state).get(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CharType <span class="title function_">toCharType</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SPACE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CharType</span> &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="顺指针打印矩阵"><a href="#顺指针打印矩阵" class="headerlink" title="顺指针打印矩阵"></a>顺指针打印矩阵</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-23%2014.38.50.png" alt="截屏2022-08-23 14.38.50" style="zoom:50%;" />



<p><strong>按层模拟</strong></p>
<h3 id="判断出入栈序列"><a href="#判断出入栈序列" class="headerlink" title="判断出入栈序列"></a>判断出入栈序列</h3><blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : pushed) &#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="括号的分数"><a href="#括号的分数" class="headerlink" title="括号的分数"></a>括号的分数</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-09%2016.08.01.png" alt="截屏2022-10-09 16.08.01" style="zoom:50%;" />





<p><strong>方法一：栈</strong></p>
<p>利用栈来解决这个问题，但不是用栈来模拟括号的匹配，而是蕴含了一种分治的思想，栈的每一位推入的都是当前括号所能得到的分数<br>如果当前遍历到的字符串字符是 ) ,那么久弹出栈顶元素，如果是0意味着上一个元素是 （，那么就推1，如果不是0，那么就根据规则来，是弹出分数的2倍，总结就是 Math.max(2*goal, 1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scoreOfParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       deque.push(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">               deque.push(<span class="number">0</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">preGoal</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">               <span class="type">int</span> <span class="variable">curGoal</span> <span class="operator">=</span> deque.pop() + Math.max(preGoal * <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">               deque.push(curGoal);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法二：分治</strong></p>
<p>记 （分数为1，）为-1，当递归的s长度只剩2了，那就返回1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scoreOfParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果传入的字符串只有两个字符，说明必是（），分数为1</span></span><br><span class="line">        <span class="comment">// 因为按照题意，所有的括号都是完美配对的</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">goal</span> <span class="operator">=</span> <span class="number">0</span>, n = s.length(), len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 找到第一个分数和为0的字符，也就是说，找到第一对配对的括号</span></span><br><span class="line">            <span class="comment">// 之所以找到这个是因为配对的括号可以继续分解，其他括号可以按照这个逻辑继续分解</span></span><br><span class="line">            goal += s.charAt(i) == <span class="string">&#x27;)&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (goal == <span class="number">0</span>) &#123;</span><br><span class="line">                len = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前len其实是s的最后一个字符，那么按照规则，将这一对括号内的分数乘2即可</span></span><br><span class="line">        <span class="keyword">if</span> (len == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> scoreOfParentheses(s.substring(<span class="number">1</span>, len - <span class="number">1</span>)) * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前len不是s的最后一个字符，那就属于 A + B类型，继续分治即可</span></span><br><span class="line">            <span class="keyword">return</span> scoreOfParentheses(s.substring(<span class="number">0</span>, len)) + </span><br><span class="line">            scoreOfParentheses(s.substring(len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法三：直接计算</strong></p>
<p>这个方法太妙了，对数学敏感度有一定要求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scoreOfParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此方法带有一点数学分析的味道，由题意可知，一个平衡字符串的分数最终取决于()</span></span><br><span class="line"><span class="comment">            由（）的深度决定，假设现有一对（），深度 h，其分数为 2^h</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>, n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            height += s.charAt(i) == <span class="string">&#x27;)&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span> &lt;&lt; height;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><blockquote>
<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>LeetCode（79）hot 100</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = word;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> board.length, w = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[h][w];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, i, j, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">boolean</span>[][] visited, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把当前元素标志为访问过，这样待会就不会重复访问此元素</span></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newi</span> <span class="operator">=</span> i + dir[<span class="number">0</span>], newj = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newi &gt;= <span class="number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="number">0</span> &amp;&amp; newj &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[newi][newj]) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, newi, newj, k + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        result = flag;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归回去的时候把当前元素设置为未访问</span></span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="电话号码字母组合"><a href="#电话号码字母组合" class="headerlink" title="电话号码字母组合"></a>电话号码字母组合</h3><blockquote>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>LeetCode 17 (hot 100)</p>
</blockquote>
<p><strong>回溯</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; combinations,</span></span><br><span class="line"><span class="params">         Map&lt;Character, String&gt; phoneMap, String digits, <span class="type">int</span> index, StringBuffer combination)</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">                 combinations.add(combination.toString());</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">                 <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> phoneMap.get(digit);</span><br><span class="line">                 <span class="comment">// 遍历每次拿出来的字母，不断加到字符串后</span></span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">                     combination.append(letters.charAt(i));</span><br><span class="line">                     backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                     combination.deleteCharAt(index);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        <span class="comment">// 声明一个队列存储结果</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digits.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 将队列和每次需要加入的 letters 传到 queueDeal 方法</span></span><br><span class="line">            queueDeal(queue, phoneMap.get(digits.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String s : queue) &#123;</span><br><span class="line">            combinations.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queueDeal</span><span class="params">(Queue&lt;String&gt; queue, String letters)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，直接把 letters 的每一个字符转成字符串加到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">                queue.add(<span class="string">&quot;&quot;</span> + letters.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">// 把当前队列的每一个元素挨个儿弹出，拼接 letters 的所有字符再加进去</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">queueStr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; letters.length(); j++) &#123;</span><br><span class="line">                    queue.add(queueStr + letters.charAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h3><blockquote>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p>LeetCode : 22 (hot 10)</p>
</blockquote>
<p><strong>利用此题独特的规律</strong></p>
<p>每次该加哪一个括号是有规律的,当左括号等于右括号，必须先加左括号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        generate(<span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">(String str, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            combinations.add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 剩余的左括号数等于右括号数必须先加左括号</span></span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                generate(str + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left 小于 right 随便加，这里优先加左括号</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    generate(str + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">                &#125;</span><br><span class="line">                generate(str + <span class="string">&quot;)&quot;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><blockquote>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code>的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p>LeetCode: 39 (hot 100)</p>
</blockquote>
<p><strong>暴力回溯，无剪枝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> idx, </span></span><br><span class="line"><span class="params">                          List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == candidates.length) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 这个判断官解没有，个人理解这也是一个小小的剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtrack(candidates, target, idx + <span class="number">1</span>, res, path);</span><br><span class="line">            <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                path.add(candidates[idx]);</span><br><span class="line">                backtrack(candidates, target - candidates[idx], idx, res, path);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带剪枝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序是剪枝的前提</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, len, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> len, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 重点理解这里剪枝，前提是候选数组已经有序，</span></span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, i, len, target - candidates[i], path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><blockquote>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em>。你可以 <strong>按任意顺序</strong> 返回答案。</p>
</blockquote>
<p><strong>回溯</strong></p>
<p>这里需要注意一个点， 就是回溯的终止条件是 ans.add(new ArrayList&lt;&gt;(path))，不是 ans.add(path);，因为 java 是按值传递，直接加 path实际只是把 path 的引用地址复制了一份加到了 ans 中，这样在递归回退到起点时就都是空链表了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">// 标识每个 nums 元素是否被用过</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];</span><br><span class="line">        backTrack(nums, len, <span class="number">0</span>, used, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> len, <span class="type">int</span> depth, <span class="type">boolean</span>[] used,</span></span><br><span class="line"><span class="params">        List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                backTrack(nums, len, depth + <span class="number">1</span>, used, path, ans);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="字集"><a href="#字集" class="headerlink" title="字集"></a>字集</h3><blockquote>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p>LeetCode(hot 100) 78</p>
</blockquote>
<p><strong>二进制 + 迭代</strong></p>
<p>以 {1, 2, 3} 集合来举例</p>
<table>
<thead>
<tr>
<th>二进制序列</th>
<th>字集</th>
<th>对应的二进制数</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>{}</td>
<td>0</td>
</tr>
<tr>
<td>001</td>
<td>{3}</td>
<td>1</td>
</tr>
<tr>
<td>010</td>
<td>{2}</td>
<td>2</td>
</tr>
<tr>
<td>011</td>
<td>{2, 3}</td>
<td>3</td>
</tr>
<tr>
<td>100</td>
<td>{1}</td>
<td>4</td>
</tr>
<tr>
<td>101</td>
<td>{1, 3}</td>
<td>5</td>
</tr>
<tr>
<td>110</td>
<td>{1, 2}</td>
<td>6</td>
</tr>
<tr>
<td>111</td>
<td>{1, 2, 3}</td>
<td>7</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 2^n 种情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); mask++) &#123;</span><br><span class="line">            list.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// 看当前mask的二进制数位是否为1，是的话就加到list中</span></span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里别忘了给list声明新的空间</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>回溯</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTrack(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(nums[cur]);</span><br><span class="line">        backTrack(cur + <span class="number">1</span>, nums);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        backTrack(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>































<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><hr>
<h2 id="哈希表与哈希函数"><a href="#哈希表与哈希函数" class="headerlink" title="哈希表与哈希函数"></a>哈希表与哈希函数</h2><blockquote>
<p>哈希表</p>
<ul>
<li>哈希表在使用层面上可以理解为一种集合结构</li>
<li>如果只有key，没有伴随数据value，可以使用HashSet结构（C++中称为UnorderedSet）</li>
<li>如果有key，又有伴随数据value，可以使用HashMap结构（C++中称为UnorderedMap）</li>
<li>有无伴随数据是HashMap和HashSet的唯一区别，底层结构实际是一回事</li>
<li>使用哈希表增删改查可以认为时间复杂度是O（1），但是常数时间较大</li>
<li>放入哈希表的东西：<ul>
<li>如果是基础类型，内部按值传递，内存占用的就是这个东西的大小</li>
<li>如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小</li>
</ul>
</li>
</ul>
<p>哈希函数：</p>
<ul>
<li>哈希函数的输入域是无穷的</li>
<li>哈希函数的输出域相对有限</li>
<li>哈希函数相同的输入值一定会返回相同的输出值</li>
<li>哈希碰撞：不同的输入可能会对应相同的输出</li>
<li>离散性和均匀性</li>
</ul>
</blockquote>
<ul>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashSet的key是基础类型</span></span><br><span class="line">       HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       hashSet1.add(<span class="number">3</span>);</span><br><span class="line">       System.out.println(hashSet1.contains(<span class="number">3</span>));</span><br><span class="line">       hashSet1.remove(<span class="number">3</span>);</span><br><span class="line">       System.out.println(hashSet1.contains(<span class="number">3</span>));</span><br><span class="line">  </span><br><span class="line">       HashMap&lt;Integer, String&gt; hashMap1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       hashMap1.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">       hashMap1.put(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>);<span class="comment">//这里会修改之前key == 1 的value值</span></span><br><span class="line">       hashMap1.put(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">       System.out.println(hashMap1.containsKey(<span class="number">1</span>));</span><br><span class="line">       System.out.println(hashMap1.get(<span class="number">1</span>));</span><br><span class="line">       System.out.println(hashMap1.get(<span class="number">100</span>));</span><br><span class="line">       System.out.println(hashMap1.remove(<span class="number">1</span>));</span><br><span class="line">       System.out.println(hashMap1.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="哈希函数案例"><a href="#哈希函数案例" class="headerlink" title="哈希函数案例"></a>哈希函数案例</h3><blockquote>
<p>假设现在有40亿个数，每个数的范围是在0 – 2^32-1， 如何利用1G内存来统计相同的数出现了多少次？</p>
<p>分析：传统做法是利用一个哈希表，key是数字，value是这个数字出现的次数，但是这样写内存不够，所以思路是将40亿个数均分成个小部分，然后来统计，但是怎么分去统计最好呢，可以先利用一个哈希函数将每一个数得到一个对应的哈希值，然后再将哈希值取模100，这样就能将所有的数按类分成100份，且相同的数一定在同一份里，再继续在每一份中去统计</p>
</blockquote>
<h3 id="RandomPool结构"><a href="#RandomPool结构" class="headerlink" title="RandomPool结构"></a>RandomPool结构</h3><blockquote>
<p>题目：<br>设计一种结构，在该结构中有如下三个功能：<br>insert(Key) : 将某个key加入到该结构，做到不重复加入<br>Delete(Key) : 将原本在结构中的某个key移除<br>getRandom( ) : 等概率随机返回结构中的任何一个key</p>
<p>要求：<br>时间复杂度都是O（1）</p>
<p>思路：<br>定义一个结构，需要三个属性，一个size和两张map，map1是str到index，map2是index到str2</p>
</blockquote>
<h3 id="用户分组"><a href="#用户分组" class="headerlink" title="用户分组"></a>用户分组</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-12%2010.15.31.png" alt="截屏2022-08-12 10.15.31" style="zoom:50%;" />



<p><strong>解析</strong></p>
<p>对于这一题我觉得是极具代表性的关于哈希表以及线性表的综合应用，思维不算太难，但是需要十分细致。<br>大体思路是：先用哈希表记录每个元素出现的次数，再遍历这个哈希表，单独拿出每个entry的size 和value，然后再利用一个双层for循环，外层用来确定组数，内层用来给每个组赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">groupThePeople</span><span class="params">(<span class="type">int</span>[] groupSizes)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> groupSizes.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> groupSizes[i];</span><br><span class="line">            map.putIfAbsent(size, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">            map.get(size).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            List&lt;Integer&gt; peopleAll = entry.getValue();</span><br><span class="line">            <span class="type">int</span> <span class="variable">groupNum</span> <span class="operator">=</span> peopleAll.size() / size;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; groupNum; i++) &#123;</span><br><span class="line">                List&lt;Integer&gt; groupEach = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i * size;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    groupEach.add(peopleAll.get(start + j));</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(groupEach);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="翻转数组相等"><a href="#翻转数组相等" class="headerlink" title="翻转数组相等"></a>翻转数组相等</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-24%2010.05.14.png" alt="截屏2022-08-24 10.05.14" style="zoom:50%;" />



<p><strong>哈希数组法</strong></p>
<p>判断数组元素是否相等即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canBeEqual</span><span class="params">(<span class="type">int</span>[] target, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; counts1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; counts2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : target) &#123;</span><br><span class="line">            counts1.put(num, counts1.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            counts2.put(num, counts2.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (counts1.size() != counts2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts1.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey(), value = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!counts2.containsKey(key) || counts2.get(key) != value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>基数数组法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canBeEqual</span><span class="params">(<span class="type">int</span>[] target, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++cnt[target[i]] == <span class="number">1</span>) ans++;</span><br><span class="line">            <span class="keyword">if</span> (--cnt[arr[i]] == <span class="number">0</span>) ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-17%2022.41.24.png" alt="截屏2022-10-17 22.41.24" style="zoom:50%;" />





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> fruits.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 用一个 left 指针来指代最左的那个树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            map.put(fruits[right], map.getOrDefault(fruits[right], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这个while是我一开始写没有想到的，得到新的起点</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(fruits[left], map.get(fruits[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(fruits[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="查找用户活跃分钟数"><a href="#查找用户活跃分钟数" class="headerlink" title="查找用户活跃分钟数"></a>查找用户活跃分钟数</h3><blockquote>
<p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 <code>IDi</code> 的用户在 <code>timei</code> 分钟时执行了某个操作。</p>
<p><strong>多个用户</strong> 可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p>
<p>指定用户的 <strong>用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p>
<p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 &lt;= j &lt;= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p>
<p>返回上面描述的答案数组 <code>answer</code> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findingUsersActiveMinutes(<span class="type">int</span>[][] logs, <span class="type">int</span> k) &#123;</span><br><span class="line">       Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; logs.length; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> logs[i][<span class="number">0</span>];</span><br><span class="line">           map.putIfAbsent(id, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;());</span><br><span class="line">           map.get(id).add(logs[i][<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">           ans[entry.getValue().size() - <span class="number">1</span>]++;                      </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="保证文件名唯一"><a href="#保证文件名唯一" class="headerlink" title="保证文件名唯一"></a>保证文件名唯一</h3><blockquote>
<p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code> 。你将会在文件系统中创建 <code>n</code> 个文件夹：在第 <code>i</code> 分钟，新建名为 <code>names[i]</code> 的文件夹。</p>
<p>由于两个文件 <strong>不能</strong> 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 <code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 <code>k</code> 是能保证文件名唯一的 <strong>最小正整数</strong> 。</p>
<p>返回长度为 <em><code>n</code></em> 的字符串数组，其中 <code>ans[i]</code> 是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p>
<p>LeetCode 1487</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] getFolderNames(String[] names) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> names.length;</span><br><span class="line">        String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> names[i];</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(name)) &#123;</span><br><span class="line">                res[i] = name;</span><br><span class="line">                map.put(name, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> map.get(name);</span><br><span class="line">                <span class="keyword">while</span> (map.containsKey(getComplexName(name, k))) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i] = getComplexName(name, k);</span><br><span class="line">                map.put(name, k + <span class="number">1</span>);</span><br><span class="line">                map.put(getComplexName(name, k), <span class="number">1</span>);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getComplexName</span><span class="params">(String name, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;(&quot;</span> + index + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h2 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h2><blockquote>
<ul>
<li>哈希表在使用层面上可以理解为一种集合结构</li>
<li>如果只有key，没有伴随数据value，可以使用TreeSet结构（C++中称为OrderedSet）</li>
<li>如果有key，又有伴随数据value，可以使用TreeMap结构（C++中称为OrderedMap）</li>
<li>有无伴随数据是TreeSet和TreeMap的唯一区别，底层结构实际是一回事</li>
<li>有序表和哈希表的区别是，有序表把key按顺序组织起来，哈希表完全不组织</li>
<li>红黑树、AVL数、Size-Balance-Tree和跳表都属于有序表结构，只是底层实现完群不同</li>
<li>放入有序表的东西：<ul>
<li>如果是基础类型，内部按值传递，内存占用的就是这个东西的大小</li>
<li>如果不是基础类型，则必须提供比较器，内部按引用传递，内存占用就是这个东西内存地址大小</li>
</ul>
</li>
<li>不论是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度</li>
</ul>
</blockquote>
<ul>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; treeMap1 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">       treeMap1.put(<span class="number">1</span>, <span class="string">&quot;我是1&quot;</span>);</span><br><span class="line">       treeMap1.put(<span class="number">2</span>, <span class="string">&quot;我是2&quot;</span>);</span><br><span class="line">       treeMap1.put(<span class="number">3</span>, <span class="string">&quot;我是3&quot;</span>);</span><br><span class="line">       treeMap1.put(<span class="number">4</span>, <span class="string">&quot;我是4&quot;</span>);</span><br><span class="line">       treeMap1.put(<span class="number">5</span>, <span class="string">&quot;我是5&quot;</span>);</span><br><span class="line">       treeMap1.put(<span class="number">6</span>, <span class="string">&quot;我是6&quot;</span>);</span><br><span class="line">       treeMap1.put(<span class="number">7</span>, <span class="string">&quot;我是7&quot;</span>);</span><br><span class="line">       System.out.println(treeMap1.containsKey(<span class="number">1</span>));</span><br><span class="line">       System.out.println(treeMap1.get(<span class="number">5</span>));</span><br><span class="line">       System.out.println(treeMap1.firstKey());</span><br><span class="line">       System.out.println(treeMap1.lastKey());</span><br><span class="line">       System.out.println(treeMap1.floorKey(<span class="number">8</span>));<span class="comment">//在表中所有&lt;=8的数中离8最近的数</span></span><br><span class="line">       System.out.println(treeMap1.ceilingKey(<span class="number">6</span>));<span class="comment">//在表中所有&gt;=8的数中离8最近的数</span></span><br><span class="line">       treeMap1.remove(<span class="number">1</span>);</span><br><span class="line">       System.out.println(treeMap1.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>链表的定义就和递归很像，所以要</p>
</blockquote>
<ul>
<li><p>单链表结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Node&lt;V&gt; &#123;</span><br><span class="line">  V value;</span><br><span class="line">  Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CLass Node&lt;V&gt;&#123;</span><br><span class="line">  V value;</span><br><span class="line">  Node next;</span><br><span class="line">  Node last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><blockquote>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>LeetCode(hot 100) 160</p>
</blockquote>
<p><strong>循环遍历法</strong></p>
<p>假设 A 链表和 B 链表相交，A 的非相交部分长 a，B 的非相交部分长为 b，A 和 B 的相交部分长 c，则让 A 和 B 同时开始遍历，当 A 遍历结束时让指针指向 B， B 遍历结束时让指针指向 A，这样，a + c + b &#x3D; b + c + a，会在相交点相遇。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pa</span> <span class="operator">=</span> headA, pb = headB;</span><br><span class="line">        <span class="keyword">while</span> (pa != pb) &#123;</span><br><span class="line">            pa = pa == <span class="literal">null</span> ? headB : pa.next;</span><br><span class="line">            pb = pb == <span class="literal">null</span> ? headA : pb.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="链表简单算法"><a href="#链表简单算法" class="headerlink" title="链表简单算法"></a>链表简单算法</h3><ul>
<li><p>反转单链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>; <span class="comment">// 这一步其实只是为了第一个节点不成环</span></span><br><span class="line">        <span class="keyword">return</span> newHead; <span class="comment">// 这个是递归尾到头传递的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>反转双链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 打印两个有序链表的公共部分</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>快慢指针：获取链表的中间节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快指针一次走两步，慢指针一次走一步，快指针走完时慢指针走到了终点</span></span><br><span class="line"><span class="comment">//注意要分奇偶等边界条件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除特定节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125; </span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="判断链表是否回文"><a href="#判断链表是否回文" class="headerlink" title="判断链表是否回文"></a>判断链表是否回文</h3><blockquote>
<p>给定一个单链表的头节点，请判断该链表是否为回文结构<br>回文结构：正序和逆序相同<br>时间复杂度O（N），空间复杂度O（1）</p>
<p>判断回文常用栈来辅助，但为了追求空间复杂度最小，可以使用一定技巧<br>首先使用快慢指针让慢指针走到中点，然后快指针往回走同时再来一个指针从头走，走一步判断一步是否相等即可</p>
</blockquote>
<ul>
<li><p>方法一：借用栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindorme1</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">//声明一个辅助栈空间</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.value != stack.pop().value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>方法二：快慢指针法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome2</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//声明2个快慢指针</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="comment">//让慢指针指向中间</span></span><br><span class="line">       <span class="keyword">while</span> (n2.next != <span class="literal">null</span> &amp;&amp; n2.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">           n1 = n1.next;</span><br><span class="line">           n2 = n2.next.next;</span><br><span class="line">       &#125;</span><br><span class="line">       n2 = n1.next;</span><br><span class="line">       n1.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="comment">//反转后半段</span></span><br><span class="line">       <span class="keyword">while</span> (n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           n3 = n2.next;</span><br><span class="line">           n2.next = n1;</span><br><span class="line">           n1 = n2;</span><br><span class="line">           n2 = n3;</span><br><span class="line">       &#125;</span><br><span class="line">       n3 = n1;</span><br><span class="line">       n2 = head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//判断是否回文</span></span><br><span class="line">       <span class="keyword">while</span> (n1 != <span class="literal">null</span> &amp;&amp; n2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (n1.value != n2.value) &#123;</span><br><span class="line">               res = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           n1 = n1.next;</span><br><span class="line">           n2 = n2.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//把右边再逆序回来</span></span><br><span class="line">       n1 = n3.next;</span><br><span class="line">       n3.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (n1 != <span class="literal">null</span>)&#123;</span><br><span class="line">           n2 = n1.next;</span><br><span class="line">           n1.next = n3;</span><br><span class="line">           n3 = n1;</span><br><span class="line">           n1 = n2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="划分单链表"><a href="#划分单链表" class="headerlink" title="划分单链表"></a>划分单链表</h3><blockquote>
<p>将单链表按某值划分为左边小、中间相等、右边大的形式。<br>给定一个单链表的头节点head，节点值类型是整形，再给定一个整数pivot，实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右边大于的形式，并且要求相对次序不变。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">listPatition</span><span class="params">(Node head, <span class="type">int</span> pivot)</span> &#123;</span><br><span class="line">        <span class="comment">//分别声明小于区域、大于区域和等于区域的头尾指针</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">sH</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">sT</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">eH</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">eT</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mT</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//存放next指针</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//加下来遍历链表进行操作</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (head.value &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sH == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sH = head;</span><br><span class="line">                    sT = head;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    sT.next = head;</span><br><span class="line">                    sT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eH == <span class="literal">null</span>) &#123;</span><br><span class="line">                    eH = head;</span><br><span class="line">                    eT = head;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    eT.next = head;</span><br><span class="line">                    eT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mH == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mH = head;</span><br><span class="line">                    mT = head;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    mT.next = head;</span><br><span class="line">                    mT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断有没有小于、等于和大于区域</span></span><br><span class="line">        <span class="keyword">if</span> (sT != <span class="literal">null</span>) &#123;</span><br><span class="line">            sT.next = eH;</span><br><span class="line">            eT = eT == <span class="literal">null</span> ? sT : eT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (eT != <span class="literal">null</span>) &#123;</span><br><span class="line">            eT.next = mH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  sH != <span class="literal">null</span> ? sH : (eH != <span class="literal">null</span> ? eH : mH);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="随机指针节点"><a href="#随机指针节点" class="headerlink" title="随机指针节点"></a>随机指针节点</h3><blockquote>
<p>复制含有随机指针节点的链表</p>
<p>一种特殊的单链表节点如下：</p>
<p>class Node {<br>int value;<br>Node next;<br>Node rand;<br>Node(int val){<br>value &#x3D; val’<br>    }<br>}</p>
<p>rand指针是单链表结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null，给丁一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数实现这个链表的复制，并返回复制的新链表的头节点，这个复制的链表和原链表相同，包括rand指针。<br>时间复杂度 O（N），空间复杂度 O（1）</p>
<p>分析：如果借用额外空间，可以使用HashMap，首先遍历链表，每次遍历都copy节点到HashMap里，遍历结束后开始处理新链表的指向问题，第一个节点的next指向的节点可以通过map中get方法或，其rand指针同理获取。</p>
</blockquote>
<ul>
<li><p>使用map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NodeR <span class="title function_">copyRandomList</span><span class="params">(NodeR head)</span> &#123;</span><br><span class="line">        <span class="comment">//key是老节点，value是新节点</span></span><br><span class="line">        HashMap&lt;NodeR, NodeR&gt; mapR = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;NodeR, NodeR&gt;();</span><br><span class="line">        <span class="type">NodeR</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            mapR.put(cur, <span class="keyword">new</span> <span class="title class_">NodeR</span>(cur.value));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            mapR.get(cur).next = mapR.get(cur.next);</span><br><span class="line">            mapR.get(cur).rand = mapR.get(cur.rand);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mapR.get(head);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不用map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NodeR <span class="title function_">copyRandomList2</span><span class="params">(NodeR head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NodeR</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">NodeR</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">NodeR</span>(cur.value);</span><br><span class="line">            cur.next.next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="type">NodeR</span> <span class="variable">curCopy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = cur.next.next;</span><br><span class="line">            curCopy = cur.next;</span><br><span class="line">            cur.next = next;</span><br><span class="line">            curCopy.next = next != <span class="literal">null</span> ? next.next : <span class="literal">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NodeR</span> <span class="variable">res</span> <span class="operator">=</span> head.next;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = cur.next.next;</span><br><span class="line">            curCopy = cur.next;</span><br><span class="line">            cur.next = next;</span><br><span class="line">            curCopy.next = next != <span class="literal">null</span> ? next.next : <span class="literal">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><blockquote>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p>LeetCode 141 (hot100)</p>
</blockquote>
<blockquote>
<p>两种思路：</p>
<p>思路一：借用HashSet，遍历链表，同时将遍历到的节点加入到set中，set有天然判断重复的功能，所以如果一个链表有环那么第一个爆出false的添加的节点就是入环节点。</p>
<p>思路二：快慢指针法，快节点一次走两步，慢节点一次走一步，如果一个链表有环，那么快慢指针一定会相遇，当他们第一次相遇时，快指针回到头节点，然后快慢指针都以一步的速度同时移动，相遇的节点就是入环节点。</p>
</blockquote>
<ul>
<li><p>HashSet法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getLoopNode1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!set.add(cur))&#123;</span><br><span class="line">               <span class="keyword">return</span> cur;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快慢指针法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="相交链表-1"><a href="#相交链表-1" class="headerlink" title="相交链表"></a>相交链表</h3><blockquote>
<p>两个单链表相交的一系列问题</p>
<p>给定两个有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点，如果不相交返回null。相交：即有公共节点，指向同一个节点</p>
<p>如果两个链表的长度之和为N，时间复杂度请达到O（N），空间复杂度O（1）</p>
<p>分析：如果是两个无环单链表相交，那么不会出现X状，只会出现Y状和V状<br>方法一：首先遍历两个链表，得到来个链表的长度，然后比较两个链表的end节点是不是指向同一片内存空间（因为从分析中可知，要么Y要么V状），如果没有指向同一片存储空间，那么第三步是让长的那个链表走差值步，然后再共同走</p>
</blockquote>
<ul>
<li><p>当两个无环链表相交时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无环情况下找公共节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">noLoop</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head1;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> head2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//长度差值</span></span><br><span class="line">        <span class="keyword">while</span> (cur1.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点不同一定不相交</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">//将较长的那个链表的头节点赋值给cur1</span></span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1; <span class="comment">//将短的那个链表的头节点赋值给cur2</span></span><br><span class="line">        n = Math.abs(n); <span class="comment">//求出n绝对值</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123; <span class="comment">//长链表先走n</span></span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有环时</p>
<ul>
<li>不存在一个有环单链表和无环单链表相交</li>
<li>两个链表都有环：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getLoopNode1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(cur))&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getLoopNode2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;<span class="comment">//让快指针先迈出两步，否则while条件不好写</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="comment">//此if来判断是否有环</span></span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="literal">null</span> || slow.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//无环情况下找公共节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">noLoop</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head1;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> head2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//长度差值</span></span><br><span class="line">        <span class="keyword">while</span> (cur1.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点不同一定不相交</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">//将较长的那个链表的头节点赋值给cur1</span></span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1; <span class="comment">//将短的那个链表的头节点赋值给cur2</span></span><br><span class="line">        n = Math.abs(n); <span class="comment">//求出n绝对值</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123; <span class="comment">//长链表先走n</span></span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head1;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> head2;</span><br><span class="line">        <span class="keyword">if</span> (loop1 == loop2) &#123; <span class="comment">//入环节点相等，就变成了无环算法</span></span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur1.next != loop1) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2.next != loop2) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> loop1;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主调用函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">loop1</span> <span class="operator">=</span> getLoopNode1(head1);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">loop2</span> <span class="operator">=</span> getLoopNode1(head1);</span><br><span class="line">        <span class="keyword">if</span> (loop1 == <span class="literal">null</span> &amp;&amp; loop2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loop1 != <span class="literal">null</span> &amp;&amp; loop2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="合并两个增序链表"><a href="#合并两个增序链表" class="headerlink" title="合并两个增序链表"></a>合并两个增序链表</h3><blockquote>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</a></p>
</blockquote>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">       <span class="comment">//递归</span></span><br><span class="line">       <span class="keyword">if</span> (list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">           list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>迭代</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">prehead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> prehead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="复杂链表深拷贝"><a href="#复杂链表深拷贝" class="headerlink" title="复杂链表深拷贝"></a>复杂链表深拷贝</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-29%2015.40.12.png" alt="截屏2022-08-29 15.40.12" style="zoom:50%;" />







<p><strong>哈希表法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>回溯+哈希</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Node, Node&gt; ans = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ans.containsKey(head)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            ans.put(head, temp);</span><br><span class="line">            temp.next = copyRandomList(head.next);</span><br><span class="line">            temp.random = copyRandomList(head.random);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> <strong>拆分法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            tmp.next = cur.next;</span><br><span class="line">            cur.next = tmp;</span><br><span class="line">            cur = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="literal">null</span>)</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">        cur = head.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><h3 id="检查替换后的单词是否有效"><a href="#检查替换后的单词是否有效" class="headerlink" title="检查替换后的单词是否有效"></a>检查替换后的单词是否有效</h3><blockquote>
<p>给你一个字符串 <code>s</code> ，请你判断它是否 <strong>有效</strong> 。</p>
<p>字符串 <code>s</code> <strong>有效</strong> 需要满足：假设开始有一个空字符串 <code>t = &quot;&quot;</code> ，你可以执行 <strong>任意次</strong> 下述操作将 <code>t</code> <strong>转换为</strong> <code>s</code> ：</p>
<ul>
<li>将字符串 <code>&quot;abc&quot;</code> 插入到 <code>t</code> 中的任意位置。形式上，<code>t</code> 变为 <code>tleft + &quot;abc&quot; + tright</code>，其中 <code>t == tleft + tright</code> 。注意，<code>tleft</code> 和 <code>tright</code> 可能为 <strong>空</strong> 。</li>
</ul>
<p>如果字符串 <code>s</code> 有效，则返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p>LeetCode 1003 (medium)</p>
</blockquote>
<p><strong>栈</strong></p>
<p>这题经典之处在于，很好的诠释了栈是一个概念，并不是所有的先入后出的模型都必须使用stack 结构，这题用动态字符即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            stk.append(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (stk.length() &gt;= <span class="number">3</span> &amp;&amp; stk.substring(stk.length() - <span class="number">3</span>).equals(<span class="string">&quot;abc&quot;</span>)) &#123;</span><br><span class="line">                stk.delete(stk.length() - <span class="number">3</span>, stk.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="判断入栈出栈序列"><a href="#判断入栈出栈序列" class="headerlink" title="判断入栈出栈序列"></a>判断入栈出栈序列</h3><blockquote>
<p>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/validate-stack-sequences%E3%80%82">https://leetcode.cn/problems/validate-stack-sequences。</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">      Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pushed.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          stack.push(pushed[i]);</span><br><span class="line">          <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[j]) &#123;</span><br><span class="line">              stack.pop();</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="下一个更大的元素（1）"><a href="#下一个更大的元素（1）" class="headerlink" title="下一个更大的元素（1）"></a>下一个更大的元素（1）</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-01%2011.23.03.png" alt="截屏2022-09-01 11.23.03" style="zoom:50%;" />



<p><strong>单调栈+HashMap</strong></p>
<p>只要看到<strong>下一个更大</strong>这种关键字，基本上就要使用单调栈<br>主要思路是：将问题拆分成两个子问题：一个是如何快速找到某个数的右侧第一个更大的数，另一个问题是如何将这个数与nums1的关系保存下来。<br>所以借助单调栈来解决问题1，借助一个map解决问题2<br>从后往前遍历nums2，如果栈空，或者nums2的当前遍历到的元素比栈的栈顶元素大，就弹出栈顶元素，因为当前元素的右侧第一个比他大的元素一定不是栈顶元素了，一直持续这个逻辑直到栈空或者找到比他大的元素，然后继续遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums2[i];</span><br><span class="line">          <span class="comment">// 栈空或者比栈顶大就弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt; stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 说明找到了或者没找到比他大的元素</span></span><br><span class="line">            map.put(num, stack.isEmpty() ? -<span class="number">1</span> : stack.peek());</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            ans[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="商品折扣后价格"><a href="#商品折扣后价格" class="headerlink" title="商品折扣后价格"></a>商品折扣后价格</h3><blockquote>
<p>给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。</p>
<p>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;&#x3D; prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。</p>
<p>请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop">https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop</a></p>
</blockquote>
<p><strong>单调栈</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] finalPrices(<span class="type">int</span>[] prices) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; prices[i] &lt; stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = stack.isEmpty() ? prices[i] : prices[i] - stack.peek();</span><br><span class="line">            stack.push(prices[i]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><blockquote>
<p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p>LeetCode 739 (hot 100)</p>
</blockquote>
<p><strong>单调栈–自己写的</strong></p>
<p>第一次自己一次行写出单调栈的方法，哪怕写的再丑，也要纪念一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temperatures[i] &gt;= temperatures[stack.peek()]) &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                        ans[i] = idx - i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是明显可以优化一下，新手写的代码就是丑，而且多余，包括ans初始赋0，都是多余的<br>并且逻辑上可以采用从前往后遍历的方式，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前遍历的元素比栈中元素大，说明当前元素是栈中元素的下一个更大元素，即弹出栈</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">preIdx</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                ans[preIdx] = i - preIdx;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="下一个更大的节点"><a href="#下一个更大的节点" class="headerlink" title="下一个更大的节点"></a>下一个更大的节点</h3><blockquote>
<p>给定一个长度为 <code>n</code> 的链表 <code>head</code></p>
<p>对于列表中的每个节点，查找下一个 <strong>更大节点</strong> 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 <strong>严格大于</strong> 它的值。</p>
<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个节点( <strong>从1开始</strong> )的下一个更大的节点的值。如果第 <code>i</code> 个节点没有下一个更大的节点，设置 <code>answer[i] = 0</code> 。</p>
<p>LeetCode(1019)</p>
</blockquote>
<p><strong>关于单调栈</strong></p>
<blockquote>
<p>关于单调栈，主要就是维护用移动最少元素的代价来维护一个单调的栈，比如给定一个数组 [4, 3, 1, 8], 我们需要求每一个元素的下一个比他大的元素，就可以从右往左遍历数组并维护一个底大顶小的单调栈，例如当遍历到 3 时发现栈顶是 1，小于3，那就把 1 弹出，不需要了，因为 3 之前的元素的下一个最大元素不可能是 1.</p>
</blockquote>
<p><strong>方法一： 经典单调栈写法</strong></p>
<p>为了做到能从后往前遍历单链表，可以采用递归算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] ans;</span><br><span class="line">    <span class="comment">// 单调栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        f(head, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(ListNode node, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="title class_">int</span>[i];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不断的向后遍历，在递归返回的时候才开始操作</span></span><br><span class="line">        f(node.next, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将栈中比当前元素小的都弹出，因为是无效的元素了</span></span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; st.peek() &lt;= node.val) &#123;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span> (!st.isEmpty()) &#123;</span><br><span class="line">            ans[i] = st.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想用递归，那就<strong>反转链表</strong>再从头遍历也行</p>
<p><strong>方法二：用每个数更新其他数的下一个更大元素</strong></p>
<p>方法一是从后往前遍历，也可以从前往后遍历，每次遍历都将该元素加到栈内，例如栈内元素是 3，2，下一个是 4，那么 3 和 2都可以弹出，因为下一个更大元素一定是4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// 首先求链表的长度来生命 ans 数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 既保存数又保存该数的下标</span></span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">            <span class="comment">// 这个逻辑可以保证当栈内有不止一个元素时是递减的</span></span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; st.peek()[<span class="number">0</span>] &lt; p.val) &#123;</span><br><span class="line">                ans[st.pop()[<span class="number">1</span>]] = p.val;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;p.val, i++&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong></p>
<p>栈内直接存下标，并且把每次遍历到的复合条件的元素直接存到 ans 中，方便修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; ans[st.peek()] &lt; p.val) &#123;</span><br><span class="line">                ans[st.pop()] = p.val;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">            <span class="comment">// 将当前遍历到的元素存入 ans，方便下次比较</span></span><br><span class="line">            ans[i++] = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> idx : st) &#123;</span><br><span class="line">            ans[idx] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="和至少为-K-的最短子数组"><a href="#和至少为-K-的最短子数组" class="headerlink" title="和至少为 K 的最短子数组"></a>和至少为 K 的最短子数组</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-01%2016.04.03.png" alt="截屏2022-11-01 16.04.03" style="zoom:50%;" />

<p><strong>单调队列 + 前缀和</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ans = n + <span class="number">1</span>;</span><br><span class="line">      <span class="type">long</span>[] s = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 初始化前缀和数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          s[i + <span class="number">1</span>] = s[i] + nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> s[i];</span><br><span class="line">          <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; cur - s[q.peekFirst()] &gt;= k) &#123;</span><br><span class="line">              ans = Math.min(ans, i - q.pollFirst());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; s[q.peekLast()] &gt;= cur) &#123;</span><br><span class="line">              q.pollLast();</span><br><span class="line">          &#125; </span><br><span class="line">          q.addLast(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans &gt; n ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





















<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><hr>
<h2 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h2><blockquote>
<p>二叉树节点结构：</p>
<p>Class Node<V> {<br>V value;<br>Node left;<br>Node right;<br>}</p>
</blockquote>
<h3 id="二叉树递归遍历"><a href="#二叉树递归遍历" class="headerlink" title="二叉树递归遍历"></a>二叉树递归遍历</h3><p>对于以下一颗二叉树</p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/d928190de56e10b7e5f2e009ca334102.jpeg" alt="d928190de56e10b7e5f2e009ca334102" style="zoom:50%;" />

<p>在计算机中从头节点用以下代码开始遍历的完整递归步骤是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fun(head.left);</span><br><span class="line">  fun(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序底层中的递归步骤是：</p>
<p>1、2、4、4、4、2、5、5、5、2、1、3、6、6、6、3、7、7、7、3、1<br>因为在遍历到4时会继续遍历4的左子树，为null，然后return，回到4，继续遍历4的右子树，如上步骤，会三次遍历到4这个节点，但是只有一次会对他进行操作，而前序遍历、中序遍历、后序遍历就是对节点进行操作的时机不同。</p>
<ul>
<li>先序遍历：1、2、4、5、3、6、7<br>就是在上述步骤中对第一次访问到的节点进行操作，第二次、第三次不操作的结果</li>
<li>中序遍历：4、2、5、1、6、3、7<br>就是在上述步骤中对第二次访问到的节点进行操作，第一次、第三次不操作</li>
<li>后序遍历：4、5、2、6、7、3、1<br>就是在上述步骤中对第三次访问到的节点进行操作，第一次、第二次不操作</li>
</ul>
<p><strong>先序遍历代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderRecur</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);<span class="comment">//在第一笔遍历到节点时打印值</span></span><br><span class="line">        preOrderRecur(head.left);</span><br><span class="line">        preOrderRecur(head.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderRecur</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderRecur(head.left);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);<span class="comment">//在第二次遍历到节点时打印值</span></span><br><span class="line">        inOrderRecur(head.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">posOrderRecur</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        posOrderRecur(head.left);</span><br><span class="line">        posOrderRecur(head.right);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);<span class="comment">//在最后一次遍历到节点时打印值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="二叉树非递归遍历"><a href="#二叉树非递归遍历" class="headerlink" title="二叉树非递归遍历"></a>二叉树非递归遍历</h3><blockquote>
<p>使用栈来辅助遍历二叉树</p>
</blockquote>
<p><strong>先序遍历</strong><br>按头右左顺序压入栈中，再弹出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderUnRecur</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;BinaryNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            stack.add(head);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value);</span><br><span class="line">                <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack.push(head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack.push(head.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong>中序遍历</strong><br>一开始整棵树左边界进栈，依次弹出的过程中打印，并对弹出节点的右树进栈（且每次右子树进栈前左子树也要进）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderUnRecur</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">           Stack&lt;BinaryNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="literal">null</span>) &#123; <span class="comment">// 只有栈空且此时的节点指针也为空时才会停止循环</span></span><br><span class="line">               <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123; <span class="comment">// 首先判断当前节点指针是否为空</span></span><br><span class="line">                   stack.push(head); <span class="comment">//如果当前节点不空，那就先压入栈再说</span></span><br><span class="line">                   head = head.left; <span class="comment">// 压入栈的节点优先继续判断其左节点</span></span><br><span class="line">               &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">                   head = stack.pop(); <span class="comment">//如果当前节点指针为空那就开始弹出栈的元素</span></span><br><span class="line">                   System.out.print(head.value + <span class="string">&quot; &quot;</span>); <span class="comment">// 对元素技能型操作</span></span><br><span class="line">                   head = head.right; <span class="comment">// 走到这个else的节点一定是左节点为空的节点，所以开始判断其右节点</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<p><strong>后序遍历</strong><br>准备两个栈，第一个栈按根左右顺序压入，每次弹出后压入第二个栈，结束后第二个栈的弹出顺序即为后序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">posOrderUnRecur</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;BinaryNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            Stack&lt;BinaryNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            stack1.push(head);</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                head = stack1.pop();</span><br><span class="line">                stack2.push(head);</span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack1.push(head.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack1.push(head.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">                System.out.print(stack2.pop().value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p>LeetCode(102) hot 100</p>
</blockquote>
<p><strong>分析</strong></p>
<p>此题稍微有些不同的是，返回的结果需要按层打印，所以在到新的一层时需要先拿到当前队列的size，即当前层的宽度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                cur.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125; </span><br><span class="line">            ans.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树宽度遍历"><a href="#二叉树宽度遍历" class="headerlink" title="二叉树宽度遍历"></a>二叉树宽度遍历</h3><p><strong>宽度优先遍历</strong></p>
<blockquote>
<p>二叉树的先序遍历就是二叉树的深度优先遍历，宽度优先遍历也就是二叉树层序遍历</p>
<p>思想：利用一个队列，头进尾出，每一次弹出就打印，先放左子树再放又子树，周而复始</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">widthTra</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        双向链表可以做队列</span></span><br><span class="line">        Queue&lt;BinaryNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">BinaryNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(cur.value);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong>求一颗二叉树的最大宽度</strong></p>
<blockquote>
<p>求一个二叉树的最大宽度即求一个二叉树所有层中节点数最多的那一层的节点数</p>
<p>即需要知道一个二叉树有几层，且每一层有几个节点，所以在层序遍历的基础上记录每一层的节点个数</p>
</blockquote>
<p><strong>借助哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxWidth</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        HashMap&lt;BinaryNode, Integer&gt; levelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        levelMap.put(head, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">curLevel</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 当前所在层</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curLevelNodes</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//当前层数到的节点数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;<span class="comment">//最大层节点数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">BinaryNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">curNodeLevel</span> <span class="operator">=</span> levelMap.get(cur);</span><br><span class="line">            <span class="keyword">if</span> (curNodeLevel == curLevel) &#123;</span><br><span class="line">                curLevelNodes++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, curLevelNodes);</span><br><span class="line">                curLevel++;</span><br><span class="line">                curLevelNodes = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                levelMap.put(cur.left, curNodeLevel+<span class="number">1</span>);</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                levelMap.put(cur.right, curNodeLevel+<span class="number">1</span>);</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>不用哈希表：P7最后</strong></p>
<h3 id="判断搜索二叉树"><a href="#判断搜索二叉树" class="headerlink" title="判断搜索二叉树"></a>判断搜索二叉树</h3><blockquote>
<p>如何判断一课树是否是搜索二叉树</p>
<p>搜索二叉树：对于跟节点来说，其左树都比根节点小，右树都比根节点大（经典搜索二叉树是没有重复值的）</p>
<p>思路：中序遍历，（没有重复值）如果是升序的话就是一棵搜索二叉树</p>
</blockquote>
<p><strong>中序遍历法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">preValue</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkBST</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeftBst</span> <span class="operator">=</span> checkBST(head.left);</span><br><span class="line">        <span class="keyword">if</span> (!isLeftBst) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt;= preValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            preValue = head.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkBST(head.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>递归实现(树形DP）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是搜索二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReturnData</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isBst;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> min;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReturnData</span><span class="params">(<span class="type">boolean</span> is, <span class="type">int</span> mi, <span class="type">int</span> ma)</span> &#123;</span><br><span class="line">            isBst = is;</span><br><span class="line">            min = mi;</span><br><span class="line">            max = ma;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title function_">process</span><span class="params">(BinaryNode x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReturnData</span> <span class="variable">leftData</span> <span class="operator">=</span> process(x.left);</span><br><span class="line">        <span class="type">ReturnData</span> <span class="variable">rightData</span> <span class="operator">=</span> process(x.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> x.value;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> x.value;</span><br><span class="line">        <span class="keyword">if</span> (leftData != <span class="literal">null</span>) &#123;</span><br><span class="line">            min = Math.min(min, leftData.min);</span><br><span class="line">            max = Math.max(max, rightData.max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightData != <span class="literal">null</span>) &#123;</span><br><span class="line">            min = Math.min(min, leftData.min);</span><br><span class="line">            max = Math.max(max, rightData.max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isBst</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftData != <span class="literal">null</span> &amp;&amp; (!leftData.isBst || leftData.max &gt;= x.value)) &#123;</span><br><span class="line">            isBst = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightData != <span class="literal">null</span> &amp;&amp; (!rightData.isBst || rightData.min &lt;= x.value)) &#123;</span><br><span class="line">            isBst = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnData</span>(isBst, min, max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h3><blockquote>
<p>思路：<br>在宽度遍历二叉树的过程中，有如下情况：</p>
<ol>
<li>某一节点有右孩子没有左孩子，则返回false</li>
<li>在条件1不违规的情况下，遇到了第一个左右孩子不双全的情况，那么接下来的所有节点都必须是叶子节点，否则返回false</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCBT</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        LinkedList&lt;BinaryNode&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(head);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//此为判断事件，是否遇到了左右孩子不双全的情况</span></span><br><span class="line">        <span class="type">BinaryNode</span> <span class="variable">l</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BinaryNode</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            head = list.poll();</span><br><span class="line">            l = head.left;</span><br><span class="line">            r = head.right;</span><br><span class="line">            <span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="literal">null</span> || r != <span class="literal">null</span>)) <span class="comment">//遇到过左右孩子不双全的节点且其不为叶节点</span></span><br><span class="line">                    ||</span><br><span class="line">                    (l == <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>))&#123; <span class="comment">//右节点不为空且左节点为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">                list.add(l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                list.add(r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="literal">null</span> || r == <span class="literal">null</span>) &#123;</span><br><span class="line">                leaf =<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h3><blockquote>
<p>思路：递归<br>左树是平衡的，右树也是平衡的，且左树右树的高度叉</p>
<p>此思路适用于一切树形dp问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsBalanceTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReturnType</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isBalanced;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReturnType</span><span class="params">(<span class="type">boolean</span> isB, <span class="type">int</span> hei)</span> &#123;</span><br><span class="line">            isBalanced = isB;</span><br><span class="line">            height = hei;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReturnType <span class="title function_">process</span><span class="params">(BinaryNode x)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(<span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">ReturnType</span> <span class="variable">leftData</span> <span class="operator">=</span> process(x.left);</span><br><span class="line">         <span class="type">ReturnType</span> <span class="variable">rightData</span> <span class="operator">=</span> process(x.right);</span><br><span class="line">         <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftData.height, rightData.height) + <span class="number">1</span>;</span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isBalanced</span> <span class="operator">=</span> leftData.isBalanced &amp;&amp; rightData.isBalanced</span><br><span class="line">                              &amp;&amp; Math.abs(leftData.height - rightData.height) &lt; <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(isBalanced, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBanlanced</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(head).isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>自顶向下的递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> Math.abs(process(root.left) - process(root.right)) &lt;= <span class="number">1</span> </span><br><span class="line">            &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(process(root.left), process(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>自下而上的递归(效率更高）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> height(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> height(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h3 id="判断满二叉树"><a href="#判断满二叉树" class="headerlink" title="判断满二叉树"></a>判断满二叉树</h3><blockquote>
<p>树形dp的问题一定要满足向左右子树询问信息是一样的情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">(BinaryNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">data</span> <span class="operator">=</span> process(head);</span><br><span class="line">        <span class="comment">//如果是满二叉树满足nodes = 2的高度次方 -1</span></span><br><span class="line">        <span class="keyword">return</span> data.nodes == (<span class="number">1</span> &lt;&lt; data.height - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> nodes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> hei, <span class="type">int</span> no)</span> &#123;</span><br><span class="line">            height = hei;</span><br><span class="line">            nodes = no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title function_">process</span><span class="params">(BinaryNode x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">leftData</span> <span class="operator">=</span> process(x.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">rightData</span> <span class="operator">=</span> process(x.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftData.height, rightData.height) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nodes</span> <span class="operator">=</span> leftData.nodes + rightData.nodes + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(height, nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="公共祖先节点"><a href="#公共祖先节点" class="headerlink" title="公共祖先节点"></a>公共祖先节点</h3><blockquote>
<p>题目：给定两个Node1和Node2，找到他们的最低公共祖先节点,这两个节点一定属于head为头节点的树</p>
<p>思路：</p>
<ol>
<li>麻烦一点的：先生成所有节点的父节点的map，然后用一个set获得两个节点其中一个的父节点表，另外一个节点往上走，看其父节点在set中存不存在，第一个存在的就是最低的祖先节点</li>
<li>代码简单，但是不好理解：<br>最低公共祖先有以下几种情况<ol>
<li>o1或o2一个是另外一个的祖先</li>
<li>o1和o2彼此不是对方的祖先</li>
</ol>
</li>
</ol>
</blockquote>
<p><strong>简单方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">lowerAncestor</span><span class="params">(Node head, Node o1, Node o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head ==o1 || head == o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> lowerAncestor(head.left, o1, o2);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> lowerAncestor(head.right, o1, o2);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树某一和路径"><a href="#二叉树某一和路径" class="headerlink" title="二叉树某一和路径"></a>二叉树某一和路径</h3><blockquote>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p>
</blockquote>
<p><strong>深度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        dfs(root, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.offerLast(node.val);</span><br><span class="line">        target -= node.val;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left, target);</span><br><span class="line">        dfs(node.right, target);</span><br><span class="line">        path.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>广度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TreeNode, TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queueSum = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queueNode.offer(root);</span><br><span class="line">        queueSum.offer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queueNode.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queueNode.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rec</span> <span class="operator">=</span> queueSum.poll() + node.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rec == target) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(node.left, node);</span><br><span class="line">                    queueNode.offer(node.left);</span><br><span class="line">                    queueSum.offer(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(node.right, node);</span><br><span class="line">                    queueNode.offer(node.right);</span><br><span class="line">                    queueSum.offer(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPath</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.add(node.val);</span><br><span class="line">            node = map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(temp);</span><br><span class="line">        ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(temp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><blockquote>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
<p>LeetCode 617 (hot 100)</p>
</blockquote>
<p><strong>深度优先</strong></p>
<p>我们可以做如下思考：我们按中序遍历的顺序同步遍历两棵树，然后创建新节点，并对新节点的值进行操作，然后将新节点的左右分支的情况寄托于下一次调用，在调用返回时将其节点返回，这种调用流程很明显适合使用递归调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// base case, 只要有一个为空就不用计算了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="comment">// 创建新节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        merged.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        merged.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>深度优先+在第一棵树上进行操作，不创建新节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        <span class="keyword">if</span> (root1.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            root1.left = root2.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeTrees(root1.left, root2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            root1.right = root2.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeTrees(root1.right, root2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>广度优先搜索</strong></p>
<p>代码比较麻烦，性能也不够优秀，仅作练习</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(merged);</span><br><span class="line">        queue1.offer(root1);</span><br><span class="line">        queue2.offer(root2);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left1</span> <span class="operator">=</span> node1.left, left2 = node2.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right1</span> <span class="operator">=</span> node1.right, right2 = node2.right;</span><br><span class="line">            <span class="keyword">if</span> (left1 != <span class="literal">null</span> || left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left1 != <span class="literal">null</span> &amp;&amp; left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left1.val + left2.val);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                    queue1.offer(left1);</span><br><span class="line">                    queue2.offer(left2);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.left = left1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.left = left2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right1 != <span class="literal">null</span> || right2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right1 != <span class="literal">null</span> &amp;&amp; right2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right1.val + right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                    queue1.offer(right1);</span><br><span class="line">                    queue2.offer(right2);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.right = right1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.right = right2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































<h2 id="二叉树操作"><a href="#二叉树操作" class="headerlink" title="二叉树操作"></a>二叉树操作</h2><h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h3><blockquote>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p>LeetCode 114 (hot 100)</p>
</blockquote>
<p><strong>左子树插到右子树</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 1 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"><span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">//将 2 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前根节点的右子树接到左子树最右节点的右子树上</span></span><br><span class="line">                pre.right = root.right;</span><br><span class="line">                <span class="comment">//将新左子树接到根节点的右子树上，并按要求将根节点的左子树设置为空</span></span><br><span class="line">                root.right = root.left;</span><br><span class="line">                root.left = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 继续循环操作</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>变形后序遍历</strong></p>
<p>题目展开的链表的顺序其实就是先序遍历，想着可以先序遍历的时候进行一些操作，把当前遍历到的节点接到前一个节点的右节点，但是这做不到，因为会导致 pre 节点的右节点丢失，所以可以反过来，将后续遍历变形，按照 右节点 - 左节点 - 根节点 的顺序去遍历，将当前节点的右指针更新为上一个节点，这样右节点就不会丢失了，因为已经访问过了</p>
<p><strong>非迭代版</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode pre;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        root.right = pre;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代版</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123; </span><br><span class="line">    Stack&lt;TreeNode&gt; toVisit = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !toVisit.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            toVisit.push(cur); <span class="comment">// 添加根节点</span></span><br><span class="line">            cur = cur.right; <span class="comment">// 递归添加右节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = toVisit.peek(); <span class="comment">// 已经访问到最右的节点了</span></span><br><span class="line">        <span class="comment">// 在不存在左节点或者右节点已经访问过的情况下，访问根节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="literal">null</span> || cur.left == pre) &#123;</span><br><span class="line">            toVisit.pop(); </span><br><span class="line">            <span class="comment">/**************修改的地方***************/</span></span><br><span class="line">            cur.right = pre;</span><br><span class="line">            cur.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">/*************************************/</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.left; <span class="comment">// 左节点还没有访问过就先访问左节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="找树最左节点"><a href="#找树最左节点" class="headerlink" title="找树最左节点"></a>找树最左节点</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-22%2016.05.34.png" alt="截屏2022-06-22 16.05.34" style="zoom:50%;" />

<p><strong>方法一 (推荐）</strong><br>深度优先遍历 + 记录最左节点值<br>深度优先遍历有一个特点：一定会最先遍历到每一层节点的最左节点，所以我们只需要声明两个值：curHeight 和 curValue 来记录遍历的高度和节点的value，在执行dfs的时候，在两次递归的后面加一个判断即可找到第一个左节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方法1 深度优先遍历 + 记录最左节点值</span></span><br><span class="line">        <span class="comment">//注：深度优先遍历有个特点：一定会最先遍历到每一层的最左节点</span></span><br><span class="line">        dfs(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> curValue;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         height++;</span><br><span class="line">         dfs(root.left, height);</span><br><span class="line">         dfs(root.right, height);</span><br><span class="line">         <span class="keyword">if</span> (height &gt; curHeight) &#123;</span><br><span class="line">             curHeight = height;</span><br><span class="line">             curValue = root.val;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>方法二</strong><br>广度优先搜索,和传统广度优先不同，这次先加右节点，这样最后一个节点的值一定是最后一层最左节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方法二：广度优先</span></span><br><span class="line">        <span class="comment">//改造一下，先加右节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            ans = cur.val;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h3><blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>LeetCode 543 (hot100)</p>
</blockquote>
<p><strong>深度优先</strong></p>
<p>统计遍历过的节点的节点个数，找到最大值 -1 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line">        ans = Math.max(ans, L + R + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(L, R) + <span class="number">1</span>; <span class="comment">// + 1是返回经过的节点个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="判断两树是否相同"><a href="#判断两树是否相同" class="headerlink" title="判断两树是否相同"></a>判断两树是否相同</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-28%2023.32.47.png" alt="截屏2022-06-28 23.32.47" style="zoom:50%;" />



<p><strong>方法一</strong><br>如果根节点都为空，那么就一定是相同的<br>如果根节点只有一个是空，那么就一定是不相同的，<br>如果值不相同，一定不相等<br>如果根节点都不为空，则开始递归到下一个节点，继续按这三个点来判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此方法中的判断分支写的很有意思 </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//方法一：递归</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong>方法二</strong><br>方法二借用队列来实现，每次加入两个节点<br>如果两个节点的值不同，返回false<br>如果两个节点的左节点同时存在，那就将这两个节点加入到节点<br>如果两个节点的左节点不同时存在，返回false<br>如果两个节点的左节点同时不存在，就继续判断右节点，右节点同理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       queue.offer(p);</span><br><span class="line">       queue.offer(q);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">cur1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">cur2</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           <span class="keyword">if</span> (cur1.val != cur2.val) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (cur1.left != <span class="literal">null</span> &amp;&amp; cur2.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               queue.offer(cur1.left);</span><br><span class="line">               queue.offer(cur2.left);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur1.left != <span class="literal">null</span> || cur2.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (cur1.right != <span class="literal">null</span> &amp;&amp; cur2.right != <span class="literal">null</span>) &#123;</span><br><span class="line">               queue.offer(cur1.right);</span><br><span class="line">               queue.offer(cur2.right);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur1.right != <span class="literal">null</span> || cur2.right != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<p><strong>利用此思想可以判断一颗二叉树是否对称</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSame(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(TreeNode l, TreeNode r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span> &amp;&amp; r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="literal">null</span> || r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l.val != r.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSame(l.left, r.right) &amp;&amp; isSame(l.right, r.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























<h3 id="判断树是否轴对称"><a href="#判断树是否轴对称" class="headerlink" title="判断树是否轴对称"></a>判断树是否轴对称</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-29%2000.10.35.png" alt="截屏2022-06-29 00.10.35" style="zoom:50%;" />





<p><strong>方法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       这一题可以借助判断两二叉树是不是相同的那一题的思想</span></span><br><span class="line"><span class="comment">       不同的是，这次两个工作指针的走向不同</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">return</span> process(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(TreeNode p1, TreeNode p2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span> &amp;&amp; p2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 == <span class="literal">null</span> || p2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.val == p2.val </span><br><span class="line">            &amp;&amp; process(p1.left, p2.right) </span><br><span class="line">            &amp;&amp; process(p1.right, p2.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="二叉树最大高度"><a href="#二叉树最大高度" class="headerlink" title="二叉树最大高度"></a>二叉树最大高度</h3><p><strong>思路一</strong><br>经典思路，声明两个变量，maxHeight 和 curHeight，再利用深度优先遍历，每次遍历到的节点判断当前高度是不是比最大高度大，是的话就赋值给最大高度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxheight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxheight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> curHeight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curHeight++;</span><br><span class="line">        maxheight = maxheight &gt; curHeight ? maxheight : curHeight;</span><br><span class="line">        dfs(root.left, curHeight);</span><br><span class="line">        dfs(root.right, curHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>思路二</strong><br>也还是利用深度优先以及递归，但是处理逻辑不同<br>将树的高度从下往上计算<br>某一个节点的高度取决于左右子树的高度中较大的那个再+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-30%2016.57.28.png" alt="截屏2022-06-30 16.57.28" style="zoom:50%;" />



<p><strong>自己写的垃圾深度优先代码</strong><br>虽然代码略长，但是速度很快</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minCount</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(TreeNode root, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            minCount = minCount &lt; count ? minCount : count;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            process(root.left, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            process(root.right, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>官方的简洁dfs代码</strong><br>虽然简洁，但是速度很慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minDep</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            minDep = Math.min(minDepth(root.left), minDep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            minDep = Math.min(minDepth(root.right), minDep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minDep + <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>广度优先思路</strong><br>二叉树广度优先即层序遍历，这种遍历的特点是遍历到的第一个叶子节点就是深度最低的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      queue.offer(root);</span><br><span class="line">      <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          height++;</span><br><span class="line">          <span class="type">int</span> <span class="variable">curSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; curSize; i++) &#123;</span><br><span class="line">              <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">              <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> height;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                  queue.offer(cur.left);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                  queue.offer(cur.right);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树目标路径和"><a href="#二叉树目标路径和" class="headerlink" title="二叉树目标路径和"></a>二叉树目标路径和</h3><p><strong>递归+中序遍历</strong><br>有关于树的操作几乎都涉及到遍历节点，那就躲不掉深度优先或广度优先遍历,每一题都需要根据题目的特殊性来量身定制再遍历时的一些操作<br>比如说这一题，在深度优先的时候，定制一下思路：分解问题规模：每到一个节点就判断从此节点到叶节点有没有满足target - sum的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) </span><br><span class="line">                    || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>广度优先+路径全记录</strong><br>解决此类问题毫无疑问还有一种百搭的方法就是利用广度优先搜索，记录从根节点到当前节点的路径和<br>这就需要声明两个队列，一个队列记录访问过的节点，另一个队列对应记录着根节点到此节点的路径和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125; </span><br><span class="line">     Queue&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 访问过的节点</span></span><br><span class="line">     Queue&lt;Integer&gt; nodeVal = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 访问过的节点的路径和</span></span><br><span class="line">     nodes.offer(root);</span><br><span class="line">     nodeVal.offer(root.val);</span><br><span class="line">     <span class="keyword">while</span> (!nodes.isEmpty()) &#123;</span><br><span class="line">         <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> nodes.poll(); <span class="comment">// 取出当前队列队头元素</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">curVal</span> <span class="operator">=</span> nodeVal.poll(); <span class="comment">// 取出其对应的路径和</span></span><br><span class="line">         <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) &#123; <span class="comment">// 当节点为叶子节点</span></span><br><span class="line">             <span class="keyword">if</span> (curVal == targetSum) &#123;  <span class="comment">// 且节点的路径和与目标一致</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//即刻返回true</span></span><br><span class="line">             &#125; </span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 否则继续循环</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">             nodes.offer(cur.left);</span><br><span class="line">             nodeVal.offer(cur.left.val + curVal); <span class="comment">// 路径和</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">             nodes.offer(cur.right);</span><br><span class="line">             nodeVal.offer(cur.right.val + curVal); <span class="comment">//路径和</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果循环结束都没有找到满足目标的节点，就返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="二叉树反转"><a href="#二叉树反转" class="headerlink" title="二叉树反转"></a>二叉树反转</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-04%2022.18.59.png" alt="截屏2022-07-04 22.18.59" style="zoom:50%;" />





<p><strong>递归思路</strong><br>递归的遍历每一个节点，从叶子节点开始，每次遍历到了就反转一次，这样的解决方式的逻辑基础是：<br>只要某个节点的两个子节点是反转好的，那么反转这两个子节点即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树节点最近祖先"><a href="#二叉树节点最近祖先" class="headerlink" title="二叉树节点最近祖先"></a>二叉树节点最近祖先</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-05%2017.57.51.png" alt="截屏2022-07-05 17.57.51" style="zoom:50%;" />





<p><strong>非递归方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; cur.val &amp;&amp; q.val &lt; cur.val) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; cur.val &amp;&amp; q.val &gt; cur.val) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>递归方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树所有路径"><a href="#二叉树所有路径" class="headerlink" title="二叉树所有路径"></a>二叉树所有路径</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-13%2014.57.24.png" alt="截屏2022-07-13 14.57.24" style="zoom:50%;" />





<p><strong>深度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        dfs(root, path, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, String path, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                path += root.val + <span class="string">&quot;&quot;</span>; <span class="comment">// 数字后面加一个空字符串即可完成数字与字符串的转换</span></span><br><span class="line">                ans.add(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path += root.val + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                dfs(root.left, path, ans);</span><br><span class="line">                dfs(root.right, path, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="左叶子节点和"><a href="#左叶子节点和" class="headerlink" title="左叶子节点和"></a>左叶子节点和</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-13%2017.20.46.png" alt="截屏2022-07-13 17.20.46" style="zoom:50%;" />



<p><strong>深度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : process(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            ans += isLeafNode(root.left) ? root.left.val : process(root.left); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; !isLeafNode(root.right)) &#123;</span><br><span class="line">            ans += process(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeafNode</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> root.left == <span class="literal">null</span> &amp;&amp; root .right == <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深度优先还有一种一行解决的简便形式</strong><br>其实最后一段的处理值的代码放在左递归和右递归的什么位置都是可以的<br>也就是说处理代码其实并不影响递归进程，因为所有的处理代码只会执行一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + </span><br><span class="line">        sumOfLeftLeaves(root.right) + </span><br><span class="line">        (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span> ?</span><br><span class="line">        root.left.val : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码的正常写法，用于体会递归</span></span><br><span class="line"><span class="comment">//class Solution &#123;</span></span><br><span class="line"><span class="comment">//     int sum = 0;</span></span><br><span class="line"><span class="comment">//     public int sumOfLeftLeaves(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//             return 0;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         dfs(root);</span></span><br><span class="line"><span class="comment">//         return sum;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     public void dfs(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//             return;</span></span><br><span class="line"><span class="comment">//         &#125; </span></span><br><span class="line"><span class="comment">//          if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123;</span></span><br><span class="line"><span class="comment">//             sum += root.left.val;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         sumOfLeftLeaves(root.left);</span></span><br><span class="line"><span class="comment">//         sumOfLeftLeaves(root.right);</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>









<h3 id="单值二叉树"><a href="#单值二叉树" class="headerlink" title="单值二叉树"></a>单值二叉树</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-26%2014.19.36.png" alt="截屏2022-07-26 14.19.36" style="zoom:50%;" />



<p><strong>简单易懂的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">preVal</span> <span class="operator">=</span> -<span class="number">999</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnivalTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preVal == -<span class="number">999</span>) &#123;</span><br><span class="line">            preVal = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val != preVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isUnivalTree(root.left) &amp;&amp; isUnivalTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>传统深度优先遍历</strong><br>较为难懂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnivalTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.val != root.left.val || !isUnivalTree(root.left)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.val != root.right.val || !isUnivalTree(root.right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="最大层内元素和"><a href="#最大层内元素和" class="headerlink" title="最大层内元素和"></a>最大层内元素和</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-31%2021.12.07.png" alt="截屏2022-07-31 21.12.07" style="zoom:50%;" />



<p><strong>广度优先</strong><br>广度优先一般使用队列Queue来实现，但是这里只是借用思想，并不一定需要使用队列，可以采用效率更高的链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLevelSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>, maxSum = root.val;</span><br><span class="line">        List&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>; !q.isEmpty(); ++level) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; nq = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : q) &#123;</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nq.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nq.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxSum) &#123;</span><br><span class="line">                maxSum = sum;</span><br><span class="line">                ans = level;</span><br><span class="line">            &#125;</span><br><span class="line">            q = nq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>深度优先</strong><br>在dfs的过程中，dfs(root.left, level + 1) 如果改成 level++ 或 ++level 会有问题，这个需要再仔细看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; visit = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLevelSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; visit.size(); ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span> (visit.get(i) &gt; visit.get(ans)) &#123;</span><br><span class="line">               ans = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level == visit.size()) &#123; <span class="comment">// 注意list的索引从0开始</span></span><br><span class="line">            visit.add(root.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visit.set(level, visit.get(level) + root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            dfs(root.left, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            dfs(root.right, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="重建无重复值树"><a href="#重建无重复值树" class="headerlink" title="重建无重复值树"></a>重建无重复值树</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-04%2017.44.47.png" alt="截屏2022-08-04 17.44.47" style="zoom:50%;" />



<p><strong>递归法</strong><br>前序遍历的第一个节点是二叉树的根节点，而我们拿着这个值在中序遍历里面拿到根节点的index后可以知道，index左边的节点是左子树，index右边的节点是右子树，由此，递归思想就可以得到应用。而在确定下一层递归的左右子树在遍历数组中的下标时，我们需要在拿到左右子树的数目，这样即可完成边界的确定。<br>而为了快速确定根节点在中序遍历数组中的位置，我们可以借助Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; buidTreeMap;<span class="comment">//为了在inorder中定位根节点的位置所创建的map</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        buidTreeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            buidTreeMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> </span><br><span class="line">            process(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, </span></span><br><span class="line"><span class="params">        <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得根节点的坐标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> preorder_left;</span><br><span class="line">         <span class="comment">//以先序遍历的第一个节点作为根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[rootIndex]);</span><br><span class="line">        <span class="comment">//在map中定位root节点在inorder中的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">inorderRootIndex</span> <span class="operator">=</span> buidTreeMap.get(preorder[rootIndex]);</span><br><span class="line">        <span class="comment">//得到左子树的数目</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSubTreeNums</span> <span class="operator">=</span> inorderRootIndex - inorder_left;</span><br><span class="line">        <span class="comment">//递归创建左子树</span></span><br><span class="line">        root.left = process(preorder, inorder, preorder_left + <span class="number">1</span>, </span><br><span class="line">            preorder_left + leftSubTreeNums, inorder_left, inorderRootIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归创建右子树</span></span><br><span class="line">        root.right = process(preorder, inorder, leftSubTreeNums + preorder_left + <span class="number">1</span>, </span><br><span class="line">            preorder_right, inorderRootIndex + <span class="number">1</span>, inorder_right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>迭代法</strong><br>迭代法很巧妙，但是理解难度高，可暂时忽略（copy官方）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="literal">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">preorderVal</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="在二叉树中加行"><a href="#在二叉树中加行" class="headerlink" title="在二叉树中加行"></a>在二叉树中加行</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-05%2015.09.24.png" alt="截屏2022-08-05 15.09.24" style="zoom:50%;" />



<p><strong>广度优先</strong><br>广度优先思路上比较简单，就是遍历到需要加行的上一层，将该层的所有节点的左右子节点全部换成以给定val为值的节点，这题在刚拿到手还有一个阻拦人的障碍点就是忽略了节点的构造方法，就是在构建新行的时候，可以直接将原行的左右节点加到构造方法里去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addOneRow</span><span class="params">(TreeNode root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, root, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TreeNode&gt; curLevel = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        curLevel.add(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; depth - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode cur : curLevel) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    temp.add(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    temp.add(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            curLevel = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode cur : curLevel) &#123;</span><br><span class="line">            cur.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, cur.left, <span class="literal">null</span>);</span><br><span class="line">            cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>深度优先遍历</strong><br>代码更加优雅，但是可能需要广度优先的铺垫才能看懂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addOneRow</span><span class="params">(TreeNode root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (depth == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, root, <span class="literal">null</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (depth == <span class="number">2</span>) &#123;</span><br><span class="line">           root.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, root.left, <span class="literal">null</span>);</span><br><span class="line">           root.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, root.right);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           addOneRow(root.left, val, depth - <span class="number">1</span>);</span><br><span class="line">           addOneRow(root.right, val, depth -<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="层数最深叶子和"><a href="#层数最深叶子和" class="headerlink" title="层数最深叶子和"></a>层数最深叶子和</h3><blockquote>
<p>给你一棵二叉树的根节点 <code>root</code> ，请你返回 <strong>层数最深的叶子节点的和</strong> 。</p>
<p><a href="https://leetcode.cn/problems/deepest-leaves-sum/">https://leetcode.cn/problems/deepest-leaves-sum/</a></p>
</blockquote>
<p><strong>广度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deepestLeavesSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            size = queue.size();</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                ans += temp.val;</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>深度优先</strong></p>
<p>深度优先效率更高，击败百分百，是广度优先执行效率的六倍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLevel</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deepestLeavesSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       dfs(root, <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level &gt; maxLevel) &#123;</span><br><span class="line">            maxLevel = level;</span><br><span class="line">            ans = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == maxLevel) &#123;</span><br><span class="line">            ans += root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, level + <span class="number">1</span>);</span><br><span class="line">        dfs(root.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="输出二叉树"><a href="#输出二叉树" class="headerlink" title="输出二叉树"></a>输出二叉树</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-22%2011.09.24.png" alt="截屏2022-08-22 11.09.24" style="zoom:50%;" />



<p><strong>深度优先</strong></p>
<p>基本思路是先写一个方法拿到高度，然后再深度优先调用，传递的参数是行，以及每一行应该存放的位置，不断递归就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">printTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> getDepth(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowNums</span> <span class="operator">=</span> height + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">colNnums</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (height + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowNums; i++) &#123;</span><br><span class="line">            List&lt;String&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colNnums; j++) &#123;</span><br><span class="line">                row.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(res, root, <span class="number">0</span>, (colNnums - <span class="number">1</span>) / <span class="number">2</span>, height);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            h = Math.max(h, getDepth(node.left) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            h = Math.max(h, getDepth(node.right) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, TreeNode root,  </span></span><br><span class="line"><span class="params">                            <span class="type">int</span> row, <span class="type">int</span> location, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        res.get(row).set(location, Integer.toString(root.val));</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            dfs(res, root.left, row + <span class="number">1</span>, location - (<span class="number">1</span>&lt;&lt;(height - row - <span class="number">1</span>)), height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            dfs(res, root.right, row + <span class="number">1</span>, location +(<span class="number">1</span>&lt;&lt;(height - row - <span class="number">1</span>)), height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>广度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Tuple</span> &#123; </span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="type">int</span> row;</span><br><span class="line">        <span class="type">int</span> loac;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tuple</span><span class="params">(TreeNode node, <span class="type">int</span> row, <span class="type">int</span> loac)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.loac = loac;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">printTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> getDepth(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowNums</span> <span class="operator">=</span> height + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">colNnums</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (height + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowNums; i++) &#123;</span><br><span class="line">            List&lt;String&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colNnums; j++) &#123;</span><br><span class="line">                row.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Tuple&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">Tuple</span>(root, <span class="number">0</span>, (colNnums - <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> temp.node;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> temp.row;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> temp.loac;</span><br><span class="line">            res.get(r).set(c, Integer.toString(node.val));</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">Tuple</span>(node.left,r+<span class="number">1</span>,c-(<span class="number">1</span>&lt;&lt;(height-r-<span class="number">1</span>))));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">Tuple</span>(node.right,r+<span class="number">1</span>,c+(<span class="number">1</span>&lt;&lt;(height-r-<span class="number">1</span>))));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            h++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-22%2014.33.11.png" alt="截屏2022-08-22 14.33.11" style="zoom:50%;" />





<p><strong>宽度优先遍历</strong></p>
<p>主要思路是：先声明一个类，将节点、节点在二叉树中的深度以及其在每一层的位置封装起来，创建一个队列来遍历二叉树，每次遍历时判断，如果这个节点的深度和当前深度不同，且其node不为空，说明来到了下一层的第一个非空节点，将其设置为最左边的节点，之后不断判断剩下的节点和最左节点的位置差是否大于ans</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PackNode</span> &#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="type">int</span> depth;</span><br><span class="line">        <span class="type">int</span> loac;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PackNode</span><span class="params">(TreeNode node, <span class="type">int</span> depth, <span class="type">int</span> loac)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.depth = depth;</span><br><span class="line">            <span class="built_in">this</span>.loac = loac;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;PackNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">PackNode</span>(root, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">PackNode</span> <span class="variable">p</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (p.node != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">PackNode</span>(p.node.left, p.depth + <span class="number">1</span>, p.loac * <span class="number">2</span>));</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">PackNode</span>(p.node.right, p.depth + <span class="number">1</span>, p.loac * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (curDepth != p.depth) &#123;</span><br><span class="line">                    curDepth = p.depth;</span><br><span class="line">                    left = p.loac;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, p.loac - left + <span class="number">1</span>);            </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>深度优先遍历</strong></p>
<p>效率不如宽度优先，但是很优雅</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    Map&lt;Integer, Integer&gt; left;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        left = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> depth, <span class="type">int</span> loac)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left.computeIfAbsent(depth, x -&gt; loac);</span><br><span class="line">        ans = Math.max(ans, loac - left.get(depth) + <span class="number">1</span>);</span><br><span class="line">        dfs(node.left, depth + <span class="number">1</span>, loac * <span class="number">2</span>);</span><br><span class="line">        dfs(node.right, depth + <span class="number">1</span>, loac * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><h3 id="前序-中序构造二叉树"><a href="#前序-中序构造二叉树" class="headerlink" title="前序 + 中序构造二叉树"></a>前序 + 中序构造二叉树</h3><blockquote>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code>是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p>LeetCode(105) hot 100</p>
</blockquote>
<p><strong>递归 中序遍历</strong></p>
<p>这里还能有一个优化的点，但是思维难度比较高，省略了，有时间去收藏的题解里面看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap; </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造中序遍历的索引 map，这样通过前序遍历的根节点值去拿坐标更快</span></span><br><span class="line">        indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> buildingTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后面四个参数的含义是：左子树或右子树在前序和中序遍历的范围分布</span></span><br><span class="line">    <span class="comment">// 通过这个范围可以确定根节点的位置并递归确定二叉树结构</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildingTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, </span></span><br><span class="line"><span class="params">        <span class="type">int</span> pre_left, <span class="type">int</span> pre_right, <span class="type">int</span> in_left, <span class="type">int</span> in_right)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (pre_left &gt; pre_right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 先序遍历的第一个节点是根节点</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">preorder_root</span> <span class="operator">=</span> pre_left;</span><br><span class="line">           <span class="comment">// 构造当前根节点</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">inorder_root</span> <span class="operator">=</span> indexMap.get(preorder[preorder_root]);</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">           <span class="comment">// 通过 inorder 可以拿到左子树的节点个数</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">countLeft</span> <span class="operator">=</span> inorder_root - in_left;</span><br><span class="line">           <span class="comment">// 再通过先序遍历以及左子树节点数可以确定左子树的节点范围</span></span><br><span class="line">           root.left = buildingTree(preorder, inorder, </span><br><span class="line">           pre_left + <span class="number">1</span>, pre_left + countLeft, in_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">           root.right = buildingTree(preorder, inorder,</span><br><span class="line">           pre_left + countLeft + <span class="number">1</span>, pre_right, inorder_root + <span class="number">1</span>, in_right);</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>迭代</strong></p>
<p>很巧妙，有空看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 二叉树应用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 节点与祖先之间的最大差值</span><br><span class="line"></span><br><span class="line">&gt; 给定二叉树的根节点 `root`，找出存在于 **不同** 节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。</span><br><span class="line">&gt;</span><br><span class="line">&gt; （如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</span><br><span class="line">&gt;</span><br><span class="line">&gt; LeetCode <span class="number">1026</span> </span><br><span class="line"></span><br><span class="line">**深度优先**</span><br><span class="line"></span><br><span class="line">这道题的思路是在遍历的时候维护祖先的最大值与最小值，然后每次计算当前节点与最大值与最小值的差，将最大的返回即可，思路比较简单，但是有一个点会困扰我很久，就是维护的最大值最小值一定是当前节点的祖先吗？</span><br><span class="line">仔细想想后发现这个问题的答案是肯定的，这个问题不能从纸面上的遍历顺序去考虑，应该从递归的顺序去考虑，当我们遍历到叶子节点时会回退的，min 和 max 会回到之前的值，唯一可以返回的只是函数的返回值</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAncestorDiff</span><span class="params">(TreeNode root)</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> dfs(root, root.val, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.max(Math.abs(node.val - min), Math.abs(node.val - max));</span><br><span class="line">       min = Math.min(min, node.val);</span><br><span class="line">       max = Math.max(max, node.val);</span><br><span class="line">       diff = Math.max(diff, dfs(node.left, min, max));</span><br><span class="line">       diff = Math.max(diff, dfs(node.right, min, max));</span><br><span class="line">       <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="序列化、反序列化"><a href="#序列化、反序列化" class="headerlink" title="序列化、反序列化"></a>序列化、反序列化</h3><blockquote>
<p>二叉树的序列化和反序列化就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的一棵树</p>
<p>序列化分为先序、中序和后序，以#表示空节点，以下划线作为一个节点的结束</p>
</blockquote>
<p><strong>先序序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">serialByPre</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;#_&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> head.value + <span class="string">&quot;_&quot;</span>;</span><br><span class="line">       res += serialByPre(head.left);</span><br><span class="line">       res += serialByPre(head.right);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>反序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reconByPreString</span><span class="params">(String preStr)</span> &#123;</span><br><span class="line">        String[] values = preStr.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            queue.add(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reconPreOrder(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reconPreOrder</span><span class="params">(Queue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.valueOf(value));</span><br><span class="line">        node.left = reconPreOrder(queue);</span><br><span class="line">        node.right = reconPreOrder(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="凹折痕、凸折痕"><a href="#凹折痕、凸折痕" class="headerlink" title="凹折痕、凸折痕"></a>凹折痕、凸折痕</h3><blockquote>
<p>微软原题：一个长方形的纸条，从中间对折一次，会出现一个折痕，这个折痕是凹下去的，继续对半折，会出现新的折痕，有凹凸之分，现给定N为对半折的次数，要求输出纸条从上到下的凹凸折痕情况。</p>
<p>解析：自己拿一个纸条做实验，每次对折之后在折痕上划线写上编号以及凹凸，最后会发现这是一个二叉树形式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAllFolds</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">printProcess(<span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i:节点的层数，N：一共要折的层数，down == true：凹，down == false：true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printProcess</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> N, <span class="type">boolean</span> down)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printProcess(i + <span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">        System.out.println(down ? <span class="string">&quot;凹&quot;</span> : <span class="string">&quot;凸&quot;</span>);</span><br><span class="line">        printProcess(i + <span class="number">1</span>, N, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











<h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-20%2023.02.49.png" alt="截屏2022-08-20 23.02.49" style="zoom:50%;" />



<p><strong>递归</strong></p>
<p>注意：递归函数的base case 里必须是小于，否则会损失答案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">biggest</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            biggest = nums[biggest] &gt; nums[i] ? biggest : i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[biggest]);</span><br><span class="line">        newHead.left = process(nums, left, biggest - <span class="number">1</span>);</span><br><span class="line">        newHead.right = process(nums, biggest + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>单调栈</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 树的子结构</span><br><span class="line"></span><br><span class="line">&gt; 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span><br><span class="line">&gt; B是A的子结构， 即 A中有出现和B相同的结构和节点值。</span><br><span class="line">&gt;</span><br><span class="line">&gt; https:<span class="comment">//leetcode.cn/problems/shu-de-zi-jie-gou-lcof/</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="literal">null</span> &amp;&amp; B != <span class="literal">null</span>) &amp;&amp; (recur( A, B) </span><br><span class="line">            || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="最大二叉树2"><a href="#最大二叉树2" class="headerlink" title="最大二叉树2"></a>最大二叉树2</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-30%2011.35.25.png" alt="截屏2022-08-30 11.35.25" style="zoom:50%;" />





<h3 id="最长同值路径"><a href="#最长同值路径" class="headerlink" title="最长同值路径"></a>最长同值路径</h3><blockquote>
<p>给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。两个节点之间的路径长度 由它们之间的边数表示。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-univalue-path">https://leetcode.cn/problems/longest-univalue-path</a></p>
</blockquote>
<p><strong>深度优先</strong></p>
<p>一般二叉树找各种最值是需要做一个缓存来存储当前最值的，可能是数组链表，也可能是一个变量即可，这里明显只需要一个变量res<br>然后采用深度优先搜索，将问题分治为：当前node的左节点的最长同值路径与右节点的最长同值路径比较，且左右节点值与根节点值做比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(node.left), right = dfs(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left1</span> <span class="operator">=</span> <span class="number">0</span>, right1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.val == node.left.val) &#123;</span><br><span class="line">            left1 = left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span> &amp;&amp; node.val == node.right.val) &#123;</span><br><span class="line">            right1 = right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, left1 + right1);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left1, right1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="二叉树序列化"><a href="#二叉树序列化" class="headerlink" title="二叉树序列化"></a>二叉树序列化</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-05%2011.26.22.png" alt="截屏2022-09-05 11.26.22"  />



<p><strong>深度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rserialize(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        String[] dataArray = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;(Arrays.asList(dataArray));</span><br><span class="line">        <span class="keyword">return</span> rdeserialize(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">rserialize</span><span class="params">(TreeNode root, String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            str += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str += str.valueOf(root.val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            str = rserialize(root.left, str);</span><br><span class="line">            str = rserialize(root.right, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">rdeserialize</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataList.get(<span class="number">0</span>).equals(<span class="string">&quot;None&quot;</span>)) &#123;</span><br><span class="line">            dataList.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(dataList.get(<span class="number">0</span>)));</span><br><span class="line">        dataList.remove(<span class="number">0</span>);</span><br><span class="line">        root.left = rdeserialize(dataList);</span><br><span class="line">        root.right = rdeserialize(dataList);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h3><blockquote>
<p>给定一棵二叉树 root，返回所有重复的子树。<br>对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。<br>如果两棵树具有相同的结构和相同的结点值，则它们是重复的。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-duplicate-subtrees">https://leetcode.cn/problems/find-duplicate-subtrees</a></p>
</blockquote>
<p><strong>哈希映射+序列化</strong></p>
<p>将每个节点的子树序列化成字符串加到哈希表中，再用一个HashSet判断是否重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录每个节点的字节点序列化值</span></span><br><span class="line">    Map&lt;String, TreeNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录重复序列化的根节点</span></span><br><span class="line">    Set&lt;TreeNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 逗号用来分割根节点和左右节点，不然难以区分</span></span><br><span class="line">        sb.append(node.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        sb.append(dfs(node.left));</span><br><span class="line">        sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        sb.append(dfs(node.right));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(str)) &#123;</span><br><span class="line">            set.add(map.get(str));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(str, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>三元组唯一表示</strong></p>
<p>方法一很明显的缺点是，二叉树足够大时序列化产生的字符串会很长很多，所以用三元组优化，三元组的组成是：根节点的值，左右子树的序列，这个序列是不同结构子树的序号，序号相同即表示左右子树结构相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录每个节点的字节点序列化值</span></span><br><span class="line">    Map&lt;String, Pair&lt;TreeNode, Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录重复序列化的根节点</span></span><br><span class="line">    Set&lt;TreeNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] tri = &#123;node.val, dfs(node.left), dfs(node.right)&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hash</span> <span class="operator">=</span> Arrays.toString(tri);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(hash)) &#123;</span><br><span class="line">            Pair&lt;TreeNode, Integer&gt; pair = map.get(hash);</span><br><span class="line">            set.add(pair.getKey());</span><br><span class="line">            <span class="keyword">return</span> pair.getValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(hash, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;TreeNode, Integer&gt;(node, ++idx));</span><br><span class="line">            <span class="keyword">return</span> idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="计算布尔二叉树"><a href="#计算布尔二叉树" class="headerlink" title="计算布尔二叉树"></a>计算布尔二叉树</h3><blockquote>
<p>给你一棵 <strong>完整二叉树</strong> 的根，这棵树有以下特征：</p>
<ul>
<li><strong>叶子节点</strong> 要么值为 <code>0</code> 要么值为 <code>1</code> ，其中 <code>0</code> 表示 <code>False</code> ，<code>1</code> 表示 <code>True</code> 。</li>
<li><strong>非叶子节点</strong> 要么值为 <code>2</code> 要么值为 <code>3</code> ，其中 <code>2</code> 表示逻辑或 <code>OR</code>，<code>3</code> 表示逻辑与 <code>AND</code> 。</li>
</ul>
<p><strong>计算</strong> 一个节点的值方式如下：</p>
<ul>
<li>如果节点是个叶子节点，那么节点的 <strong>值</strong> 为它本身，即 <code>True</code> 或者 <code>False</code> 。</li>
<li>否则，<strong>计算</strong> 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 <strong>运算</strong> 。</li>
</ul>
<p>返回根节点 <code>root</code> 的布尔运算值。</p>
<p><strong>完整二叉树</strong> 是每个节点有 <code>0</code> 个或者 <code>2</code> 个孩子的二叉树。</p>
<p><strong>叶子节点</strong> 是没有孩子的节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">evaluateTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> evaluateTree(root.left) || evaluateTree(root.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> evaluateTree(root.left) &amp;&amp; evaluateTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























<h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><blockquote>
<p>前缀树主要针对字符串，能够查询是否存在某一个字符串并且能查询以某一子串为前缀的字符串个数</p>
<p>将某单个字符放在节点与节点的边上，这样从根节点走到叶子节点就是一个字符串</p>
<p>其中在字符种类多的情况喜爱可以用哈希表来代替数组 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前缀树节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> pass; <span class="comment">//表示此节点到达过多少次</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> end; <span class="comment">// 表示此节点是否是一个字符串的结尾节点</span></span><br><span class="line">        <span class="keyword">public</span> TrieNode[] nexts; <span class="comment">// HashMap&lt;Char, Node&gt; nexts</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">           pass = <span class="number">0</span>;</span><br><span class="line">           end = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//nexts[0] == 0 :没有走向a的路</span></span><br><span class="line">           <span class="comment">//nexts[1] != 0 :有走向a的路</span></span><br><span class="line">           <span class="comment">//nexts[25] != 0 ：有走向z的路</span></span><br><span class="line">           nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前缀树类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            node.pass++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录每个字符在nexts数组中的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.nexts[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.nexts[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[index];</span><br><span class="line">                node.pass++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询单词加入过几次</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searcchCount</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.nexts[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询所有的字符串中有多少个是以pre这个字符串作为前缀的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prefixNum</span><span class="params">(String pre)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] chs = pre.toCharArray();</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.nexts[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.pass;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除一个字符串的存储信息</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (searcchCount(word) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">                node.pass--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                    index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--node.nexts[index].pass == <span class="number">0</span>) &#123; <span class="comment">// 如果一个节点的pass都是0了，那就释放掉，没用了</span></span><br><span class="line">                        node.nexts[index] = <span class="literal">null</span>; <span class="comment">//只有java可以这么写，因为有gc机制</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.nexts[index];</span><br><span class="line">                &#125;</span><br><span class="line">                node.end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="单词替换"><a href="#单词替换" class="headerlink" title="单词替换"></a>单词替换</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-07%2023.59.25.png" alt="截屏2022-07-07 23.59.25" style="zoom:50%;" />

















<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>LeetCode (98) hot 100</p>
</blockquote>
<p><strong>递归</strong></p>
<p>每次向下递归一个范围，判断当前节点在不在范围内<br>用 long 没有特殊的，只是测试用例里面有 Integer，这样会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(TreeNode node, <span class="type">long</span> lower, <span class="type">long</span> upper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValid(node.left, lower, node.val) &amp;&amp; isValid(node.right, node.val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>中序遍历</strong></p>
<p>二叉搜索树的一个重要特性就是中序遍历是一个升序的序列，所以我们只需在中序遍历的时候判断当前节点是否大于之前的一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">pre</span> <span class="operator">=</span> -Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; </span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="二叉搜索树众数"><a href="#二叉搜索树众数" class="headerlink" title="二叉搜索树众数"></a>二叉搜索树众数</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-14%2011.30.15.png" alt="截屏2022-07-14 11.30.15" style="zoom:50%;" />



<p><strong>中序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; asc = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">//用来记录截止到目前的出现频率最高的的节点们</span></span><br><span class="line">    <span class="type">int</span> curNum; <span class="comment">// 当前遍历到的节点</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 遍历到的节点的出现次数</span></span><br><span class="line">    <span class="type">int</span> maxCount; <span class="comment">// asc中的出现频率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[asc.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; asc.size(); ++i) &#123;</span><br><span class="line">            answer[i] = asc.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        update(root.val);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 更新asc的函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val == curNum) &#123; </span><br><span class="line">          <span class="comment">// 判断当前遍历到的节点和之前遍历到的节点值是不是一样的</span></span><br><span class="line">          <span class="comment">//因为一样的肯定是在相同的区间内</span></span><br><span class="line">            ++count; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不一样就用两个变量来存放当前值以及重置的出现次数</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            curNum = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">            asc.add(curNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            asc.clear();</span><br><span class="line">            asc.add(curNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>Morris中序遍历</strong><br>需要修改树的结构</p>
<h3 id="搜索树最小绝对差"><a href="#搜索树最小绝对差" class="headerlink" title="搜索树最小绝对差"></a>搜索树最小绝对差</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-26%2014.51.47.png" alt="截屏2022-07-26 14.51.47" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="type">int</span> preVal;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        preVal = -<span class="number">999</span>;</span><br><span class="line">        process(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(root.left);</span><br><span class="line">        <span class="keyword">if</span> (preVal == -<span class="number">999</span>) &#123;</span><br><span class="line">            preVal = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.min(ans, root.val - preVal);</span><br><span class="line">            preVal = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        process(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="判断BST后序序列"><a href="#判断BST后序序列" class="headerlink" title="判断BST后序序列"></a>判断BST后序序列</h3><blockquote>
<p>力扣：<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p>
<p>题目描述：<br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p><strong>递归法</strong></p>
<p>Base case：当递归传入的左节点index大于或等于右节点的index下标，说明此时的递归只剩下最后一个节点，那就没必要判断了，直接返回true。<br>接下来通过两个 while 循环来找到第一个大于根节点的节点以及第一个不大于根节点的节点，用来分开左子树与右子树，以进行下一次递归。<br>在最后判断此树是不是二叉搜索树的后序遍历时，先看第一个不大于根节点的节点和传入的右节点的下标是否相同，并且总体返回的值还取决于左子树的情况以及右子树的情况，所以将三种情况相与。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p] &lt; postorder[r]) p++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lnew</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p] &gt; postorder[r]) p++;</span><br><span class="line">        <span class="keyword">return</span> p == r </span><br><span class="line">            &amp;&amp; process(postorder, l, lnew - <span class="number">1</span>) &amp;&amp; process(postorder, lnew, r - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>辅助单调栈</strong></p>
<p>主要利用了后序遍历的逆序列是前序遍历的“镜像”这一特点，很新颖，但效率不高，知道就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])</span><br><span class="line">            	root = stack.pop();</span><br><span class="line">            stack.add(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-10%2023.18.07.png" alt="截屏2022-09-10 23.18.07" style="zoom:50%;" />





<p><strong>深度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = trimBST(root.left, low, high);</span><br><span class="line">            root.right = trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>迭代</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (root != <span class="literal">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root; node.left != <span class="literal">null</span>; ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (node.left.val &lt; low) &#123;</span><br><span class="line">               node.left = node.left.right;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node = node.left;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root; node.right != <span class="literal">null</span>;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (node.right.val &gt; high) &#123;</span><br><span class="line">               node.right = node.right.left;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node = node.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="重叠矩形面积"><a href="#重叠矩形面积" class="headerlink" title="重叠矩形面积"></a>重叠矩形面积</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-17%2023.55.05.png" alt="截屏2022-09-17 23.55.05" style="zoom:50%;" />

































<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><hr>
<h2 id="图的表达"><a href="#图的表达" class="headerlink" title="图的表达"></a>图的表达</h2><blockquote>
<p>图的表达有很多种方式，最常用的也是最万能的两个方法：</p>
<ul>
<li>临接表</li>
<li>临接矩阵</li>
</ul>
<p>此外还有很多特殊表达，比如对于一个没有环且有向上的节点的图，可以用数据来表示，每个数组元素表示其父节点<br>还有比如一个二维数组，N行3列，第一列表示某一个边的权值，第二列第三列表示其连接的两个节点</p>
<p>所以图的学习方式是用一种存储方式去解决所有算法，效率最高</p>
</blockquote>
<h3 id="表达代码"><a href="#表达代码" class="headerlink" title="表达代码"></a>表达代码</h3><blockquote>
<p>在图的结构里用hashmap存点集和边集</p>
<p>这个结构比较完善，基本支持所有的常规图算法，如果其中某些字段没用到，不填即可</p>
</blockquote>
<p><strong>图Graph</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(HashMap&lt;Integer, Node&gt; nodes, HashSet&lt;Edge&gt; edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nodes = nodes;</span><br><span class="line">        <span class="built_in">this</span>.edges = edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>点集Nodes</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> in; <span class="comment">// 一个点的入度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> out; <span class="comment">// 一个点的出度</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts; <span class="comment">// 由这个点发散出去的直接邻居的点集</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges; <span class="comment">// 由这个点出去的边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Edge&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>边集Edge</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight; <span class="comment">//这个边的权值</span></span><br><span class="line">    <span class="keyword">public</span> Node from;</span><br><span class="line">    <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> weight, Node from, Node to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="不同表达的转换"><a href="#不同表达的转换" class="headerlink" title="不同表达的转换"></a>不同表达的转换</h3><blockquote>
<p>若现在有一个N行3列的二维数组，第一列第二列表示from节点和to节点，第三列表示边的权重，现将这个二维数组的图的表达转换成我自己的表达</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title function_">createGraph</span><span class="params">(Integer matrix[][])</span> &#123;</span><br><span class="line">       <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">from</span> <span class="operator">=</span> matrix[i][<span class="number">0</span>];</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">to</span> <span class="operator">=</span> matrix[i][<span class="number">1</span>];</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">weight</span> <span class="operator">=</span> matrix[i][<span class="number">2</span>];</span><br><span class="line">           <span class="keyword">if</span> (!graph.nodes.containsKey(from)) &#123;</span><br><span class="line">               graph.nodes.put(from, <span class="keyword">new</span> <span class="title class_">Node</span>(from));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!graph.nodes.containsKey(to)) &#123;</span><br><span class="line">               graph.nodes.put(to, <span class="keyword">new</span> <span class="title class_">Node</span>(to));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">fromNode</span> <span class="operator">=</span> graph.nodes.get(from);</span><br><span class="line">           <span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> graph.nodes.get(to);</span><br><span class="line">           <span class="type">Edge</span> <span class="variable">newEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(weight, fromNode, toNode);</span><br><span class="line">           fromNode.nexts.add(toNode);</span><br><span class="line">           fromNode.out++;</span><br><span class="line">           toNode.in++;</span><br><span class="line">           fromNode.edges.add(newEdge);</span><br><span class="line">           graph.edges.add(newEdge);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> graph;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>











<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h3><blockquote>
<ol>
<li>优先访问与源节点相邻的节点</li>
<li>利用队列实现</li>
<li>从源节点开始依次按照宽度进入队列，然后弹出</li>
<li>每弹出一个点，把该节点所有没进过队列的临接点放入队列</li>
<li>直到队列变空</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从node出发，宽度优先遍历图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 这个set是为了判断某一个节点有没有被遍历过</span></span><br><span class="line">        queue.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(cur.value);</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    queue.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><blockquote>
<ol>
<li>一直往下遍历节点</li>
<li>利用栈实现</li>
<li>从源节点开始把节点按深度放入栈，然后弹出</li>
<li>每弹出一个点，把该节点下一个没进过栈的临接点放入栈</li>
<li>直到栈变空</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从Node出发，深度优先遍历图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        stack.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    System.out.println(next.value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











<h2 id="图排序"><a href="#图排序" class="headerlink" title="图排序"></a>图排序</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><blockquote>
<p>思想：每次找出入度为0的那个节点，遍历他的nexts，把与其相邻的节点入度减一再继续遍历找到入度为0的节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">sortedTopology</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">        <span class="comment">//key : 某一个Node，value：剩余的入度</span></span><br><span class="line">        HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//入度为0的点进入这个队列</span></span><br><span class="line">        Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历这个图的nodes集合，目的是把所有的nodes以及其入度加入到inMap中</span></span><br><span class="line">        <span class="comment">// 同时检查出第一个入度为0的节点并接入到0入度集合中</span></span><br><span class="line">        <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">            inMap.put(node, node.in);</span><br><span class="line">            <span class="keyword">if</span> (node.in == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroInQueue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个数组用来接收最终的拓扑排序结果</span></span><br><span class="line">        List&lt;Node&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!zeroInQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//将0入度集合的第一个元素弹出，放入到result中</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> zeroInQueue.poll();</span><br><span class="line">            result.add(cur);</span><br><span class="line">            <span class="comment">//继续遍历弹出元素的nexts，将其next中的元素的入度减一再重新加入到inMap中</span></span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//再继续找下一个入度为0的节点</span></span><br><span class="line">                <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeroInQueue.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><blockquote>
<p>从边的角度获得最小生成树，且针对无向图</p>
<p>所有的边中从权值最小的开始添加，每次添加的时候判断一下有没有环生成，有就不要，依次这样处理所有的边</p>
<p>所以问题就变成了如何判断树有无环，这里使用并查集来解决，一开始将所有的节点看成单独的集合，然后每当有两个集合需要连接就会判断这两个节点是否在同一个集合中，如果在，那么连接后就意味着有环，如果不在，连接后这两个节点的集合就合并</p>
<p>在此题中只会写一个小型并查集</p>
</blockquote>
<p><strong>写一个模拟并查集，说清楚底层原理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">mySets</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> HashMap&lt;Node, List&lt;Node&gt;&gt; setMap;</span><br><span class="line">       <span class="comment">//将所有的节点一开始加入到集合中</span></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">mySets</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">               ArrayList&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//每个节点所在的集合</span></span><br><span class="line">               set.add(node);</span><br><span class="line">               setMap.put(node, set);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断两个节点是不是处于同一个集合</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(Node from, Node to)</span> &#123;</span><br><span class="line">           List&lt;Node&gt; fromSet = setMap.get(from);</span><br><span class="line">           List&lt;Node&gt; toSet = setMap.get(to);</span><br><span class="line">           <span class="keyword">return</span> fromSet == toSet;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将两个节点所在集合合并成一个集合</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(Node from, Node to)</span> &#123;</span><br><span class="line">           List&lt;Node&gt; fromSet = setMap.get(from);</span><br><span class="line">           List&lt;Node&gt; toSet = setMap.get(to);</span><br><span class="line">           <span class="keyword">for</span> (Node node : toSet) &#123;</span><br><span class="line">               fromSet.add(node);</span><br><span class="line">               setMap.put(node, fromSet);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>Kruskal</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">kruskal</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node cur : graph.nodes.values()) &#123;</span><br><span class="line">            list.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">mySets</span> <span class="variable">mysets</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mySets</span>(list); <span class="comment">//先将每个节点设置成单独的集合</span></span><br><span class="line">        <span class="comment">//创建一个堆，传入自己定义的比较器</span></span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">EdgeComparator</span>());</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : graph.edges) &#123;</span><br><span class="line">            priorityQueue.add(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!mysets.isSameSet(edge.from, edge.to)) &#123;</span><br><span class="line">                result.add(edge);</span><br><span class="line">                mysets.union(edge.from, edge.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><blockquote>
<p>适用于无向图</p>
<p>思想：从源节点开始，每次找到此节点的边中权值最低的然后将与其相邻的节点加入</p>
<p>Prim算法不同与Kruskal算法，不需要并查集结构，因为Prim是确定了一个集合然后每次将其他解节点拉入到这个集合当中，而Kruskal算法会涉及到不同的集合合并的问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">primMST</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">        <span class="comment">//将所有的边做成一个小根堆</span></span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">EdgeComparator</span>());</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">//判断节点有无处理过</span></span><br><span class="line">        Set&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">//依次挑选的边放在result里</span></span><br><span class="line">        <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="comment">//这个for循环是为了处理森林情况的,如果是连通图不用这个大for循环也可以</span></span><br><span class="line">            <span class="comment">//node是开始的点</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(node)) &#123;</span><br><span class="line">                set.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : node.edges) &#123; <span class="comment">//遍历这个点所有的相邻边</span></span><br><span class="line">                priorityQueue.add(edge);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll();<span class="comment">//小根堆弹出时是以从小到大顺序弹出的</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> edge.to;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(toNode)) &#123;</span><br><span class="line">                    set.add(toNode);</span><br><span class="line">                    result.add(edge);</span><br><span class="line">                    <span class="keyword">for</span> (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">                        priorityQueue.add(nextEdge);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><blockquote>
<p>单元最短路径算法，适用于没有负数权值的图</p>
<p>思路：Dijkstra算法必须指定一个源节点，然后可以找到这个源节点出发到所有节点的权值最小路径，然后维护一个数组，素组的元素是源节点出发到其他节点的最短距离，初始化源节点到自己的距离是0，到其他节点的距离是无穷，然后每次开始操作当下节点相邻边，看看此时的距离有没有比之前更加优化。每次确定好的距离可以加锁表示最终答案。</p>
<p>Dijkstra算法的改进：可以将distance存放在小根堆中，具体见9.2.1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title function_">dijkstra</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">//key : 从head出发到达key</span></span><br><span class="line">        <span class="comment">//value：从head出发到达key的最小值</span></span><br><span class="line">        <span class="comment">//如果在表中没有t这个节点的信息，含义是从head到t的距离是正无穷</span></span><br><span class="line">        HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        distanceMap.put(head, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//已经求过距离的节点存在selectedNodes，以后不碰</span></span><br><span class="line">        HashSet&lt;Node&gt; selectedNode = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> getMinDIstanceAndUnselectedNodes(distanceMap, selectedNode);</span><br><span class="line">        <span class="keyword">while</span> (minNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> distanceMap.get(minNode);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : minNode.edges) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> edge.to;</span><br><span class="line">                <span class="keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;</span><br><span class="line">                    distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                selectedNode.add(minNode); <span class="comment">//锁住处理好的节点</span></span><br><span class="line">                minNode = getMinDIstanceAndUnselectedNodes(distanceMap, selectedNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> distanceMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getMinDIstanceAndUnselectedNodes</span><span class="params">(</span></span><br><span class="line"><span class="params">            HashMap&lt;Node, Integer&gt; distanceMap,</span></span><br><span class="line"><span class="params">            HashSet&lt;Node&gt; touchedNodes</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minDistance</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">                minNode = node;</span><br><span class="line">                minDistance = distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>













<h2 id="图应用"><a href="#图应用" class="headerlink" title="图应用"></a>图应用</h2><h3 id="不邻接植花"><a href="#不邻接植花" class="headerlink" title="不邻接植花"></a>不邻接植花</h3><blockquote>
<p>有 <code>n</code> 个花园，按从 <code>1</code> 到 <code>n</code> 标记。另有数组 <code>paths</code> ，其中 <code>paths[i] = [xi, yi]</code> 描述了花园 <code>xi</code> 到花园 <code>yi</code> 的双向路径。在每个花园中，你打算种下四种花之一。</p>
<p>另外，所有花园 <strong>最多</strong> 有 <strong>3</strong> 条路径可以进入或离开.</p>
<p>你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。</p>
<p><em>以数组形式返回 <strong>任一</strong> 可行的方案作为答案 <code>answer</code>，其中 <code>answer[i]</code> 为在第 <code>(i+1)</code> 个花园中种植的花的种类。花的种类用  1、2、3、4 表示。保证存在答案。</em></p>
<p>LeetCode 1042</p>
</blockquote>
<p><strong>这道题比较容易，放在图应用的第一道题用来体会图的思想，主要也还是蕾丝广度优先遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] gardenNoAdj(<span class="type">int</span> n, <span class="type">int</span>[][] paths) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] adj = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] path : paths) &#123;</span><br><span class="line">            adj[path[<span class="number">0</span>] - <span class="number">1</span>].add(path[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            adj[path[<span class="number">1</span>] - <span class="number">1</span>].add(path[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span>[] colored = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> adjGardens : adj[i]) &#123;</span><br><span class="line">                colored[ans[adjGardens]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!colored[j]) &#123;</span><br><span class="line">                    ans[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="受限条件下可到达的节点数目"><a href="#受限条件下可到达的节点数目" class="headerlink" title="受限条件下可到达的节点数目"></a>受限条件下可到达的节点数目</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-12%2011.01.32.png" alt="截屏2022-08-12 11.01.32" style="zoom:50%;" />



<p><strong>BFS</strong></p>
<p>广度优先，主要思想是：建立链表数组来做邻接表，然后维护一个访问队列，这个访问队列的元素是一个两个元素的数组，第一个元素代表访问的是哪一个元素的邻接表，第二个元素代表上一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachableNodes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span>[] restricted)</span> &#123;</span><br><span class="line">       <span class="comment">// 建立邻接表</span></span><br><span class="line">       List&lt;Integer&gt;[] connectedList = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           connectedList[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] cur : edges) &#123;</span><br><span class="line">           connectedList[cur[<span class="number">0</span>]].add(cur[<span class="number">1</span>]);</span><br><span class="line">           connectedList[cur[<span class="number">1</span>]].add(cur[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 建立被限制元素的索引表，可以做到o(1)内判断是否是限制元素</span></span><br><span class="line">       <span class="type">int</span>[] isRest = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">       Arrays.fill(isRest, -<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> cur : restricted) isRest[cur] = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 广度优先搜索的关键是维护一个队列，将邻接表的元素按顺序加入</span></span><br><span class="line">       <span class="comment">//所以先做一个队列</span></span><br><span class="line">       Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//队列的数组元素含义是：</span></span><br><span class="line">       <span class="comment">//第一个是当前遍历到的节点值，用来获取该节点的临界数表</span></span><br><span class="line">       <span class="comment">//第二个是该节点上一个与之连接的节点，作用是防重复</span></span><br><span class="line">       queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;);</span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 开始bfs</span></span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">           <span class="type">int</span>[] temp = queue.poll();</span><br><span class="line">           <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> temp[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> p : connectedList[temp[<span class="number">0</span>]]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isRest[p] != <span class="number">1</span> &amp;&amp; p != pre) &#123;</span><br><span class="line">                   ans++;</span><br><span class="line">                   queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;p, temp[<span class="number">0</span>]&#125;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>DFS</strong></p>
<p>深度优先：不用维护队列，用递归去完成遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt;[] connectedList;</span><br><span class="line">    <span class="type">int</span>[] isRest;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachableNodes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span>[] restricted)</span> &#123;</span><br><span class="line">       <span class="comment">// 建立邻接表</span></span><br><span class="line">       connectedList = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           connectedList[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] cur : edges) &#123;</span><br><span class="line">           connectedList[cur[<span class="number">0</span>]].add(cur[<span class="number">1</span>]);</span><br><span class="line">           connectedList[cur[<span class="number">1</span>]].add(cur[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 建立被限制元素的索引表，可以做到o(1)内判断是否是限制元素</span></span><br><span class="line">       isRest = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">       Arrays.fill(isRest, -<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> cur : restricted) isRest[cur] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       dfs(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> pre)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : connectedList[now]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != pre &amp;&amp; isRest[node] != <span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(node, now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote>
<p>并查集主要就是对样本集合提供两个操作，一个是判断是否是同一个集合，一个是合并集合</p>
<p>但是传统数据结构没办法同时做到这两点，所以诞生了并查集</p>
<p>实现原理就是：给每一个样本集合封装一个顶部指针，一开始都指向自己，判断是否是同一个集合时就判断顶部指针是否相同即可，合并时就把元素较少的集合的指针挂在元素多的集合下</p>
<p>查找时并查集有一个小优化，就是将链状扁平化，即：假设现在有 a -&gt; b -&gt; c -&gt; e 的一个链，在找a的顶部节点时顺便把b、c的顶部节点指向e，这样就是扁平化优化</p>
</blockquote>
<h3 id="并查集模版"><a href="#并查集模版" class="headerlink" title="并查集模版"></a>并查集模版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        p[x] = find(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pa</span> <span class="operator">=</span> find(a), pb = find(b);</span><br><span class="line">    <span class="keyword">if</span> (pa == pb) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[pa] = pb;</span><br><span class="line">    size[pb] += size[pa];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="省份问题"><a href="#省份问题" class="headerlink" title="省份问题"></a>省份问题</h3><blockquote>
<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
<p>LeetCode 547</p>
</blockquote>
<h3 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h3><blockquote>
<p>题目：<br>一个矩阵中只有0 和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛（斜着相连不算）</p>
<p>进阶：如何设计一个并行的算法解决这个问题？</p>
</blockquote>
<p><strong>常规</strong></p>
<p>常规算法就是广度优先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countIslands</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="literal">null</span> || m[<span class="number">0</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> m.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    infect(m, i, j, N, M);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 感染过程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">infect</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> N, <span class="type">int</span> M)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[i][j] = <span class="number">2</span>;</span><br><span class="line">        infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">        infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="最大人工岛"><a href="#最大人工岛" class="headerlink" title="最大人工岛"></a>最大人工岛</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-19%2000.05.36.png" alt="截屏2022-09-19 00.05.36" />





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用来标记方向的静态数组，在遍历岛屿的四个方向时会用到</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] d = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录每个点的编号</span></span><br><span class="line">        <span class="type">int</span>[][] tag = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 记录每个点所属的岛屿</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; area = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; tag[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 给所有的陆地赋编号，属于同一片岛屿的点编号相同</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> i * n + j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 放到岛屿标记中去，key是编号，value是相连的最大岛屿</span></span><br><span class="line">                    area.put(t, dfs(grid, i, j, tag, t));</span><br><span class="line">                    res = Math.max(res, area.get(t));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接下来进行人工岛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    Set&lt;Integer&gt; connected = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + d[k], y = j + d[k + <span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 如果周围岛屿不符合规范或已经连过了，就继续下一次循环</span></span><br><span class="line">                        <span class="keyword">if</span> (!valid(n, x, y) || tag[x][y] == <span class="number">0</span> </span><br><span class="line">                        || connected.contains(tag[x][y])) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 获得新新人工岛的面积</span></span><br><span class="line">                        z += area.get(tag[x][y]);</span><br><span class="line">                        <span class="comment">// 将已经算过面积的岛屿的标志加入已连接集合</span></span><br><span class="line">                        connected.add(tag[x][y]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res = Math.max(res, z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[][] tag, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将编号加入tag数组</span></span><br><span class="line">        tag[x][y] = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 得到周围四个点的坐标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> x + d[i], y1 = y + d[i + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果周围的点坐标在n以内，且是个岛屿，且没被遍历过</span></span><br><span class="line">            <span class="keyword">if</span> (valid(n, x1, y1) &amp;&amp; grid[x1][y1] == <span class="number">1</span> &amp;&amp; tag[x1][y1] == <span class="number">0</span>) &#123;</span><br><span class="line">                res += dfs(grid, x1, y1, tag, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断点坐标是否合规</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h3 id="图中是否存在路径"><a href="#图中是否存在路径" class="headerlink" title="图中是否存在路径"></a>图中是否存在路径</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-12-19%2017.24.34.png" alt="截屏2022-12-19 17.24.34" style="zoom:50%;" />



<p><strong>广度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="comment">// 先建立各结点的下一结点队列</span></span><br><span class="line">        List&lt;Integer&gt;[] neighbor = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; neighbor.length; i++) &#123;</span><br><span class="line">            neighbor[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化下一结点队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>], to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 由于题中说的是双向图，所以需要在 from 和 to 都加</span></span><br><span class="line">            neighbor[from].add(to);</span><br><span class="line">            neighbor[to].add(from);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接下来开始广度优先遍历这些结点列</span></span><br><span class="line">        <span class="comment">// 记录结点是否被访问过</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="comment">// 广度队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(source);</span><br><span class="line">        visited[source] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == destination) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> next : neighbor[node]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[next]) &#123;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                    visited[next] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[destination];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>深度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt;[] neighbor = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; neighbor.length; i++) &#123;</span><br><span class="line">            neighbor[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>], to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 由于题中说的是双向图，所以需要在 from 和 to 都加</span></span><br><span class="line">            neighbor[from].add(to);</span><br><span class="line">            neighbor[to].add(from);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> visited[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">return</span> dfs(source, destination, neighbor, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, List&lt;Integer&gt;[] neighbor,<span class="type">boolean</span> visited[])</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (source == destination) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[source] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> next : neighbor[source]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[next] &amp;&amp; dfs(next, destination, neighbor, visited)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>并查集</strong></p>
<p>我们将图中的每个强连通分量视为一个集合，强连通分量中任意两点均可达，如果两个点 source 和 destination 处在同一个强连通分量中，则两点一定可连通，因此连通性问题可以使用并查集解决。</p>
<p>并查集初始化时，nnn 个顶点分别属于 nnn 个不同的集合，每个集合只包含一个顶点。初始化之后遍历每条边，由于图中的每条边均为双向边，因此将同一条边连接的两个顶点所在的集合做合并。</p>
<p>遍历所有的边之后，判断顶点 source 和顶点 destination 是否在同一个集合中，如果两个顶点在同一个集合则两个顶点连通，如果两个顶点所在的集合不同则两个顶点不连通</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source == destination) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            uf.uni(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.connect(source, destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="comment">// 下标和结点编号相同，对应的元素是其老大</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="comment">// 记录当前结点下有几个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] rank;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并函数，如果调用了此函数就说明 x 和 y 两结点是连通的，需要进行合并操作</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uni</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> find(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> find(y);</span><br><span class="line">            <span class="comment">// 根节点不同，所以需要进行合并操作,合并的依据是看谁底下的小弟多</span></span><br><span class="line">            <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                    parent[rootx] = rooty;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                    rank[rootx]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果每个结点的 parent 不是自己，就继续找当前结点的“老大”是谁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断两节点是否联通</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="可能的二分法"><a href="#可能的二分法" class="headerlink" title="可能的二分法"></a>可能的二分法</h3><blockquote>
<p>886</p>
<p>给定一组 <code>n</code> 人（编号为 <code>1, 2, ..., n</code>）， 我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>
<p>给定整数 <code>n</code> 和数组 <code>dislikes</code> ，其中 <code>dislikes[i] = [ai, bi]</code> ，表示不允许将编号为 <code>ai</code> 和 <code>bi</code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code>。</p>
</blockquote>
<p><strong>广度优先 + 染色法</strong></p>
<p>染色法就是遍历所有样本进行染色以便分类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">possibleBipartition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] dislikes)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为人的编号从 1 开始所以范围多声明一个方便计算</span></span><br><span class="line">        <span class="type">int</span> color[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        List&lt;Integer&gt;[] disl = <span class="keyword">new</span> <span class="title class_">List</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            disl[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化每个人的不喜欢人的链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p : dislikes) &#123;</span><br><span class="line">            disl[p[<span class="number">0</span>]].add(p[<span class="number">1</span>]);</span><br><span class="line">            disl[p[<span class="number">1</span>]].add(p[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历每个人，给所有人染色</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 0 是未染色</span></span><br><span class="line">            <span class="keyword">if</span> (color[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                <span class="comment">// 默认给颜色1</span></span><br><span class="line">                color[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> next : disl[t]) &#123;</span><br><span class="line">                        <span class="comment">// 如果已经染色且颜色相同，那就返回false</span></span><br><span class="line">                        <span class="keyword">if</span> (color[next] &gt; <span class="number">0</span> &amp;&amp; color[next] == color[t]) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果还没染色就赋相反色</span></span><br><span class="line">                        <span class="comment">// 3 异或 1 等于 2 ， 3 异或 2 等于 1</span></span><br><span class="line">                        <span class="keyword">if</span> (color[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                            color[next] = <span class="number">3</span> ^ color[t];</span><br><span class="line">                            queue.offer(next);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>深度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">possibleBipartition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] dislikes)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为人的编号从 1 开始所以范围多声明一个方便计算</span></span><br><span class="line">        <span class="type">int</span> color[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        List&lt;Integer&gt;[] disl = <span class="keyword">new</span> <span class="title class_">List</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            disl[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化每个人的不喜欢人的链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p : dislikes) &#123;</span><br><span class="line">            disl[p[<span class="number">0</span>]].add(p[<span class="number">1</span>]);</span><br><span class="line">            disl[p[<span class="number">1</span>]].add(p[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] == <span class="number">0</span> &amp;&amp; !dfs(i, <span class="number">1</span>, color, disl)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> curnode, <span class="type">int</span> nowcolor, <span class="type">int</span>[] color, List&lt;Integer&gt;[] disl)</span> &#123;</span><br><span class="line">        color[curnode] = nowcolor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : disl[curnode]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[next] != <span class="number">0</span> &amp;&amp; color[next] == color[curnode]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (color[next] == <span class="number">0</span> &amp;&amp; !dfs(next, <span class="number">3</span> ^ nowcolor, color, disl)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>并查集</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] p;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">possibleBipartition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] dislikes)</span> &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        List&lt;Integer&gt;[] disl = <span class="keyword">new</span> <span class="title class_">List</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">            disl[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p : dislikes) &#123;</span><br><span class="line">            disl[p[<span class="number">0</span>]].add(p[<span class="number">1</span>]);</span><br><span class="line">            disl[p[<span class="number">1</span>]].add(p[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : disl[i]) &#123;</span><br><span class="line">                <span class="comment">// 如果发现 i 和 j 属于同一个集合，那就说明错误</span></span><br><span class="line">                <span class="keyword">if</span> (find(i) == find(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 j 放在 i 讨厌的人的集合里面</span></span><br><span class="line">                p[find(j)] = find(disl[i].get(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != p[x]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











































<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><hr>
<blockquote>
<p>在某一个标准下，优先考虑最满足标本的样本，最后考虑不满足标本的样本，最终得到答案的算法，叫做贪心算法<br>也就是说不从整体最优上去考虑，所作出的是某种意义上的局部最优解。</p>
<p>贪心策略在实现时，经常使用到的技巧：</p>
<ul>
<li><p>根据某一标准建立一个比较器来排序</p>
</li>
<li><p>根据某一标准建立一个比较器来组成堆</p>
</li>
<li></li>
</ul>
</blockquote>
<h2 id="贪心–比较器"><a href="#贪心–比较器" class="headerlink" title="贪心–比较器"></a>贪心–比较器</h2><h3 id="会议安排"><a href="#会议安排" class="headerlink" title="会议安排"></a>会议安排</h3><blockquote>
<p>一些项目要占用会议室宣讲，会议室不能同时容纳两个项目的宣讲，给定每个回忆开始时间和结束时间（一个数组，数组元素是一个个项目），现在来安排宣讲日程，要求会议室进行的宣讲场次最多，返回这个最多的宣讲场次</p>
<p>贪心策略：会议结束时间早的先安排</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Program</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个比较器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProgramComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Program&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Program o1, Program o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//timePoint：此时的时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bestArrange</span><span class="params">(Program[] programs, <span class="type">int</span> timePoint)</span> &#123;</span><br><span class="line">        Arrays.sort(programs, <span class="keyword">new</span> <span class="title class_">ProgramComparator</span>());</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最终安排的会议数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; programs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timePoint &lt;= programs[i].start) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                timePoint = programs[i].end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="字典序最小"><a href="#字典序最小" class="headerlink" title="字典序最小"></a>字典序最小</h3><blockquote>
<p>给定一组字符串，将它们全部组合在一起，找到字典序最小的组合</p>
<p>贪心策略：字符串a，和字符串b，a+b的字典序如果小于b+a,就把a+b拼接在一起，如此循环</p>
<p>证明：要想证明此策略是正确的，本质上是证明这样一种排序方式是有传递性的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> (o1 + o1).compareTo(o2 + o1); <span class="comment">//compareTo：比较字典序</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">lowerString</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">MyComparator</span>());</span><br><span class="line">       <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">           res += strs[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>









<h3 id="卡车上最大单元数"><a href="#卡车上最大单元数" class="headerlink" title="卡车上最大单元数"></a>卡车上最大单元数</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-15%2011.25.16.png" alt="截屏2022-11-15 11.25.16" style="zoom:50%;" />



<p><strong>比较器</strong></p>
<p>这一题关键就是用比较器来从大到小排序二维数组，下面给出两种比较器声明方式，第一种是自己写的，是完整版，第二种是lambda表达式写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumUnits</span><span class="params">(<span class="type">int</span>[][] boxTypes, <span class="type">int</span> truckSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(boxTypes, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">1</span>] - o1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; boxTypes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (boxTypes[i][<span class="number">0</span>] &lt;= truckSize) &#123;</span><br><span class="line">                ans += boxTypes[i][<span class="number">0</span>] * boxTypes[i][<span class="number">1</span>];</span><br><span class="line">                truckSize -= boxTypes[i][<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += truckSize * boxTypes[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumUnits</span><span class="params">(<span class="type">int</span>[][] boxTypes, <span class="type">int</span> truckSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(boxTypes, (a, b) -&gt; b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; boxTypes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (boxTypes[i][<span class="number">0</span>] &lt;= truckSize) &#123;</span><br><span class="line">                ans += boxTypes[i][<span class="number">0</span>] * boxTypes[i][<span class="number">1</span>];</span><br><span class="line">                truckSize -= boxTypes[i][<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += truckSize * boxTypes[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="贪心–-数组"><a href="#贪心–-数组" class="headerlink" title="贪心– 数组"></a>贪心– 数组</h2><h3 id="交换一次的先前排列"><a href="#交换一次的先前排列" class="headerlink" title="交换一次的先前排列"></a>交换一次的先前排列</h3><blockquote>
<p>给你一个正整数数组 <code>arr</code>（可能存在重复的元素），请你返回可在 <strong>一次交换</strong>（交换两数字 <code>arr[i]</code> 和 <code>arr[j]</code> 的位置）后得到的、按字典序排列小于 <code>arr</code> 的最大排列。</p>
<p>如果无法这么操作，就请返回原数组。</p>
<p>LeetCode(1053)</p>
</blockquote>
<p><strong>贪心策略</strong></p>
<p>贪心策略：arr[i] 记为 A，arr[j] 记为 B</p>
<ol>
<li>A &gt; B 且 A 尽可能靠后</li>
<li>B 在 A 之后，且 B 尽可能大</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] prevPermOpt1(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 这样写 if 条件可以保证已遍历过的数组部分是非递减的</span></span><br><span class="line">            <span class="comment">// 有助于我们在找最大 arr[j] 的时候直接从后往前遍历</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// arr[j] == arr[j - 1] 是应对 3 1 1 3 这种情况</span></span><br><span class="line">                <span class="keyword">while</span> (arr[j] &gt;= arr[i] || arr[j] == arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h2 id="贪心–堆"><a href="#贪心–堆" class="headerlink" title="贪心–堆"></a>贪心–堆</h2><h3 id="切金条"><a href="#切金条" class="headerlink" title="切金条"></a>切金条</h3><blockquote>
<p>一块金条切成两半，是需要花费和长度数值一样的铜板的，比如长度为20的金条，不管切成长度多大的两半，都需要花费20铜板<br>一群人想整分整块金条，怎么分最省铜板？<br>例如给定数组{10, 20, 30} ，代表一共三个人，整块金条长度为10 + 20 + 30 &#x3D; 60， 金条要分成10，20，30三个部分，如果先把长度60的金条分成10和50，花费60，再把长度为50的金条分成20和30，花费50，一共花费110， 但如果先把长度60的金条分为30和30，花费60，再把30的金条分为10和20，花费30，一共花费90铜板。</p>
<p>输入一个数组，返回分割的最小代价</p>
<p>策略：典型的哈夫曼树编码，将数组扔到小根堆里，每次弹出两个最小的数，组成新的节点再扔到小根堆里，再重复此过程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lessMoney</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pQ = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            pQ.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//最小代价</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//每次弹出的两个值的和</span></span><br><span class="line">        <span class="keyword">while</span> (pQ.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cur = pQ.poll() + pQ.poll();</span><br><span class="line">            sum += cur;</span><br><span class="line">            pQ.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="项目收益"><a href="#项目收益" class="headerlink" title="项目收益"></a>项目收益</h3><blockquote>
<p>输入：<br>正数数组costs<br>正数数组profits<br>正数k<br>正数m</p>
<p>含义：<br>costs[i] 表示i号项目的花费<br>profits[i] 表示i号项目在扣除花费后还能挣到的钱（利润）<br>k表示只能串行的做最多k个项目<br>m表示初始资金</p>
<p>说明：<br>每做完一个项目获得的收益可以立马获得并且支持去做下一个项目</p>
<p>输出：最后获得的最大钱数</p>
<p>贪心策略：<br>首先判断现有资金能否完成项目，如果能够完成的话，优先完成能完成项目中的收益最大的项目，所以思路是准备两个堆，一个小根堆，一个大根堆，小根堆的作用是lock，初始时将所有的项目按花费锁在堆中，如多手头的钱足够完成项目，就弹出小根堆到大根堆里，大根队是按收益排序，每从大根堆里处理一次，就去扫描小根堆看看有没有符合要求的项目。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> cost;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> profit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> cost, <span class="type">int</span> profit)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cost = cost;</span><br><span class="line">            <span class="built_in">this</span>.profit = profit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MinCostComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Node&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.cost - o2.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MaxProfitComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Node&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.profit - o2.profit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span>[] profits, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Node&gt; minCostQ = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Node&gt; maxProfitQ = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//先将项目都放到花费小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">            minCostQ.add(<span class="keyword">new</span> <span class="title class_">Node</span>(costs[i], profits[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//将花费小于当前手头现金的项目弹到大根堆里</span></span><br><span class="line">            <span class="keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().cost &lt;= m) &#123;</span><br><span class="line">                maxProfitQ.add(minCostQ.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxProfitQ.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            m += maxProfitQ.poll().profit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><blockquote>
<p>leetcode : 55 , 跳跃游戏</p>
<p>题目描述：<br>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个下标<br>数组中的每个元素代表你在该位置可以跳跃的最大长度<br>判断你是否能够到达最后一个下标。</p>
</blockquote>
<p><strong>分析</strong><br>此题有一个核心的点是，每一个数组的元素值代表的是可以跳到的最远距离的范围，所以，只需要从左到右不断的遍历到此刻所能到达的最远距离去看看最远距离能否到达最远的元素即可同时不断更新最远距离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= maxDistance; i++) &#123;</span><br><span class="line">            maxDistance = maxDistance &gt; i + nums[i] ? maxDistance : i + nums[i];</span><br><span class="line">            <span class="keyword">if</span> (maxDistance &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="跳跃游戏-2"><a href="#跳跃游戏-2" class="headerlink" title="跳跃游戏_2"></a>跳跃游戏_2</h3><blockquote>
<p>Leetcode : <a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p>
<p>题目描述：<br>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>假设你总是可以到达数组的最后一个位置。</p>
</blockquote>
<p><strong>1. 巧妙的贪心策略</strong></p>
<p>这个贪心策略很巧妙，就是从最后一个元素开始往回推，看哪个元素能走到这里，往回推的策略就是一个巧妙的贪心–我们认为，靠左的元素的到达最后一个元素的步数更少。但这种方案时间复杂度较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                    position = i;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2. 正面推</strong></p>
<p>维护一个每次移动的边界以及最大距离，即可做到一次遍历得到结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 步数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 判断当前位置有没有到此次最大范围的边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDistance</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 可移动的最大距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            maxDistance = Math.max(maxDistance, i + nums[i]); <span class="comment">// 更新最大范围</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123; <span class="comment">// 如果移动范围已经到了更新前的距离边界，那就 步数++且更新end</span></span><br><span class="line">                ans++;</span><br><span class="line">                end = maxDistance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="最多排序块"><a href="#最多排序块" class="headerlink" title="最多排序块"></a>最多排序块</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-13%2011.28.17.png" alt="截屏2022-08-13 11.28.17" style="zoom:50%;" />



<p><strong>分析</strong></p>
<p>我一开始的思路是：每次找到数组中最小的数，因为每次划分一定要有最小值，不然就无法成功，但是在提交时意识到，并不一定有答案，比如：[2,0,1]这个数据，就无法通过我的思路<br>再看官方的贪心策略就高明很多:<br>即：一次合理的划分一定要满足最大值在最右边的块，所以可以用一个变量来记录当前遍历得到的最大值，由于数组的值和下标是对应的，所以直接判断最大值与当前遍历的下标是否一样，一样就说明当前遍历的最大值已经满足一个块了，就可以ans++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxChunksToSorted</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(arr[i], max);</span><br><span class="line">            <span class="keyword">if</span> (max == i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="最多排序块-2"><a href="#最多排序块-2" class="headerlink" title="最多排序块_2"></a>最多排序块_2</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-13%2011.49.38.png" alt="截屏2022-08-13 11.49.38" style="zoom:50%;" />



<p><strong>哈希 + 排序</strong></p>
<p>核心思想：arr 和 arr 的排序数组从左到右开始比较的话，如果能够划分成一个合理的块数，那么其词频应该是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxChunksToSorted</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法一：统计词频法</span></span><br><span class="line">        <span class="comment">// 用 HashMap统计词频</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化排序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, visited, <span class="number">0</span>, arr.length);</span><br><span class="line">        Arrays.sort(visited);</span><br><span class="line">        <span class="comment">// 开始循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> arr[i], v = visited[i];</span><br><span class="line">            map.put(a, map.getOrDefault(a, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(a) == <span class="number">0</span>) &#123;</span><br><span class="line">                map.remove(a);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(v, map.getOrDefault(v, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(v) == <span class="number">0</span>) &#123;</span><br><span class="line">                map.remove(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>单调栈</strong></p>
<p>维护一个记录所有逻辑上分块的最大值的栈，当来到一个新的num时，找到最大值小于它的那个块，然后这个快之前的所有块都要融合成一个块，再把原来最大值push进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxChunksToSorted</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 单调栈法</span></span><br><span class="line">        <span class="comment">// 这个栈的元素是逻辑上分块的最大值！最后返回栈的size（）就是最终答案</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素比最大值大或者栈非空就加入新的值</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || num &gt;= stack.peek()) &#123;</span><br><span class="line">                stack.push(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到下一个大于其最大值的块</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &lt; stack.peek()) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><blockquote>
<p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/non-overlapping-intervals">https://leetcode.cn/problems/non-overlapping-intervals</a></p>
<p>此题类似于：646. 最长数对链<br><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/">https://leetcode.cn/problems/maximum-length-of-pair-chain/</a></p>
</blockquote>
<p><strong>动态规划</strong></p>
<p>这题用动态规划执行效率比较低，超出时间限制，但是作为一个经典思路，以及对二维数组比较器的学习，将代码拿过来。<br>主要思路是：先按数组的第一列从小到大排序，然后找出动态转移方程就是：到第 i 个区间的可以找到多少个不重叠区间取决于第 i-1个区间可以有多少个不重叠区间且如果 i-1 的右端点小于等于 i 区间的左端点，那么可组成的不重叠区间就 + 1<br>最终返回区间总数 - 缓存数组的最大值就好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自定义一个比较器，按第一列排序二维数组</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a1[<span class="number">0</span>] - a2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="comment">// 缓存数组</span></span><br><span class="line">        <span class="comment">// flush数组元素的含义是当前元素之前的不重叠区间的个数以及判断当前是否属可加入这个区间</span></span><br><span class="line">        <span class="type">int</span>[] flush = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(flush, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (intervals[j][<span class="number">1</span>] &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    flush[i] = Math.max(flush[i], flush[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - Arrays.stream(flush).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>贪心</strong></p>
<p>贪心可以理解为上述动态规划算法的优化<br>我们可以隐约看出一点：那就是最优不重叠区间序列的左端点一定是右端点最小的那个区间，这很好理解，而且这一结论是递归的<br>所以我们可以按右端点进行排序，然后遍历到的区间的最左端点就是最优序列的左端点！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与动归不同，这个是按照第二列也就是右端点大小来排序的</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a1[<span class="number">1</span>] - a2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="comment">// 维护一个右端点以及总数即可，不需要一个数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="最低支付工资"><a href="#最低支付工资" class="headerlink" title="最低支付工资"></a>最低支付工资</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-11%2009.55.32.png" alt="截屏2022-09-11 09.55.32" style="zoom:50%;" />











<h3 id="最大交换"><a href="#最大交换" class="headerlink" title="最大交换"></a>最大交换</h3><blockquote>
<p>给定一个非负整数，你<strong>至多</strong>可以交换一次数字中的任意两位。返回你能得到的最大值。</p>
</blockquote>
<p><strong>暴力全交换</strong></p>
<p>这个方法效率显而易见的低，但是实现思路还是有意思，String和Integer的相互转化以及交换策略都是值得看一下的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] charArray = String.valueOf(num).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> charArray.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                swap(charArray, i, j);</span><br><span class="line">                max = Math.max(max, Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(charArray)));</span><br><span class="line">                swap(charArray, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>贪心</strong></p>
<p>贪心策略：从右往左一次遍历，记录最大值的index，同时判断当前index和最大index的数位大小，如果当前的index数字比maxIndex小，那么就把这两个数交换，得到的数一定比原来的数大，经过一轮这样操作后，得到的最大数即为答案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      <span class="comment">// 从右往左找到最大的</span></span><br><span class="line">      <span class="type">char</span>[] charArray = String.valueOf(num).toCharArray();</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> charArray.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">maxId</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> num;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (charArray[i] &gt; charArray[maxId]) &#123;</span><br><span class="line">              maxId = i;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charArray[i] &lt; charArray[maxId]) &#123;</span><br><span class="line">              swap(charArray, i, maxId);</span><br><span class="line">              <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(charArray));</span><br><span class="line">              swap(charArray, i, maxId);</span><br><span class="line">              maxNum = maxNum &gt; cur ? maxNum : cur;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> maxNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] charArray, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">        charArray[i] = charArray[j];</span><br><span class="line">        charArray[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码是我自己写的，很明显的是，每次比较都会经历一次交换数字以及Integer 和 String 转化的过程，比较蠢，所以可用以下手段优化, 可以用记录数对的方式，记录最大数的交换的index，这样只用一次判断加一次转化，即可完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      <span class="comment">// 从右往左找到最大的</span></span><br><span class="line">      <span class="type">char</span>[] charArray = String.valueOf(num).toCharArray();</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> charArray.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">maxId</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 记录需要交换的数字的下标</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">idx1</span> <span class="operator">=</span> -<span class="number">1</span>, idx2 = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (charArray[i] &gt; charArray[maxId]) &#123;</span><br><span class="line">              maxId = i;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charArray[i] &lt; charArray[maxId]) &#123;</span><br><span class="line">              idx1 = i;</span><br><span class="line">              idx2 = maxId;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (idx1 != -<span class="number">1</span>) &#123;</span><br><span class="line">          swap(charArray, idx1, idx2);</span><br><span class="line">          <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(charArray));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> num;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] charArray, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">        charArray[i] = charArray[j];</span><br><span class="line">        charArray[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="最少括号添加"><a href="#最少括号添加" class="headerlink" title="最少括号添加"></a>最少括号添加</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-04%2022.01.54.png" alt="截屏2022-10-04 22.01.54" style="zoom:50%;" />



<p><strong>贪心</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minAddToMakeValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="comment">// 专注于一个括号的匹配情况来进行贪心</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">leftcnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">              leftcnt++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (leftcnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  leftcnt--;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  ans++;</span><br><span class="line">              &#125;              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans + leftcnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="最小小球操作数"><a href="#最小小球操作数" class="headerlink" title="最小小球操作数"></a>最小小球操作数</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-12-02%2010.28.28.png" alt="截屏2022-12-02 10.28.28" style="zoom:50%;" />



<p><strong>策略</strong></p>
<p>最快速的策略是直接用上一个位置的操作数以及当前位置的状态来得出当前位置的操作数<br>详细来说就是：假设 i 位置的操作数是 operationsi ，i + 1位置左边的小球数是 left, 右边的小球数是 right， 那么当前位置的操作数是 oerations + left - right ，因为所有左边的小球都要多移动一位，右边的小球少移动一位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] minOperations(String boxes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> boxes.length();</span><br><span class="line">        <span class="comment">// 初始化左边小球数是第一个盒子的状态（因为后面的遍历都从1开始)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> boxes.charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>, right = <span class="number">0</span>, operations = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化右边的小球数以及操作数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (boxes.charAt(i) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                right ++;</span><br><span class="line">                operations += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        ans[<span class="number">0</span>] = operations;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            operations += left - right;</span><br><span class="line">            <span class="keyword">if</span> (boxes.charAt(i) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = operations;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="能组成的最大整数"><a href="#能组成的最大整数" class="headerlink" title="能组成的最大整数"></a>能组成的最大整数</h3><blockquote>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的 <code>n</code> 个硬币。第 <code>i</code> 个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 <code>x</code> ，那么称，你可以 <strong>构造</strong> 出 <code>x</code> 。</p>
<p>请返回从 <code>0</code> 开始（<strong>包括</strong> <code>0</code> ），你最多能 <strong>构造</strong> 出多少个连续整数。</p>
<p>你可能有多个相同值的硬币。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaximumConsecutive</span><span class="params">(<span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        假设当前若干硬币可以组成的最大连续整数范围是 [0, x]</span></span><br><span class="line"><span class="comment">        那么当加上 y 时，其能组成的整数范围是 [0, x] 和 [y, y + x]</span></span><br><span class="line"><span class="comment">        要使加上的这个 y 有效果， x + 1 就必须在 [y, y + x]中</span></span><br><span class="line"><span class="comment">        则 y &lt;= x + 1</span></span><br><span class="line"><span class="comment">        则 y &gt; n</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; x + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x += y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为什么都取也是一种方法，所以要 + 1</span></span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="和有限的最长子序列"><a href="#和有限的最长子序列" class="headerlink" title="和有限的最长子序列"></a>和有限的最长子序列</h3><blockquote>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，和一个长度为 <code>m</code> 的整数数组 <code>queries</code> 。</p>
<p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是 <code>nums</code> 中元素之和小于等于 <code>queries[i]</code> 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度 。</p>
<p><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</p>
<p>LeetCode: 2389</p>
</blockquote>
<p><strong>我的方法</strong></p>
<p>这道题是一道简单题，我自己写的方法是比较直观的了，因为是子序列，且只要子序列的长度，所以直接排序，然后两层for去处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] answerQueries(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, m = nums.length; j &lt; m; j++) &#123;</span><br><span class="line">                cnt += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; queries[i]) &#123;</span><br><span class="line">                    ans[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    ans[i] = m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>前缀和 + 二分查找</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      前缀和 f[i] + 二分查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] answerQueries(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, q = queries.length;</span><br><span class="line">        <span class="comment">// 声明前缀和数组并初始化</span></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>] = f[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            ans[i] = binarySearch(f, queries[i]) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用二分法找到前缀和数组中最小的大于 target 的元素，其下标就是ans</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] f, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = f.length;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 这个二分的 if 可以好好琢磨一下，high 和 mid 的赋值有讲究</span></span><br><span class="line">            <span class="keyword">if</span> (f[mid] &gt; target) &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="字母与数字"><a href="#字母与数字" class="headerlink" title="字母与数字"></a>字母与数字</h3><blockquote>
<p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p>
<p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p>
<p>LeetCode(面试题17.05) </p>
</blockquote>
<p><strong>前缀和基础版</strong></p>
<p>核心思想如下：</p>
<ul>
<li>转换思想：遍历数组，遇到字母++，遇到数字–，这样题目就变成了求前缀和为0的最长子数组了</li>
<li>求前缀和为0的最长子数组，即求两个前缀和之差为0且下标差最大的子数组，求前缀和之差为 0 等价于求前缀和相同的两个下标</li>
<li>在遍历的同时，用一个数组或哈希表记录某个前缀和首次出现的位置，我们要找的就是 i - first[sum] 的最大值</li>
<li>对于任意小写&#x2F;大写英文字母字符，其 ASCII 码的二进制都形如 01xxxxxx；对于任意数字字符，其 ASCII 码的二进制都形如0011xxxx。根据这一特点，可以根据二进制从低到高第 6 位（设二进制最低位是第 0 位）是 0还是 1 来判断：如果是 1 就是小写&#x2F;大写英文字母字符，如果是 0 就是数字字符。把字符的二进制右移 6 位再 AND 1 就可以得到这个比特值。然后再通过 x2−1 的操作，把 1 转换成 1，0 转换成 −1。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 前缀数组的第一个元素默认是 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] + (array[i].charAt(<span class="number">0</span>) &gt;&gt; <span class="number">6</span> &amp; <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>; <span class="comment">// 声明符合要求的子数组</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; first = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> first.getOrDefault(s[i], -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                first.put(s[i], i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i - j &gt; end - begin)&#123;</span><br><span class="line">                begin = j;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] sub = <span class="keyword">new</span> <span class="title class_">String</span>[end - begin];</span><br><span class="line">        System.arraycopy(array, begin, sub, <span class="number">0</span>, sub.length);</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>优化-官方</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, maxLength = <span class="number">0</span>, startIdx = <span class="number">0</span>, n = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果是字母前缀和++，数字前缀和--</span></span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(array[i].charAt(<span class="number">0</span>))) sum++;</span><br><span class="line">            <span class="keyword">else</span> sum--;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">firstIdx</span> <span class="operator">=</span> map.get(sum);</span><br><span class="line">                <span class="keyword">if</span> (i - firstIdx &gt; maxLength) &#123;</span><br><span class="line">                    maxLength = i - firstIdx;</span><br><span class="line">                    startIdx = firstIdx + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxLength == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[maxLength];</span><br><span class="line">        System.arraycopy(array, startIdx, res, <span class="number">0</span>, maxLength);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>优化-前缀和数组和Hash</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length, begin = <span class="number">0</span>, end = <span class="number">0</span>, s = n;</span><br><span class="line">        <span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(first, -<span class="number">1</span>); <span class="comment">// 注：去掉可以再快 1ms（需要 s 下标改从 1 开始）</span></span><br><span class="line">        first[s] = <span class="number">0</span>; <span class="comment">// s[0] = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            s += (array[i - <span class="number">1</span>].charAt(<span class="number">0</span>) &gt;&gt; <span class="number">6</span> &amp; <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> first[s];</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                first[s] = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i - j &gt; end - begin) &#123;</span><br><span class="line">                begin = j;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>[end - begin];</span><br><span class="line">        System.arraycopy(array, begin, sub, <span class="number">0</span>, sub.length);</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><hr>
<h2 id="堆应用"><a href="#堆应用" class="headerlink" title="堆应用"></a>堆应用</h2><h3 id="找中位数"><a href="#找中位数" class="headerlink" title="找中位数"></a>找中位数</h3><blockquote>
<p>在一个数据流中可以随时取得中位数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MidNum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MinNumComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MaxNumComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minNum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; bigger = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MaxNumComparator</span>());</span><br><span class="line">        PriorityQueue&lt;Integer&gt; smaller = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MinNumComparator</span>());</span><br><span class="line">        bigger.add(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//当</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= bigger.peek()) &#123;</span><br><span class="line">                bigger.add(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                smaller.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当两个堆的size大小差距超过2就进行调整</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(bigger.size() - smaller.size()) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bigger.size() &gt; smaller.size()) &#123;</span><br><span class="line">                    smaller.add(bigger.poll());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bigger.add(smaller.poll());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midNum</span> <span class="operator">=</span> nums.length % <span class="number">2</span> == <span class="number">1</span> ?</span><br><span class="line">                (bigger.size() &gt; smaller.size() ? bigger.poll() : smaller.poll()) :</span><br><span class="line">                ((bigger.poll() + smaller.poll()) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> midNum;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















<h2 id="堆的改进"><a href="#堆的改进" class="headerlink" title="堆的改进"></a>堆的改进</h2><h3 id="Dijkstra改进"><a href="#Dijkstra改进" class="headerlink" title="Dijkstra改进"></a>Dijkstra改进</h3><blockquote>
<p>将disctance放在小根堆中，每次改完distance后重新放在堆中，这样的一个堆无法使用系统提供的堆结构，需要自己改造堆结构来满足需求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeRecord</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Node node;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> distance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NodeRecord</span><span class="params">(Node node, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">        <span class="built_in">this</span>.distance = distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeHeap</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node[] nodes; <span class="comment">//所有的节点放在数组里面（堆的底层结构是数组）</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap; <span class="comment">//节点在堆中的位置</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap; <span class="comment">// 节点目前到head的最短距离</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">//目前这个堆上有多少个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NodeHeap</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[size];</span><br><span class="line">            heapIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrUpdateOrIgnore</span><span class="params">(Node node, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inHeap(node)) &#123;</span><br><span class="line">                distanceMap.put(node, Math.min(distanceMap.get(node), distance));</span><br><span class="line">                insertHeapify(node, heapIndexMap.get(node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEntered(node)) &#123;</span><br><span class="line">                nodes[size] = node;</span><br><span class="line">                heapIndexMap.put(node, size);</span><br><span class="line">                distanceMap.put(node, distance);</span><br><span class="line">                insertHeapify(node, size++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> NodeRecord <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">NodeRecord</span> <span class="variable">nodeRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeRecord</span>(nodes[<span class="number">0</span>], distanceMap.get(nodes[<span class="number">0</span>]));</span><br><span class="line">            swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">            heapIndexMap.put(nodes[size - <span class="number">1</span>], -<span class="number">1</span>);</span><br><span class="line">            distanceMap.remove(nodes[size - <span class="number">1</span>]);</span><br><span class="line">            nodes[size - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">            heapify(<span class="number">0</span>, --size);</span><br><span class="line">            <span class="keyword">return</span> nodeRecord;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断一个节点有没有进来过</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEntered</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> heapIndexMap.containsKey(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertHeapify</span><span class="params">(Node node, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[index - <span class="number">1</span>]) / <span class="number">2</span>) &#123;</span><br><span class="line">                swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">                index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="number">1</span>]) &lt; distanceMap.get(nodes[left])</span><br><span class="line">                        ? left + <span class="number">1</span> : left;</span><br><span class="line">                smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;</span><br><span class="line">                <span class="keyword">if</span> (smallest == index) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(smallest, index);</span><br><span class="line">                index = smallest;</span><br><span class="line">                left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断节点是否在堆上</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inHeap</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换调整堆</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">            heapIndexMap.put(nodes[index1], index2);</span><br><span class="line">            heapIndexMap.put(nodes[index2], index1);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> nodes[index1];</span><br><span class="line">            nodes[index1] = nodes[index2];</span><br><span class="line">            nodes[index2] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//改进后的dijkstra算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title function_">dijkstra2</span><span class="params">(Node head, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">NodeHeap</span> <span class="variable">nodeHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeHeap</span>(size);</span><br><span class="line">        nodeHeap.addOrUpdateOrIgnore(head, <span class="number">0</span>);</span><br><span class="line">        HashMap&lt;Node, Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!nodeHeap.isEmpty()) &#123;</span><br><span class="line">            <span class="type">NodeRecord</span> <span class="variable">record</span> <span class="operator">=</span> nodeHeap.pop();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> record.node;</span><br><span class="line">            <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> record.distance;</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : cur.edges) &#123;</span><br><span class="line">                nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);</span><br><span class="line">            &#125;</span><br><span class="line">            result.put(cur, distance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>













<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="最大平均通过率"><a href="#最大平均通过率" class="headerlink" title="最大平均通过率"></a>最大平均通过率</h3><blockquote>
<p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 <code>classes</code> ，其中 <code>classes[i] = [passi, totali]</code> ，表示你提前知道了第 <code>i</code> 个班级总共有 <code>totali</code> 个学生，其中只有 <code>passi</code> 个学生可以通过考试。</p>
<p>给你一个整数 <code>extraStudents</code> ，表示额外有 <code>extraStudents</code> 个聪明的学生，他们 <strong>一定</strong> 能通过任何班级的期末考。你需要给这 <code>extraStudents</code> 个学生每人都安排一个班级，使得 <strong>所有</strong> 班级的 <strong>平均</strong> 通过率 <strong>最大</strong> 。</p>
<p>一个班级的 <strong>通过率</strong> 等于这个班级通过考试的学生人数除以这个班级的总人数。<strong>平均通过率</strong> 是所有班级的通过率之和除以班级数目。</p>
<p>请你返回在安排这 <code>extraStudents</code> 个学生去对应班级后的 <strong>最大</strong> 平均通过率。与标准答案误差范围在 <code>10-5</code> 以内的结果都会视为正确结果。</p>
</blockquote>
<p><strong>数学分析可知：</strong><br><strong>a + 1 &#x2F; b + 1 &lt; a &#x2F; b</strong><br><strong>所以应该每次挑出其中通过率最小的那个班级分子分母加 1 后再放回去，继续和其他班级的通过率比较，每次拿出最大的，所以考虑使用数据结构：优先队列，也就是大根堆，由于java的优先队列默认是小根堆，所以要定制化一下初始化方法.</strong><br><strong>其中,满足以下条件时，j比i的优先级更高(j 班级的通过率大于 i 班级)：</strong><br><strong>passi + 1 &#x2F; totali + 1 &lt; passj + 1 &#x2F; totalj + 1,    化简后可得：</strong><br><strong>(totalj+1)×(totalj)×(totali−passi)&lt;(totali+1)×(totali)×(totalj−passj)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">maxAverageRatio</span><span class="params">(<span class="type">int</span>[][] classes, <span class="type">int</span> extraStudents)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明优先队列，定制取根逻辑</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">val1</span> <span class="operator">=</span> (<span class="type">long</span>)(b[<span class="number">1</span>] + <span class="number">1</span>) * b[<span class="number">1</span>] * (a[<span class="number">1</span>] - a[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">val2</span> <span class="operator">=</span> (<span class="type">long</span>)(a[<span class="number">1</span>] + <span class="number">1</span>) * a[<span class="number">1</span>] * (b[<span class="number">1</span>] - b[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (val1 == val2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val2 &gt; val1 ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将当前班级逐个加入到优先队列中，会自动调lambda方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] c : classes) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;c[<span class="number">0</span>], c[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始将 extraStudents 加入到优先队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; extraStudents; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pass</span> <span class="operator">=</span> arr[<span class="number">0</span>], total = arr[<span class="number">1</span>];</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;pass + <span class="number">1</span>, total + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历优先队列，计算总平均通过率</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classes.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pass</span> <span class="operator">=</span> arr[<span class="number">0</span>], total = arr[<span class="number">1</span>];</span><br><span class="line">            ans += <span class="number">1.0</span> * pass / total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / classes.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="距离相等的条形码"><a href="#距离相等的条形码" class="headerlink" title="距离相等的条形码"></a>距离相等的条形码</h3><blockquote>
<p>在一个仓库里，有一排条形码，其中第 <code>i</code> 个条形码为 <code>barcodes[i]</code>。</p>
<p>请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p>
<p>LeetCode 1054 (medium)</p>
</blockquote>
<p><strong>大根堆</strong></p>
<p>采用的排列策略是：每次优先将数量最多的那个元素做排列，实在不行就出现频次第二多的排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] rearrangeBarcodes(<span class="type">int</span>[] barcodes) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : barcodes) &#123;</span><br><span class="line">            cnt.put(i, cnt.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="number">0</span>] - a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getValue(), entry.getKey()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> barcodes.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] p = pq.poll();</span><br><span class="line">            <span class="comment">// 如果 i == 0或前一个元素不等于频率最大的元素，就拿当前频率最大的元素去排</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || res[i - <span class="number">1</span>] != p[<span class="number">1</span>]) &#123;</span><br><span class="line">                res[i] = p[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (p[<span class="number">0</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;p[<span class="number">0</span>] - <span class="number">1</span>, p[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就拿频率第二的元素排</span></span><br><span class="line">                <span class="type">int</span>[] q = pq.poll();</span><br><span class="line">                res[i] = q[<span class="number">1</span>]; </span><br><span class="line">                <span class="keyword">if</span> (q[<span class="number">0</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;q[<span class="number">0</span>] - <span class="number">1</span>, q[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                pq.offer(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><hr>
<blockquote>
<p>什么是动态规划：</p>
<ul>
<li>空间换时间</li>
<li>如果有重复调用的子过程，那就把子过程执行结果记下来，下次遇到直接调用</li>
</ul>
<p>在写动态规划题目时，一般来说是三部曲，一开始是自己分析开始尝试，然后加入缓存优化，如果可以的话最后维护dp表<br>将递归行为替换为dp表里拿值</p>
</blockquote>
<h2 id="dp三部曲案例"><a href="#dp三部曲案例" class="headerlink" title="dp三部曲案例"></a>dp三部曲案例</h2><h3 id="分隔数组得最大和"><a href="#分隔数组得最大和" class="headerlink" title="分隔数组得最大和"></a>分隔数组得最大和</h3><blockquote>
<p>给你一个整数数组 <code>arr</code>，请你将该数组分隔为长度 <strong>最多</strong> 为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。</p>
<p>返回将数组分隔变换后能够得到的元素最大和。本题所用到的测试用例会确保答案是一个 32 位整数。</p>
<p>LeetCode 1043</p>
</blockquote>
<p><strong>基本递归</strong></p>
<p>以 [1,15,7,9,2,5,10]，k &#x3D; 3 为例，我们从后往前遍历，当遍历到 10 时，我们可以分割的数组有三种可能性，[10], [5, 10], [2, 5, 10], 我们分别计算这些数组的最大值后，继续在不同的可能性往下计算，可以想象出遍历的过程大致为树状，所以采用递归来做<br>但是这种算法会超时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="keyword">return</span> dfs(arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, mx = <span class="number">0</span>; j &gt; i - k &amp;&amp; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            mx = Math.max(mx, arr[j]); <span class="comment">// 计算当前的最大值</span></span><br><span class="line">            ans = Math.max((i - j + <span class="number">1</span>) * mx + dfs(j - <span class="number">1</span>), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>递归优化</strong></p>
<p>加入缓存数组，将最优解缓存至数组，以空间换时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr, memo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="keyword">return</span> dfs(arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, mx = <span class="number">0</span>; j &gt; i - k &amp;&amp; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            mx = Math.max(mx, arr[j]); <span class="comment">// 计算当前的最大值</span></span><br><span class="line">            ans = Math.max((i - j + <span class="number">1</span>) * mx + dfs(j - <span class="number">1</span>), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>翻译成 dp 递推形式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, mx = <span class="number">0</span>; j &gt;= <span class="number">0</span> &amp;&amp; j &gt; i - k; j--) &#123;</span><br><span class="line">                mx = Math.max(mx, arr[j]);</span><br><span class="line">                f[i + <span class="number">1</span>] = Math.max(f[j] + (i - j + <span class="number">1</span>) * mx, f[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优化</strong></p>
<p>还没彻底掌握</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">var</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, mx = <span class="number">0</span>; j &gt; i - k &amp;&amp; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                mx = Math.max(mx, arr[j]); <span class="comment">// 一边枚举 j，一边计算子数组的最大值</span></span><br><span class="line">                <span class="comment">// 注意在循环结束前，f[(i+1)%k] 是需要用到的，不能提前覆盖</span></span><br><span class="line">                res = Math.max(res, f[j % k] + (i - j + <span class="number">1</span>) * mx);</span><br><span class="line">            &#125;</span><br><span class="line">            f[(i + <span class="number">1</span>) % k] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n % k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h3 id="一位机器人左右走"><a href="#一位机器人左右走" class="headerlink" title="一位机器人左右走"></a>一位机器人左右走</h3><blockquote>
<p>给定参数：N，start， aim，K<br>N：给定的一位数组位置数，从1到N<br>start：机器人从哪个位置出发<br>aim：机器人的目的地<br>K：机器人走K步到目的地</p>
<p>问：机器人智能左右走，从start走到aim用K步，有多少种方案，返回方案数</p>
</blockquote>
<p><strong>暴力尝递归法</strong><br>暴力递归是存在大量重复解的问题的，例如我们从7开始走还剩10步，那么会调用（6，9）和（8，9）<br>（6，9）会调用（5，8）和（7，8）<br>（8，9）会调用（7，8）和（9，8）<br>（7，8）就被重复调用了，所以动态规划需要解决重复解问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways1</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> process1(start, K, aim, N);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//cur：当前位置</span></span><br><span class="line">   <span class="comment">//rest：剩余位置</span></span><br><span class="line">   <span class="comment">//aim：目的地</span></span><br><span class="line">   <span class="comment">//N：1到N个位置</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123; <span class="comment">//base case， 如果剩下的位置为0，说明K步走完</span></span><br><span class="line">           <span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 如果此时的位置是aim，那就是一种方案，否则就不是</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果rest大于0，还有步数要走</span></span><br><span class="line">       <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123; <span class="comment">//当走到1时没有别的选择，只能去2</span></span><br><span class="line">           <span class="keyword">return</span> process1(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (cur == N) &#123; <span class="comment">// 当走到N时，只能去N-1</span></span><br><span class="line">           <span class="keyword">return</span> process1(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> process1(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N) + process1(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>动态规划：记忆化搜索｜自顶向下的动态规划</strong><br>用一个dp二维数组记录每一种状态下的可能性有没有被走过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways2</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">               dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//dp[][]就是缓存表</span></span><br><span class="line">       <span class="comment">//dp[cur][rest] == -1 -&gt; process(cur, rest)之前没算过</span></span><br><span class="line">       <span class="comment">//dp[cur][rest] != -1 -&gt; process(cur, rest)之前算过，返回值就是dp[cur][rest]</span></span><br><span class="line">       <span class="keyword">return</span> process2(start, K, aim, N, dp);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//cur范围：1到N</span></span><br><span class="line">   <span class="comment">//rest范围：0到K</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim, <span class="type">int</span> N, <span class="type">int</span> dp[][])</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (dp[cur][rest] != -<span class="number">1</span>) &#123; <span class="comment">//缓存命中</span></span><br><span class="line">           <span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">           ans = process2(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">           ans = process2(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          ans = process2(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp) + process2(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">       &#125;</span><br><span class="line">       dp[cur][rest] = ans;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>动态规划：最终优化版本</strong><br>动态规划不是原因只是结果，维护一张dp表，找到引起变化的两个元素作为二维表的两个维度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways3</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//设置好dp[cur][rest]枚举数据的初始值</span></span><br><span class="line">        <span class="comment">//只有rest == 0，cur == aim的时候dp的值才为1</span></span><br><span class="line">        dp[aim][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp填表</span></span><br><span class="line">        <span class="comment">//从左到右，从上往下填</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= K; rest++) &#123; <span class="comment">//从第一列开始填</span></span><br><span class="line">            dp[<span class="number">1</span>][rest] = dp[<span class="number">2</span>][rest - <span class="number">1</span>]; <span class="comment">//当位置在1时只依赖于位置2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">2</span>; cur &lt; N; cur++) &#123;</span><br><span class="line">                dp[cur][rest] = dp[cur - <span class="number">1</span>][rest - <span class="number">1</span>] + dp[cur + <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[N][rest] = dp[N - <span class="number">1</span>][rest - <span class="number">1</span>]; <span class="comment">//当位置在N时只依赖于位置N-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[start][K];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="左右纸牌问题"><a href="#左右纸牌问题" class="headerlink" title="左右纸牌问题"></a>左右纸牌问题</h3><blockquote>
<p>和 递归4.3.4 一样</p>
<p>给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，玩家A和玩家B都绝顶聪明。返回最后获胜者的分数。</p>
</blockquote>
<p><strong>递归法：自然分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据规则返回获胜者的分数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> before(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> after(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在arr[L,,,R]返回上，先手获得的最好分数返回</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">before</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (L == R) &#123; <span class="comment">// 最后一张牌的情况下，base case</span></span><br><span class="line">           <span class="keyword">return</span> arr[L];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//下面这两步和先手的思路不一样，不是后手的人在&quot;尝试&quot;，而是被迫在做决定</span></span><br><span class="line">       <span class="comment">//因为这样个人都很聪明，所以后手的是一定拿的是在L和R的情况下，先手拿的结果中自己哪怕尽力争取也是最小的那个</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> arr[L] + after(arr, L + <span class="number">1</span>, R);</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> arr[R] + after(arr, L, R - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在arr[L,,,R]返回上，后手获得的最好分数返回</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">after</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> before(arr, L + <span class="number">1</span>, R); <span class="comment">//对方先手拿走了L，只能在L+1里先手拿大的</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> before(arr, L, R - <span class="number">1</span>); <span class="comment">//对方先手拿了R， 只能在R-1里先手拿小的</span></span><br><span class="line">       <span class="keyword">return</span> Math.min(p1, p2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<p><strong>缓存优化</strong><br>自然分析法在调用时会有调用重复，这里加入了缓存优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓存优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[][] beforeMap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">        <span class="type">int</span>[][] afterMap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">//没算过的都是-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                beforeMap[i][j] = -<span class="number">1</span>;</span><br><span class="line">                afterMap[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> before2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, beforeMap, afterMap);</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> after2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, beforeMap, afterMap);</span><br><span class="line">        <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">before2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[][] beforeMap, <span class="type">int</span>[][] afterMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeMap[L][R] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> beforeMap[L][R];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            ans = arr[L];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> arr[L] + after2(arr, L + <span class="number">1</span>, R, beforeMap, afterMap);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> arr[R] + after2(arr, L, R - <span class="number">1</span>, beforeMap, afterMap);</span><br><span class="line">            ans = Math.max(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        beforeMap[L][R] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">after2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[][] beforeMap, <span class="type">int</span>[][] afterMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (afterMap[L][R] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> afterMap[L][R];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L != R) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> before2(arr, L + <span class="number">1</span>, R, beforeMap, afterMap);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> before2(arr, L, R - <span class="number">1</span>, beforeMap, afterMap);</span><br><span class="line">            ans = Math.min(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        afterMap[L][R] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>终极动态规划</strong><br>先找两张表的边界（base case），再找两张表的每个点的依赖<br>dp表的含义是理解问题和解决问题的关键，最先填好两张表的对角线的位置（即递归的base case），然后再往回推，相当于这个表记录的是递归在完成了第一次深入后的返回的时候的值的记录！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win3</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">       <span class="type">int</span>[][] beforeMap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">       <span class="type">int</span>[][] afterMap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">       <span class="comment">//给对角线也就是base case ： L == R赋值</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">           beforeMap[i][i] = arr[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//因为每个点的依赖和左边和下边的点相关</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> <span class="number">1</span>; startCol &lt; N; startCol++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> startCol;</span><br><span class="line">           <span class="keyword">while</span> (R &lt; N) &#123;</span><br><span class="line">               beforeMap[L][R] = Math.max(arr[L] + afterMap[L + <span class="number">1</span>][R], arr[R] + afterMap[L][R - <span class="number">1</span>]);</span><br><span class="line">               afterMap[L][R] = Math.min(beforeMap[L + <span class="number">1</span>][R], beforeMap[L][R - <span class="number">1</span>]);</span><br><span class="line">               <span class="comment">//实现对角线往下爬</span></span><br><span class="line">               L++;</span><br><span class="line">               R++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(beforeMap[<span class="number">0</span>][N - <span class="number">1</span>], afterMap[<span class="number">0</span>][N - <span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h3 id="装袋最大重量-1"><a href="#装袋最大重量-1" class="headerlink" title="装袋最大重量"></a>装袋最大重量</h3><blockquote>
<p>给定两个长度为N的数组weights[i] 和 values[i] 分别代表i号物品的重量和价值，给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量，返回你能装下最多的价值是多少？</p>
</blockquote>
<p><strong>递归写法见4.2.3 相同问题</strong><br>典型的从左往右尝试模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> process(w, v, <span class="number">0</span>, bag);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//尝试函数</span></span><br><span class="line">   <span class="comment">//当前考虑到了index号货，index往后的货物可以自由选择，返回value</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> index, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (bag &lt; <span class="number">0</span>) &#123; <span class="comment">//不是&lt;=是因为以防有的货物重量为0</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (index == w.length) &#123; <span class="comment">//没货了</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//bag还有空间</span></span><br><span class="line">       <span class="comment">//index有货</span></span><br><span class="line">       <span class="comment">//不要当前的货</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, bag);</span><br><span class="line">       <span class="comment">//要当前货物</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span>  process(w, v, index + <span class="number">1</span>, bag - w[index]);</span><br><span class="line">       <span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">           p2 = v[index] + next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>调优：</strong><br>主函数的参数w和v是固定的，所以递归的变化取决于index和bag，所以优化从这两个变量入手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> w.length;</span><br><span class="line">       <span class="comment">//index o~N</span></span><br><span class="line">       <span class="comment">//rest 0~bag</span></span><br><span class="line">       <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line">       <span class="comment">//之所以让dp数组是N+1行是因为我们需要多出来的一行来判断index是否超过了w数组长度</span></span><br><span class="line">       <span class="comment">//所以p数组的第N行（最后一行为0）所以就不用赋值了，因为java默认为0</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= bag; rest++) &#123;</span><br><span class="line">               <span class="comment">//dp的状态转移方程由暴力递归的逻辑决定</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][rest];</span><br><span class="line">               <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">               <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> rest - w[index] &lt; <span class="number">0</span>? -<span class="number">1</span> : dp[index + <span class="number">1</span>][rest - w[index]];</span><br><span class="line">               <span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">                   p2 = next + v[index];</span><br><span class="line">               &#125;</span><br><span class="line">               dp[index][rest] = Math.max(p1, p2);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h3 id="数字和字符转化"><a href="#数字和字符转化" class="headerlink" title="数字和字符转化"></a>数字和字符转化</h3><blockquote>
<p>规定 1 和 A对应、2 和 B对应、3 和 C对应</p>
<p>那么一个数字字符串比如“111” 就可以转化为“AAA“、“KA”、“AK”<br>给定一个只有数字组成的字符串，返回有多少种转化结果</p>
<p>思路：找到适当的决策</p>
<ol>
<li>只要任意位置上的数字不是0，就可以找到一个字母与之对应</li>
<li>如果i位置上的字符是3到9之间的数字，那么仅可以做一个决定</li>
<li>如果i是1的话，那么有两种方案</li>
<li>如果i是2的话，那么需要看i和i+1的数字组合起来有没有超过26</li>
</ol>
</blockquote>
<p><strong>暴力尝试</strong></p>
<p>做好逻辑推理和分类讨论</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">number</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//假设str[0~i-1]无需过问</span></span><br><span class="line">    <span class="comment">//就看str[i....]往后有多少种方法并返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//当i的位置来到终止位，说明前面已经找到了一种方案，返回1</span></span><br><span class="line">        <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当i的位置元素是0，说明当前方法失效</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当以上情况都不是的时候说明开始进行决策：</span></span><br><span class="line">        <span class="comment">//决策一：当前位置的数字单独转成字母</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> process(str, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//决策二：如果当前位置的下一个位置没有越界且他们两个组成的字母没有超过26则也是方法</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">            ways += process(str, i + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ways;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>DP优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line">        <span class="comment">//由于当前位置的种类个数取决于下一个位置，所以dp表是从右往左填</span></span><br><span class="line">        <span class="comment">//又因为i的位置有可能走到 越界的位置裁判定成功，所以dp表的长度应该加1</span></span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//如果当前位置正确走到了终止则是一个允许的方案，所以最后一位赋1</span></span><br><span class="line">        dp[N] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> dp[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">                    ways += dp[i + <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = ways;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="贴纸凑目标串"><a href="#贴纸凑目标串" class="headerlink" title="贴纸凑目标串"></a>贴纸凑目标串</h3><blockquote>
<p>题目：<br>给定一个字符串 str，给定一个字符串类型的数组 arr， 出现的字符都是小写英文，arr 每一个字符串代表一张贴纸（假设每一种贴纸无穷张），你可以把单个字符剪开使用，目的是拼出 str 来，返回需要<strong>至少</strong>多少张贴纸可以完成这个任务。</p>
<p>举例：<br>Str &#x3D; “babac” , arr &#x3D; {“ba”, “c”, “abcd”}<br>至少需要两张贴纸<br>为了凑出 babac， 大概有以下几种策略：<br>2 张 ba + 1 张 c<br>1 张 ba + 1 张 abcd<br>2 张 babac<br>由此可见，至少需要两张贴纸才可以完成任务</p>
</blockquote>
<p><strong>最初始的尝试策略–暴力递归</strong></p>
<p>暴力递归的思路就是：从 arr 的第一个字符串开始遍历尝试，每次遍历时将 arr 的字符串从 str 中去除（这里需要量身定制一个minus函数，用于从一个小写字符串中去除另外一个小写字符串的所有字符），然后继续递归调用这个函数，这样就可以做到毫无保留的暴力递归尝试。但是此方法效率太低，leetcode的时间都过不了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers1</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process1(stickers, target);</span><br><span class="line">        <span class="comment">//如果ans是整型最大值，说明无有效方案，所以返回-1</span></span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line">        <span class="comment">//base case 是当这个 target 的长度为 0 时返回 0</span></span><br><span class="line">        <span class="comment">//因为此时说明target已经被每次遍历的贴纸去除干净了</span></span><br><span class="line">        <span class="keyword">if</span> (target.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//min 是还需要的最小贴纸数的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String first : stickers) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> minus(target, first);</span><br><span class="line">            <span class="keyword">if</span> (rest.length() != target.length()) &#123;</span><br><span class="line">                min = Math.min(min, process1(stickers, rest));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// min 的值是还需要的最小贴纸数，还需要再加上现在的已经选中的1</span></span><br><span class="line">        <span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先完成一个函数用来实现一个小写字符串去掉另一个小写字符串的字符后剩下的字符组成的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minus</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> cha : str1) &#123;</span><br><span class="line">            count[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> cha : str2) &#123;</span><br><span class="line">            count[cha - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count[i]; j++) &#123;</span><br><span class="line">                    builder.append((<span class="type">char</span>)(i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>暴力递归的优化：</strong></p>
<ul>
<li>优先判断含有当前target第一个字符的贴纸</li>
<li>做两张词频表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案2</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers2</span><span class="params">(String stickers[], String target)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line">       <span class="type">int</span>[][] count = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">           <span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">               count[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process2(count, target);</span><br><span class="line">       <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将 stickers 换成二维数组</span></span><br><span class="line">   <span class="comment">// stickers[i] 表示 arr 的第 i 号贴纸的字符词频统计</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[][] stickers, String target)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (target.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">char</span>[] tar = target.toCharArray();</span><br><span class="line">       <span class="type">int</span>[] tarCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> cha : tar) &#123;</span><br><span class="line">           tarCount[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">           <span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line">           <span class="keyword">if</span> (sticker[tar[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (tarCount[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> tarCount[j] - sticker[j];</span><br><span class="line">                       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; num; k++) &#123;</span><br><span class="line">                           builder.append((<span class="type">char</span>)(j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">               min = Math.min(min, process2(stickers, rest));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>方案三</strong></p>
<p>加入傻缓存优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案三</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers3</span><span class="params">(String stickers[], String target)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line">       <span class="type">int</span>[][] count = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">           <span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">               count[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       HashMap&lt; String, Integer&gt; dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       dp.put(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process3(count, target, dp);</span><br><span class="line">       <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process3</span><span class="params">(<span class="type">int</span>[][] stickers, String target, HashMap&lt;String, Integer&gt; dp)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (dp.containsKey(target)) &#123;</span><br><span class="line">           <span class="keyword">return</span> dp.get(target);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">char</span>[] tar = target.toCharArray();</span><br><span class="line">       <span class="type">int</span>[] tarCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> cha : tar) &#123;</span><br><span class="line">           tarCount[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">           <span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line">           <span class="keyword">if</span> (sticker[tar[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (tarCount[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> tarCount[j] - sticker[j];</span><br><span class="line">                       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; num; k++) &#123;</span><br><span class="line">                           builder.append((<span class="type">char</span>)(j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">               min = Math.min(min, process3(stickers, rest, dp));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       dp.put(target, ans);</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



















<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-08%2021.23.32.png" alt="截屏2022-08-08 21.23.32" style="zoom:50%;" />



<p><strong>方案 1: 暴力递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longCommonSubsequence</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span> || s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> process1(str1, str2, str1.length - <span class="number">1</span>, str2.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此递归的含义是str1[0..i] 与 str2[0...j]的最长公共子序列是多长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str1[i] == str2[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//有三种可能性去尝试</span></span><br><span class="line">            <span class="comment">//不考虑以 i 位置结尾，但考虑以 j 位置结尾</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line">            <span class="comment">//不考虑以 j 位置结尾，但考虑以 i 位置结尾</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//上面两种可能性以外还有一种可能性:一定要以 i 和 j 结尾</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? (<span class="number">1</span> + process1(str1, str2, i - <span class="number">1</span>, j - <span class="number">1</span>)) : Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">return</span> Math.max(p1, Math.max(p2, p3));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong>方案2 ：dp优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longCommonSubsequence2</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text1.length() == <span class="number">0</span> || text2.length() == <span class="number">0</span> || text1 == <span class="literal">null</span> || text2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> str2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][M];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = str1[<span class="number">0</span>] == str2[j] ? <span class="number">1</span> : dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? (<span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">                dp[i][j] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N - <span class="number">1</span>][M - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-08%2022.45.09.png" alt="截屏2022-08-08 22.45.09" style="zoom:50%;" />



<p><strong>方案1: 利用上一题，最长子序列</strong></p>
<p>将给定的字符串 s 逆序 ss ， 求 s 与 ss 的最长子公共子序列，求得的就是最长回文子序列</p>
<p><strong>方案2：暴力尝试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(s.toCharArray(), <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归函数的意义是 str[L...R] 上的最长回文子序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> L , <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="comment">//如果只剩一个字符那一定是回文串</span></span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果只剩两个字符，那么这两个字符相同的话就是2，不相同的就是1</span></span><br><span class="line">        <span class="keyword">if</span> (L == R - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str[L] == str[R] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接下来是4种普遍情况</span></span><br><span class="line">        <span class="comment">//不以 L 开头也不以 R 结尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(str, L + <span class="number">1</span>, R - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//以 L 开头，但不以 R 结尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process(str, L, R - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//不以 L 开头，以 R 结尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> process(str, L + <span class="number">1</span>, R);</span><br><span class="line">        <span class="comment">// 以 L 开头， 以 R 结尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p4</span> <span class="operator">=</span> str[L] == str[R] ? (<span class="number">2</span> + process(str, L + <span class="number">1</span>, R - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(p1, p2), Math.max(p3, p4));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>方案3 ：dp优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">        <span class="comment">//根据递归的base case 填好初始值</span></span><br><span class="line">        <span class="comment">//dp表的下半区是没用的且对角全为1，对角线上面那条平行线需要判断</span></span><br><span class="line">        dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = str[i] == str[i+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">2</span>; R &lt; N; R++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[L + <span class="number">1</span>][R - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[L][R - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> dp[L + <span class="number">1</span>][R];</span><br><span class="line">                <span class="type">int</span> <span class="variable">p4</span> <span class="operator">=</span> str[L] == str[R] ? (dp[L + <span class="number">1</span>][R - <span class="number">1</span>] + <span class="number">2</span>) : <span class="number">0</span>;</span><br><span class="line">                dp[L][R] = Math.max(Math.max(p1, p2), Math.max(p3, p4));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>方案4:继续优化</strong></p>
<p>画个二维表仔细思考可以得出，没必要和左下的那个格子比较，这是第一个优化的点，第二点是只有L和R位置的字符相等才有必要去和第四种情况比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">        <span class="comment">//根据递归的base case 填好初始值</span></span><br><span class="line">        <span class="comment">//dp表的下半区是没用的且对角全为1，对角线上面那条平行线需要判断</span></span><br><span class="line">        dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = str[i] == str[i+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">2</span>; R &lt; N; R++) &#123;</span><br><span class="line">                dp[L][R] = Math.max(dp[L][R - <span class="number">1</span>], dp[L + <span class="number">1</span>][R]);</span><br><span class="line">                <span class="keyword">if</span> (str[L] == str[R]) &#123;</span><br><span class="line">                    dp[L][R] = Math.max(dp[L][R], dp[L + <span class="number">1</span>][R - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











<h3 id="象棋跳跃问题"><a href="#象棋跳跃问题" class="headerlink" title="象棋跳跃问题"></a>象棋跳跃问题</h3><blockquote>
<p>已知象棋规则中马走日，给定棋盘大小，马的初始位置在(0,0)，目标是在跳 k 步的情况下跳到目标坐标，问有多少种方法</p>
</blockquote>
<p><strong>暴力</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">horseJump</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jump(<span class="number">0</span>, <span class="number">0</span>, k, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 易想到以下递归</span></span><br><span class="line">    <span class="comment">// 当前来到 (x, y)</span></span><br><span class="line">    <span class="comment">// 还剩下rest步</span></span><br><span class="line">    <span class="comment">// 跳完rest步正好跳到 (a, b) 有多少种可能</span></span><br><span class="line">    <span class="comment">//棋盘大小 10 * 9</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (x == a &amp;&amp; y == b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列举马走日的八种可能性</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> jump(x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">        ways += jump(x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">        ways += jump(x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">        ways += jump(x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">        ways += jump(x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">        ways += jump(x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">        ways += jump(x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">        ways += jump(x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">        <span class="keyword">return</span> ways;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong>dp优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dpJump</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">9</span>][k+<span class="number">1</span>];</span><br><span class="line">        dp[a][b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= k; rest++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; <span class="number">9</span>; y++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> pick(dp, x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                    ways += pick(dp, x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">                    ways += pick(dp, x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">                    ways += pick(dp, x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                    ways += pick(dp, x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                    ways += pick(dp, x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">                    ways += pick(dp, x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">                    ways += pick(dp, x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                    dp[x][y][rest] = ways;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了防止dp表拿值的时候越界报错，写一个pick函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pick</span><span class="params">(<span class="type">int</span>[][][] dp, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y][rest];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>













<h3 id="咖啡问题"><a href="#咖啡问题" class="headerlink" title="咖啡问题"></a>咖啡问题</h3><blockquote>
<p>给定一个数组 arr， arr[i]代表第 i 号咖啡机泡一杯咖啡的时间<br>给定一个正数 N，表示 N 个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡<br>只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯<br>每个咖啡杯也可以自己挥发干净，时间耗费 b，咖啡杯可以并行挥发<br>假设所有人拿到咖啡之后立刻喝干净，<br>返回从开始等到所有咖啡机变干净的最短时间<br>三个参数: int[ ] arr、int N, int a、int b</p>
</blockquote>
<h2 id="动归入门"><a href="#动归入门" class="headerlink" title="动归入门"></a>动归入门</h2><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><blockquote>
<p>Leetcode : <a href="https://leetcode.cn/problems/unique-binary-search-trees/">https://leetcode.cn/problems/unique-binary-search-trees/</a></p>
<p>题目描述：<br>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
</blockquote>
<p><strong>简单的暴力</strong></p>
<p>这个尝试是符合正常思维的，主要思想是当有 n 个节点时，轮流让每个节点作为根节点，而当根节点确定后其能构建的搜索二叉树的数量又取决于左右两棵子树的种类相乘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数n有多少个二叉搜索树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="comment">// 虽然当 n = 0 时意味着左子树没有节点，但是由于是可能性相乘，所以返回1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用i当头结点。如果左树有m个搜索子树，右树有n个搜索子树。那么 m * n 就是以i为结点的搜索子树个数。</span></span><br><span class="line">            <span class="comment">// 左树有多少种子树</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 右树有多少种子树</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process(n - i);</span><br><span class="line">            ans += p1 * p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>比较妙的优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">2</span> * numTrees(n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">              sum += numTrees(i - <span class="number">1</span>) * numTrees(n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>缓存优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numTrees2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 结点个数为0或者1的时候，搜索子树个数为1</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数n有多少个二叉搜索树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] != -<span class="number">1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用i当头结点。如果左树有m个搜索子树，右树有n个搜索子树。那么 m * n 就是以i为结点的搜索子树个数。</span></span><br><span class="line">            <span class="comment">// 左树有多少种子树</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f(i - <span class="number">1</span>, dp);</span><br><span class="line">            <span class="comment">// 右树有多少种子树</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f(n - i, dp);</span><br><span class="line">            ans += p1 * p2;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>最终优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numTrees3</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">2</span>; index &lt;= n; index++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 从1...index。有多少个搜索子树</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> <span class="number">1</span>; node &lt;= index; node++) &#123;</span><br><span class="line">                <span class="comment">// 以node值为头结点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[node - <span class="number">1</span>]; <span class="comment">// 左树有多少个搜索子树</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[index - node]; <span class="comment">// 右树有多少个搜索子树</span></span><br><span class="line">                ans += p1 * p2;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











<h3 id="字符串递增"><a href="#字符串递增" class="headerlink" title="字符串递增"></a>字符串递增</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-11%2013.25.33.png" alt="截屏2022-06-11 13.25.33" style="zoom:50%;" />







<h3 id="粉刷房子问题"><a href="#粉刷房子问题" class="headerlink" title="粉刷房子问题"></a>粉刷房子问题</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-06-25%2016.23.07.png" alt="截屏2022-06-25 16.23.07" style="zoom:50%;" />











<h3 id="剪绳子-1"><a href="#剪绳子-1" class="headerlink" title="剪绳子_1"></a>剪绳子_1</h3><blockquote>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/jian-sheng-zi-lcof">https://leetcode.cn/problems/jian-sheng-zi-lcof</a></p>
</blockquote>
<p><strong>递归 和 缓存优化</strong></p>
<p>递归的主要思想是：当剪到 n &#x3D;&#x3D; 0 时，一位置绳子没办法再剪了，就返回 1，然后每次递归分为两个分支–剪或者不剪，剪剪的话剪多少则是由 for 循环决定的.但是由于有太多重复计算，所以超出时间限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 下面这个递归在思维上更好理解，速度也更快点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= (n &gt;&gt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">            max = Math.max(Math.max(i * process(n - i), i * (n - i)), max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp =<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cut</span> <span class="operator">=</span> <span class="number">3</span>; cut &lt;= n; cut++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= (cut &gt;&gt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">                max = Math.max(Math.max(i * dp[cut - i], i * (cut - i)), max);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[cut] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>贪心–数学</strong></p>
<p>利用了均值不等式，求解最大值的数字特点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="相似度为k的字符串"><a href="#相似度为k的字符串" class="headerlink" title="相似度为k的字符串"></a>相似度为k的字符串</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-21%2023.02.33.png" alt="截屏2022-09-21 23.02.33" style="zoom:50%;" />



<p><strong>方式一 ： 枚举</strong></p>
<p>这是最简单粗暴的一种方式，枚举所有的可能性，同时很自然的想到用Set来记录所有遍历过的可能性来剪枝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kSimilarity</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        Deque&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        queue.offer(s1);</span><br><span class="line">        visited.add(s1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 之所以敢写while true 是因为s1一定可以转变成s2，我们只需要找到结果返回</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 我们每次需要遍历queue的size次，以此来找到当前队列中所有的状态的下一个状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue.pollFirst();</span><br><span class="line">                <span class="keyword">if</span> (cur.equals(s2)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String s : next(cur, s2)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(s)) &#123;</span><br><span class="line">                        visited.add(s);</span><br><span class="line">                        queue.offer(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将所有满足条件的下一个状态的字符串以list返回</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">next</span><span class="params">(String cur, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = s2.length();</span><br><span class="line">        <span class="type">char</span>[] cs = cur.toCharArray();</span><br><span class="line">        List&lt;String&gt; next = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到第一个cur 和 s2不相等的字符的索引</span></span><br><span class="line">        <span class="keyword">for</span> (; cs[i] == s2.charAt(i); ++i) &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cs[j] == s2.charAt(i) &amp;&amp; cs[j] != s2.charAt(j)) &#123;</span><br><span class="line">                swap(cs, i, j);</span><br><span class="line">                next.add(<span class="keyword">new</span> <span class="title class_">String</span>(cs));</span><br><span class="line">                swap(cs, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> cs[i];</span><br><span class="line">        cs[i] = cs[j];</span><br><span class="line">        cs[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>方式二</strong></p>
<p><strong>方式三</strong></p>
<p><strong>方式四</strong></p>
<h3 id="使序列递增最小交换"><a href="#使序列递增最小交换" class="headerlink" title="使序列递增最小交换"></a>使序列递增最小交换</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-11%2016.39.06.png" alt="截屏2022-10-11 16.39.06" style="zoom:50%;" />



<p><strong>分析</strong></p>
<p>由于题目指明：一定会有解，所以，所有位置的数字的情况由以下两种情况组成</p>
<ul>
<li>当前位置和上一个位置的数字已经是单调递增的关系<ul>
<li>nums1[i] &gt; nums1[i - 1] &amp;&amp; nums2[i] &gt; nums2[i - 1]</li>
</ul>
</li>
<li>当前位置的数字交换以后和上一个位置的数字是单调递增的关系<ul>
<li>nums1[i] &gt; nums2[i - 1] &amp;&amp; nums2[i] &gt; nums1[i - 1]</li>
</ul>
</li>
</ul>
<p><strong>基本方法</strong></p>
<p>最基本的、毫无优化的方法就是使用dp 数组分类讨论上述情况,但是效率很低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwap</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="comment">// 换不换都是递增</span></span><br><span class="line">            <span class="keyword">if</span> ((nums1[i] &gt; nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums2[i-<span class="number">1</span>]) &amp;&amp; </span><br><span class="line">                (nums1[i] &gt; nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums1[i-<span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                    dp[i][<span class="number">0</span>] = cur;</span><br><span class="line">                    dp[i][<span class="number">1</span>] = cur + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 换了才递增</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums1[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[n-<span class="number">1</span>][<span class="number">0</span>], dp[n-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>滚动数组优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwap</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">      <span class="comment">// 滚动数组优化：</span></span><br><span class="line">       <span class="comment">// 由于当前位置仅由前一个位置决定，所以可以用关东数组优化：即</span></span><br><span class="line">       <span class="comment">// 用两个变量代表dp[i][0] 和 dp[i][1]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="comment">// at 和 bt 用来存放上一个dp[1][0] 和 dp[i][1]的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">at</span> <span class="operator">=</span> a, bt = b;</span><br><span class="line">          <span class="comment">// 这个用来记录当前dp值</span></span><br><span class="line">            a = b = n;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums1[i - <span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums2[i - <span class="number">1</span>])  &#123;</span><br><span class="line">                a = Math.min(a, at);</span><br><span class="line">                b = Math.min(b, bt + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[i - <span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums1[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                a = Math.min(a, bt);</span><br><span class="line">                b = Math.min(b, at + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><blockquote>
<p>Leetcode 5 </p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 当 s 的长度为1时，必定是回文，所以直接返回 s 本身</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 声明 dp 数组</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示从 i 到 j 是不是回文</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 所有一个字符的串都是回文串，所以边界设置为 true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录当前最长回文字串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录当前回文字串的起点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="comment">// 用双层for来遍历每一种可能的字符串，但用dp空间换时间</span></span><br><span class="line">        <span class="comment">// 这个 L 表示现在检查的回文串从 2 开始（因为1肯定是回文）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>;  L &lt;= len; L++) &#123;</span><br><span class="line">            <span class="comment">// 然后从0开始遍历每一个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// j 表示当前子串的右端点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 右端点界限判断</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// dp 策略：</span></span><br><span class="line">                <span class="comment">// 1. 如果当前子串的两端不相等直接赋值 false</span></span><br><span class="line">                <span class="comment">// 2. 如果当前字串两端相等，取决于当前子串的长度</span></span><br><span class="line">                <span class="comment">//  如果是小于等于3，则可直接由两端判定是true</span></span><br><span class="line">                <span class="comment">//  如果是不是，则其值取决于里面是否是回文子串</span></span><br><span class="line">                <span class="keyword">if</span> (ss[i] != ss[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新子串最大长度并记录索引</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="最大加号标志"><a href="#最大加号标志" class="headerlink" title="最大加号标志"></a>最大加号标志</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-11%2010.16.42.png" alt="截屏2022-11-11 10.16.42" style="zoom:50%;" />



<p><strong>预处理+模拟</strong></p>
<p>声明四个方向的前缀和数组，每个元素的加号阶数由四个方向中最短的那一个决定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orderOfLargestPlusSign</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] mines)</span> &#123;</span><br><span class="line">        <span class="comment">// 预处理 + 模拟</span></span><br><span class="line">        <span class="comment">// 由于要预处理，所以要多加2的边际</span></span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 下面两个for循环做出grid数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(g[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] mine: mines) &#123;</span><br><span class="line">            g[mine[<span class="number">0</span>] + <span class="number">1</span>][mine[<span class="number">1</span>] + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 四个前缀数组</span></span><br><span class="line">        <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[][] d = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 给前缀数组赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    a[i][j] = a[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    b[i][j] = b[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (g[n + <span class="number">1</span> - i][n + <span class="number">1</span> - j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    c[n + <span class="number">1</span> - i][n + <span class="number">1</span> - j] = c[n + <span class="number">1</span> - i][n + <span class="number">2</span> - j] + <span class="number">1</span>;</span><br><span class="line">                    d[n + <span class="number">1</span> - i][n + <span class="number">1</span> - j] = d[n + <span class="number">2</span> - i][n + <span class="number">1</span> - j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                ans = Math.max(ans, </span><br><span class="line">                Math.min(</span><br><span class="line">                    Math.min(a[i][j], b[i][j]),</span><br><span class="line">                    Math.min(c[i][j], d[i][j])</span><br><span class="line">                ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>动态规划</strong></p>
<p>思维也类似于前缀和数组，但是不用四个数组来缓存前缀和，而是每个方向上找最小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orderOfLargestPlusSign</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] mines)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], n);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; banned = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] vec : mines) &#123;</span><br><span class="line">            banned.add(vec[<span class="number">0</span>] * n + vec[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* left */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (banned.contains(i * n + j)) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], count);</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* right */</span> </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (banned.contains(i * n + j)) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* up */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (banned.contains(j * n + i)) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j][i] = Math.min(dp[j][i], count);</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* down */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (banned.contains(j * n + i)) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j][i] = Math.min(dp[j][i], count);</span><br><span class="line">                ans = Math.max(ans, dp[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h3 id="礼物最大价值"><a href="#礼物最大价值" class="headerlink" title="礼物最大价值"></a>礼物最大价值</h3><blockquote>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>LeetCode: 剑指 47</p>
</blockquote>
<p><strong>自己的第一次写的方法</strong></p>
<p>纪念一下自己写出的第一道中等以上的动归。<br>虽然题目读完就知道一定是用动归来写，但是需要弄清楚一个底层逻辑，就是当走到  i，j 位置时，当前拿到的礼物的最大价值是可以唯一确定的，因为只有两种走路方式，向右或者向下，每次都可以分解为两个方向二选一，一直分解到从 0，0出发，如果是四个方向的话，就不能用动态规划来解决了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化 dp 数组，两条边只需要累加即可</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 从两个方向中选出最大的那个</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] += grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>代码简化版写法，但是速度可能没提升太多</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 相当于用 if 判断来代替了我的初始化的过程</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] = Math.max(dp[i][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] += grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>用两个一维数组代替dp数组，减少空间复杂度</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 数位动规</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 旋转数字</span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-25%2023.56.26.png&quot;</span> alt=<span class="string">&quot;截屏2022-09-25 23.56.26&quot;</span> style=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**方法一：找规律**</span><br><span class="line"></span><br><span class="line">规律总结起来就一个字：一个数如果是好数，那么所有位的数字都必须是 0125689 里的，且至少有一位是 <span class="number">2589</span> 里的</span><br><span class="line">用两个map存储两组数字，然后再单独写一个判断是否好数的方法，弹出每一位数字就好</span><br><span class="line">代码比较简单，就不写了，效率也比较低。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**方法二：加强查找**</span><br><span class="line"></span><br><span class="line">用一种巧妙的方式存储有效旋转数字</span><br><span class="line">可能在效率上也不是多么高效，但是非常巧妙</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">// 用距离 + 分类去判断是否有效</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] check = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rotatedDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">must</span> <span class="operator">=</span> <span class="literal">true</span>, least = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; num.length(); j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> num.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (check[cur - <span class="string">&#x27;0&#x27;</span>] == -<span class="number">1</span> ) &#123;</span><br><span class="line">                    must = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (check[cur - <span class="string">&#x27;0&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    least = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (must &amp;&amp; least) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法三：数位动态规划</strong></p>
<h2 id="动归-二分"><a href="#动归-二分" class="headerlink" title="动归 + 二分"></a>动归 + 二分</h2><h2 id="动归-数组"><a href="#动归-数组" class="headerlink" title="动归 + 数组"></a>动归 + 数组</h2><h3 id="填充书架"><a href="#填充书架" class="headerlink" title="填充书架"></a>填充书架</h3><blockquote>
<p>给定一个数组 <code>books</code> ，其中 <code>books[i] = [thicknessi, heighti]</code> 表示第 <code>i</code> 本书的厚度和高度。你也会得到一个整数 <code>shelfWidth</code> 。</p>
<p><strong>按顺序</strong> 将这些书摆放到总宽度为 <code>shelfWidth</code> 的书架上。</p>
<p>先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 <code>shelfWidth</code> ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。</p>
<p>需要注意的是，在上述过程的每个步骤中，<strong>摆放书的顺序与你整理好的顺序相同</strong>。</p>
<ul>
<li>例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。（书架自上而下去建）</li>
</ul>
<p>每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。</p>
<p>以这种方式布置书架，返回书架整体可能的最小高度。</p>
<p>LeetCode 1105</p>
</blockquote>
<p><strong>暴力递归</strong></p>
<p>首先为什么可以用递归解决这个问题呢？– 假设我们最后一层摆满了4本书，现在还有3本书，那么总共7本书的最小高度问题就变成了3本书的最小高度加上最底下那一层的4本书的最高高度。<br>我们可以这么考虑从后往前遍历 books，每次遍历到一个位置就开始 for 循环，for 循环的目的是枚举每一层可以放多少本书的所有情况，然后每一种情况的最优解又取决于剩下的书的最优解，递归就形成了，最后返回ans。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此方法无法通过 LeetCode 提交，超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] books;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> shelfWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minHeightShelves</span><span class="params">(<span class="type">int</span>[][] books, <span class="type">int</span> shelfWidth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.books = books;</span><br><span class="line">        <span class="built_in">this</span>.shelfWidth = shelfWidth;</span><br><span class="line">        <span class="keyword">return</span> dfs(books.length - <span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入的参数的含义是：放置 i 本书所需要的最小书架高度,所以递归最终 return 的就是答案</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有书的话书架高度是 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE, leftW = shelfWidth, maxH = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            leftW -= books[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (leftW &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            maxH = Math.max(maxH, books[j][<span class="number">1</span>]);</span><br><span class="line">            ans = Math.min(ans, dfs(j - <span class="number">1</span>) + maxH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>递归 + 记忆化搜索</strong></p>
<p>很明显，上面的方法有很明显的弊端，就是有很多重复的递归，比如，dfs(4)  和 dfs(3) 的时候，都会重复调用 dfs(2) 和 dfs(1),所以尝试加入缓存。</p>
<p>加了缓存以后，效果改观很明显，从运行超时直接击败百分百。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] books;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> shelfWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minHeightShelves</span><span class="params">(<span class="type">int</span>[][] books, <span class="type">int</span> shelfWidth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.books = books;</span><br><span class="line">        <span class="built_in">this</span>.shelfWidth = shelfWidth;</span><br><span class="line">        <span class="built_in">this</span>.memo = <span class="keyword">new</span> <span class="title class_">int</span>[books.length];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(books.length - <span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">      <span class="comment">// 缓存判断</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE, leftW = shelfWidth, maxH = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            leftW -= books[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (leftW &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            maxH = Math.max(maxH, books[j][<span class="number">1</span>]);</span><br><span class="line">            ans = Math.min(ans, dfs(j - <span class="number">1</span>) + maxH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>1:1 翻译成递推写法</strong></p>
<p>我们可以通过 for 循环，去掉递的部分，只保留归的部分<br>通用做法：</p>
<ul>
<li>dfs 改成 f 数组</li>
<li>递归改成循环（每个参数对应一层循环）</li>
<li>递归的边界改成递归的初始值</li>
</ul>
<p>这里有一个小问题，递归的边界是 i &lt; 0, 但是在数组中无法反应这个边界，于是就只能把 f 数组整体往右推一位，f[0] &#x3D; 0；来表示边界，这样涉及到 f 数组的下标都加一，但是 books 的逻辑不用改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minHeightShelves</span><span class="params">(<span class="type">int</span>[][] books, <span class="type">int</span> shelfWidth)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> books.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 模拟 dfs “归”的部分,遍历的含义就是开始计算当前书本的最优解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftW</span> <span class="operator">=</span> shelfWidth, maxH = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                leftW -= books[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (leftW &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                maxH = Math.max(maxH, books[j][<span class="number">1</span>]);</span><br><span class="line">                f[i + <span class="number">1</span>] = Math.min(f[i + <span class="number">1</span>], f[j] + maxH);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















<h2 id="动归-矩阵（图形）"><a href="#动归-矩阵（图形）" class="headerlink" title="动归 + 矩阵（图形）"></a>动归 + 矩阵（图形）</h2><h3 id="全为1的方形矩阵"><a href="#全为1的方形矩阵" class="headerlink" title="全为1的方形矩阵"></a>全为1的方形矩阵</h3><blockquote>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p>
</blockquote>
<p><strong>核心思想是：遍历矩阵，以遍历到的当前元素作为正方形的右下角，并计算正方形面积</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSquares</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可以申请一个范围 + 1的dp数组来避免讨论边界的case</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSquares</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                   dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                   ans += dp[i][j];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><hr>
<h2 id="数学原理及应用"><a href="#数学原理及应用" class="headerlink" title="数学原理及应用"></a>数学原理及应用</h2><h3 id="最小偶倍数"><a href="#最小偶倍数" class="headerlink" title="最小偶倍数"></a>最小偶倍数</h3><blockquote>
<p>给你一个正整数 <code>n</code> ，返回 <code>2</code> 和 <code>n</code> 的最小公倍数（正整数）。</p>
<p>LeetCode 2413</p>
</blockquote>
<p><strong>奇偶讨论</strong></p>
<p>这题很简单，但是想思考的简单并且代码写的简洁也是需要功夫的</p>
<p><strong>当 n 为 偶数时答案是 n，当 n 为奇数时答案为 2 * n</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? n : <span class="number">2</span> * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这么写还是不够优雅,以下代码参考了灵神</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span> + <span class="number">1</span>) * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>当 n 为奇数时，答案是 n 左移一位，否则不变</strong><br>这样就可以借助位运算了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt;&lt; (n % <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="公因子数目（最大公约数）"><a href="#公因子数目（最大公约数）" class="headerlink" title="公因子数目（最大公约数）"></a>公因子数目（最大公约数）</h3><blockquote>
<p>给你两个正整数 <code>a</code> 和 <code>b</code> ，返回 <code>a</code> 和 <code>b</code> 的 <strong>公</strong> 因子的数目。</p>
<p>如果 <code>x</code> 可以同时整除 <code>a</code> 和 <code>b</code> ，则认为 <code>x</code> 是 <code>a</code> 和 <code>b</code> 的一个 <strong>公因子</strong> 。</p>
</blockquote>
<p><strong>找到到最大公约数</strong></p>
<p>这题我们当然可以从 1 遍历到 a 和 b 的最小值，然后用 a 和 b 取余遍历到的每一个元素即可，但是可以进行优化，我们只需要遍历到 a 和 b 的最大公约数即可，并且利用公因子是成对出现的这一特点去继续优化。</p>
<p><strong>1. 求最大公约数</strong><br>利用辗转相除法求最大公约数，原理如下：<br>例如：30 &#x2F; 18 &#x3D; 1 .. 12<br>其中 30 和 18 的最大公约数，就是 18 和 12 的最大公约数，证明如下：<br>a &#x2F; b &#x3D; q .. r , a &#x3D; q * b + r , 令 a 和 b 的最大公约数为 x , a &#x3D; n1 * x , b &#x3D; n2 * x , n1 * x &#x3D; q * n2 * x + r<br>r &#x3D; (n1 - q * n2) * x , 可以发现，r 也就是余数的最大公约数和除数和被除数保持一致<br>每次将除数和被除数作为下一次计算的参数，当余数为 0 时可以证明，该次除数即 a 和 b 的最大公约数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            a %= b;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b ^= a;</span><br><span class="line">            a ^= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>2. 遍历到根号最大公约数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">commonFactors</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> gcd(a, b), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 由于公因子成对出现，所以遍历到根号最大公约数即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; x * x &lt;= c; x++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a % x == <span class="number">0</span> &amp;&amp; b % x == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">if</span> (x * x != c) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            a %= b;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b ^= a;</span><br><span class="line">            a ^= b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h2 id="简单数学应用"><a href="#简单数学应用" class="headerlink" title="简单数学应用"></a>简单数学应用</h2><h3 id="移动筹码问题"><a href="#移动筹码问题" class="headerlink" title="移动筹码问题"></a>移动筹码问题</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-07-08%2023.37.53.png" alt="截屏2022-07-08 23.37.53" style="zoom:50%;" />



<p><strong>分析</strong><br>仔细分析可知，如果是一个偶数位置移动到偶数位置或者奇数位置移动到奇数位置时cost都为0，只有奇数位置与偶数位置互相移动才会有花费，所以假设现在移动到 i 位置是一个奇数，那么所有奇数位置的cost都为0，只要计算偶数位置的cost，且每个偶数位置的数移动过来cost都为1，综上所述，其实也就是看奇数位置和偶数位置谁的个数少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostToMoveChips</span><span class="params">(<span class="type">int</span>[] position)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">o</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cur : position) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                o++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(o, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><blockquote>
<p>力扣：<a href="https://leetcode.cn/problems/monotone-increasing-digits/">https://leetcode.cn/problems/monotone-increasing-digits/</a></p>
<p>题目描述：<br>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p>
</blockquote>
<p><strong>贪心策略</strong></p>
<p>这其实是一道简单的贪心题，贪心策略是：从左往右遍历数字，找到第一个非递增的数据，然后将其以及之前的数字都减1，其之后的数字赋9</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数字转换成字符数组</span></span><br><span class="line">        <span class="type">char</span>[] strN = Integer.toString(n).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历数组，找到第一个降低的字符</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; strN.length &amp;&amp; strN[i - <span class="number">1</span>] &lt;= strN[i]) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; strN.length) &#123;</span><br><span class="line">            <span class="comment">// 第一个降低的字符之前的数字全部减一</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; strN[i - <span class="number">1</span>] &gt; strN[i]) &#123;</span><br><span class="line">                strN[i - <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                i -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 之后的数字全部赋值9</span></span><br><span class="line">            <span class="keyword">for</span> (i += <span class="number">1</span>; i &lt; strN.length; ++i) &#123;</span><br><span class="line">                strN[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(strN));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><blockquote>
<p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p>
</blockquote>
<p><strong>快速幂 + 递归</strong><br>$$<br>假设求 2^{10}, 我们可以转换去用递归求：2^5 \times 2^5, \<br>这里要分一下奇偶：例如：2^{11} &#x3D; 2^5 \times 2^5\times 2<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt;= <span class="number">0</span> ? process(x, n) : <span class="number">1.0</span> / process(x, - n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">process</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> process(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>快速幂 + 迭代</strong></p>
<p>在递归的基础上进行优化, 略难理解，省略。</p>
<h3 id="特殊数组的特征值"><a href="#特殊数组的特征值" class="headerlink" title="特殊数组的特征值"></a>特殊数组的特征值</h3><blockquote>
<p>给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。</p>
<p>注意： x 不必 是 nums 的中的元素。</p>
<p>如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x">https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x</a></p>
</blockquote>
<p><strong>降序排列+一次遍历</strong></p>
<p>降序排列后通过索引来找出个数和大小的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">specialArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先对数组进行降序排列</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt;= i &amp;&amp; (i == nums.length || nums[i] &lt; i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="最小公倍数为K子数组"><a href="#最小公倍数为K子数组" class="headerlink" title="最小公倍数为K子数组"></a>最小公倍数为K子数组</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-15%2015.22.15.png" alt="截屏2022-11-15 15.22.15" style="zoom:50%;" />



<p><strong>暴力法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarrayLCM</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                x = lcm(x, nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (x == k) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求最小公约数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a != <span class="number">0</span> ? gcd(a, b % a) : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求最小公倍数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>利用LCM性质剪枝</strong></p>
<h3 id="香槟塔"><a href="#香槟塔" class="headerlink" title="香槟塔"></a>香槟塔</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-20%2022.46.07.png" alt="截屏2022-11-20 22.46.07" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">champagneTower</span><span class="params">(<span class="type">int</span> poured, <span class="type">int</span> query_row, <span class="type">int</span> query_glass)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟法，先将水全部倒在当前所在行的杯子里（初始时倒在第一个杯子里）</span></span><br><span class="line">        <span class="type">double</span>[] row = &#123;poured&#125;;</span><br><span class="line">        <span class="comment">// 遍历倒所求行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= query_row; i++) &#123;</span><br><span class="line">            <span class="comment">// 模拟每一行倒水的情况，先声明这一行的杯子数量</span></span><br><span class="line">            <span class="type">double</span>[] nextRow = <span class="keyword">new</span> <span class="title class_">double</span>[i + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 模拟每一行的倒水的逻辑是遍历上一次层的杯子然后赋值给下一层的杯子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="type">double</span> <span class="variable">column</span> <span class="operator">=</span> row[j];</span><br><span class="line">                <span class="keyword">if</span> (column &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    nextRow[j] += (column - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    nextRow[j + <span class="number">1</span>] += (column - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            row = nextRow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后别忘了有可能杯子里的水是大于1的，那就和1做比较</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(<span class="number">1</span>, row[query_glass]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="第N个神奇数字"><a href="#第N个神奇数字" class="headerlink" title="第N个神奇数字"></a>第N个神奇数字</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-22%2011.19.05.png" alt="截屏2022-11-22 11.19.05" style="zoom:50%;" />



<p><strong>容斥原理 + 二分法</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-22%2011.20.05.png" alt="截屏2022-11-22 11.20.05" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthMagicalNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Math.min(a, b);</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> (<span class="type">long</span>) n * Math.min(a, b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> lcm(a, b);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> ((r - l) &gt;&gt; <span class="number">1</span>) + l;</span><br><span class="line">            <span class="type">long</span> <span class="variable">cnt</span> <span class="operator">=</span> mid / a + mid / b - mid / c;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= n) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ((r + <span class="number">1</span>) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最小公倍数 = 两数乘积 / 最大公约数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 辗转相除求最大公约数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b != <span class="number">0</span> ? gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="盒子最多球数量"><a href="#盒子最多球数量" class="headerlink" title="盒子最多球数量"></a>盒子最多球数量</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-23%2009.56.31.png" alt="截屏2022-11-23 09.56.31" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countBalls</span><span class="params">(<span class="type">int</span> lowLimit, <span class="type">int</span> highLimit)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lowLimit; i &lt;= highLimit; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, x = i;</span><br><span class="line">            <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += x % <span class="number">10</span>;</span><br><span class="line">                x /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            max = Math.max(map.get(sum), max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="三的幂的和"><a href="#三的幂的和" class="headerlink" title="三的幂的和"></a>三的幂的和</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-12-09%2013.56.55.png" alt="截屏2022-12-09 13.56.55" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPowersOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="特定最少元素和"><a href="#特定最少元素和" class="headerlink" title="特定最少元素和"></a>特定最少元素和</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-12-16%2014.58.16.png" alt="截屏2022-12-16 14.58.16" style="zoom:50%;" />

<p> <strong>代码简单，但是数学原理有点意思</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-12-16%2014.58.32.png" alt="截屏2022-12-16 14.58.32" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minElements</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(sum - goal);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ((diff + limit - <span class="number">1</span>) / limit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="移除石子最大得分"><a href="#移除石子最大得分" class="headerlink" title="移除石子最大得分"></a>移除石子最大得分</h3><blockquote>
<p>1753</p>
<p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>、<code>b</code> 和 <code>c</code> 的 <strong>三堆</strong> 石子。</p>
<p>每回合你都要从两个 <strong>不同的非空堆</strong> 中取出一颗石子，并在得分上加 <code>1</code>分。当存在 <strong>两个或更多</strong> 的空堆时，游戏停止。</p>
<p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 <strong>最大分数</strong> 。</p>
</blockquote>
<p><strong>贪心</strong></p>
<p>先给一个常规贪心解法，很容易想到，每次拿石子需要去拿最大的两堆，注意！这个最大的两堆是动态变化的，比如 4 4 6 这三堆，先拿第一堆和第三堆，变成 3 4 5，接下来要拿第二堆和第三堆了，这是动态变化的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumScore</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="comment">// 核心思想：每次取出最大的两个</span></span><br><span class="line">        <span class="type">int</span>[] stones = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;a, b, c&#125;;</span><br><span class="line">        Arrays.sort(stones);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (stones[<span class="number">0</span>] != <span class="number">0</span> || stones[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            stones[<span class="number">1</span>]--;</span><br><span class="line">            stones[<span class="number">2</span>]--;</span><br><span class="line">            Arrays.sort(stones);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>数学分析</strong></p>
<p>在解法一的基础上，进行数学推导，不妨假设a &lt;&#x3D; b &lt;&#x3D; c </p>
<p>若a + b &lt; c, 那么答案为c,将a和b依次与c进行配对，分数为a+b<br>若a + b &gt;&#x3D; c, 那么c每次与最大的数进行匹配。设于a匹配cnt1次，与b匹配cnt2次。最后变成(a - cnt1, b - cnt2, 0),由于每次c都与最大的数进行匹配，那么最后剩下的两个数必然相等或者相差1，如(3，6，7)(3， 6， 7)(3，6，7),会变成(1,1,0)(1,1,0)(1,1,0) 。将两者相加除2便是剩下两个数互相匹配的分数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumScore</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(Math.max(a, b), c);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumAB</span> <span class="operator">=</span> a + b + c - max;</span><br><span class="line">        <span class="keyword">return</span> sumAB &lt; max ? sumAB : (a + b + c) / <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="好对子"><a href="#好对子" class="headerlink" title="好对子"></a>好对子</h3><blockquote>
<p>给你一个数组 <code>nums</code> ，数组中只包含非负整数。定义 <code>rev(x)</code> 的值为将整数 <code>x</code> 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code> ， <code>rev(120) = 21</code> 。我们称满足下面条件的下标对 <code>(i, j)</code>是 <strong>好的</strong> ：</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; nums.length</code></li>
<li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></li>
</ul>
<p>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 核心思想：方程移项</span></span><br><span class="line">    <span class="comment">// nums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) 等价于</span></span><br><span class="line">    <span class="comment">// nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]) 简便运算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNicePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num, rev = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                rev = rev * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + map.getOrDefault(num - rev, <span class="number">0</span>)) % MOD;</span><br><span class="line">            map.put(num - rev, map.getOrDefault(num - rev, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="使数组中所有元素都为零"><a href="#使数组中所有元素都为零" class="headerlink" title="使数组中所有元素都为零"></a>使数组中所有元素都为零</h3><blockquote>
<p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p>
<ul>
<li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong>元素。</li>
<li><code>nums</code> 中的每个正整数都减去 <code>x</code>。</li>
</ul>
<p>返回使 <code>nums</code> 中所有元素都等于 <code>0</code> 需要的 <strong>最少</strong> 操作数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        set.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h3><blockquote>
<p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>LeetCode(hot 100)</p>
<p>此题有太多解法，这里只列举两种</p>
</blockquote>
<p><strong>排序法</strong></p>
<p>先用 java 内置的 sort 方法方法排序后，返回 nums.length &#x2F; 2 的那个元素，就是多数元素<br>代码略，执行时间 2ms</p>
<p><strong>随机数法</strong></p>
<p>由于多数已经超过了一般的数字，所以随机数法会有相当不错的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 在 nums 长度范围内生成一个随机数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randRage</span><span class="params">(Random rand, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(max - min) + min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计 num 出现的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countOccurences</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == num) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">majority</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> nums[randRage(rand, <span class="number">0</span>, nums.length)];</span><br><span class="line">            <span class="keyword">if</span> (countOccurences(nums, candidate) &gt; majority)</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h2 id="复杂数学"><a href="#复杂数学" class="headerlink" title="复杂数学"></a>复杂数学</h2><h3 id="变为棋盘"><a href="#变为棋盘" class="headerlink" title="变为棋盘"></a>变为棋盘</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-08-23%2009.33.31.png" alt="截屏2022-08-23 09.33.31" style="zoom:50%;" />







<h3 id="子串中唯一字符串"><a href="#子串中唯一字符串" class="headerlink" title="子串中唯一字符串"></a>子串中唯一字符串</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-07%2000.52.57.png" alt="截屏2022-09-07 00.52.57" style="zoom:50%;" />











<h3 id="全局、局部倒置"><a href="#全局、局部倒置" class="headerlink" title="全局、局部倒置"></a>全局、局部倒置</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-16%2023.47.26.png" alt="截屏2022-11-16 23.47.26" style="zoom:50%;" />



<p><strong>从后往前遍历！</strong></p>
<p>仔细分析后发现，局部倒置一定是全局倒置，那么只需要找到一个跨度大于1且nums[i] &gt; nums[j]的数对即可，并且可以从后往前遍历，维护一个最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIdealPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, min = nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; min) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = Math.min(nums[i + <span class="number">1</span>], min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>归纳证明！！</strong></p>
<p>这个做法更妙了，假设数组满足局部倒置等于非局部倒置，那么最小值的下标一定不能大于等于2</p>
<ul>
<li>如果 nums[0] &#x3D; 0, 那么问题转换为[1, n-1]区间的一个子问题</li>
<li>如果 nums[[0] &#x3D; 1, 那么nums[0]] 必须为1，否则，就不满足，所以问题转换为一个 [2, n-1]的子问题</li>
<li>经过总结，|nums[i] - i | &lt;&#x3D; 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIdealPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(nums[i] - i) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h2 id="贪心-数学"><a href="#贪心-数学" class="headerlink" title="贪心 + 数学"></a>贪心 + 数学</h2><h3 id="递减元素使数组呈锯齿状"><a href="#递减元素使数组呈锯齿状" class="headerlink" title="递减元素使数组呈锯齿状"></a>递减元素使数组呈锯齿状</h3><blockquote>
<p>给你一个整数数组 <code>nums</code>，每次 <strong>操作</strong> 会从中选择一个元素并 <strong>将该元素的值减少 1</strong>。</p>
<p>如果符合下列情况之一，则数组 <code>A</code> 就是 <strong>锯齿数组</strong>：</p>
<ul>
<li>每个偶数索引对应的元素都大于相邻的元素，即 <code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li>
<li>或者，每个奇数索引对应的元素都大于相邻的元素，即 <code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li>
</ul>
<p>返回将数组 <code>nums</code> 转换为锯齿数组所需的最小操作次数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movesToMakeZigzag</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 用一个两个元素的数组来存储分类讨论的情况</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = nums.length; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span>  <span class="operator">=</span> i &gt; <span class="number">0</span> ? nums[i - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i &lt; n - <span class="number">1</span> ? nums[i + <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">            ans[i % <span class="number">2</span>] += Math.max(nums[i] - Math.min(left, right) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="进制相关"><a href="#进制相关" class="headerlink" title="进制相关"></a>进制相关</h2><h3 id="二进制数转字符串"><a href="#二进制数转字符串" class="headerlink" title="二进制数转字符串"></a>二进制数转字符串</h3><blockquote>
<p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>
<p>LeetCode: 面试题 05.02</p>
</blockquote>
<p><strong>思路</strong></p>
<p>核心思想就是如何循环拿到每一位然后拼接到字符串里面，一般来说就是拿到最后一位或者第一位<br>在二进制中，以 0.625 为例，乘2, 二进制由 0.101 变成 1.01，这样可以拿到第一位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">printBin</span><span class="params">(<span class="type">double</span> num)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (sb.length() &lt;= <span class="number">32</span> &amp;&amp; num != <span class="number">0</span>) &#123;</span><br><span class="line">            num *= <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> (<span class="type">int</span>) num;</span><br><span class="line">            sb.append(digit);</span><br><span class="line">            num -= digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() &lt;= <span class="number">32</span> ? sb.toString() : <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h3><blockquote>
<p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p>
<p>LeetCode(hot 100) 338</p>
</blockquote>
<p><strong>brain kernighan 算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans[i] = getOnes(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// brain kernighan 算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOnes</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这样做可以消除 x 的最后一个 1</span></span><br><span class="line">            num = num &amp; (num - <span class="number">1</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="负二进制数相加"><a href="#负二进制数相加" class="headerlink" title="负二进制数相加"></a>负二进制数相加</h3><blockquote>
<p>给出基数为 <strong>-2</strong> 的两个数 <code>arr1</code> 和 <code>arr2</code>，返回两数相加的结果。</p>
<p>数字以 <em>数组形式</em> 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，<code>arr = [1,1,0,1]</code> 表示数字 <code>(-2)^3 + (-2)^2 + (-2)^0 = -3</code>。<em>数组形式</em> 中的数字 <code>arr</code> 也同样不含前导零：即 <code>arr == [0]</code> 或 <code>arr[0] == 1</code>。</p>
<p>返回相同表示形式的 <code>arr1</code> 和 <code>arr2</code> 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。</p>
<p>LeetCode 1073(Medium)</p>
</blockquote>
<p><strong>模拟</strong></p>
<p>需要注意的是 -2 进制下的进位是 - 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] addNegabinary(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr1.length - <span class="number">1</span>, j = arr2.length - <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> carry;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) x += arr1[i];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) x += arr2[j];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                res.add(x - <span class="number">2</span>);</span><br><span class="line">                carry = -<span class="number">1</span>; <span class="comment">// 因为基数是 -2， 所以进位是 -1，（绝对值变大)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(x);</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="number">1</span>);</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (res.size() &gt; <span class="number">1</span> &amp;&amp; res.get(res.size() - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">            arr[i] = res.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="可被60整除"><a href="#可被60整除" class="headerlink" title="可被60整除"></a>可被60整除</h3><blockquote>
<p>在歌曲列表中，第 <code>i</code> 首歌曲的持续时间为 <code>time[i]</code> 秒。</p>
<p>返回其总持续时间（以秒为单位）可被 <code>60</code> 整除的歌曲对的数量。形式上，我们希望下标数字 <code>i</code> 和 <code>j</code> 满足 <code>i &lt; j</code> 且有 <code>(time[i] + time[j]) % 60 == 0</code>。</p>
<p>LeetCode 1010 (medium)</p>
</blockquote>
<p><strong>分析</strong></p>
<p>需要返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量，因此，每首歌曲对结果的影响因素是它的持续时间除以 60 后的余数。可以用一个长度为 60 的数组 cnt，用来表示余数出现的次数。然后分情况统计歌曲对：</p>
<ul>
<li><p>余数为 0的歌曲。他们需要与余数为 0 的歌曲组成对，但不能与自己组成对。歌曲对的数量为 cnt[0]×(cnt[0]−1)&#x2F;2</p>
</li>
<li><p>余数为 30 的歌曲。他们需要与余数为 30 的歌曲组成对，但不能与自己组成对。歌曲对的数量为 cnt[30]×(cnt[30]−1)&#x2F;2</p>
</li>
<li><p>余数为 i,i∈[1,29]i, i∈[1,29] 的歌曲。他们需要与余数为 60−i 的歌曲组成对。歌曲对的数量为 ∑i&#x3D;129cnt[i]×cnt[60−i]</p>
</li>
<li><p>余数为 i,i∈[31,59]i, i\in[31,59]i,i∈[31,59] 的歌曲。已经在上一部分组对过，不需要重复计算。</p>
</li>
<li><p>把这几部分求和，就可以得到最后的对数。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numPairsDivisibleBy60</span><span class="params">(<span class="type">int</span>[] time)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : time) &#123;</span><br><span class="line">            cnt[num % <span class="number">60</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            res += cnt[i] * cnt[<span class="number">60</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        res += (<span class="type">long</span>)cnt[<span class="number">0</span>] * (cnt[<span class="number">0</span>] - <span class="number">1</span>) / <span class="number">2</span> + (<span class="type">long</span>)cnt[<span class="number">30</span>] * (cnt[<span class="number">30</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="简单字符处理"><a href="#简单字符处理" class="headerlink" title="简单字符处理"></a>简单字符处理</h2><h3 id="重排列单词空格"><a href="#重排列单词空格" class="headerlink" title="重排列单词空格"></a>重排列单词空格</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-07%2014.29.20.png" alt="截屏2022-09-07 14.29.20" style="zoom:50%;" />



<p><strong>双指针</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reorderSpaces</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), cnt = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; ++i &gt;= <span class="number">0</span> &amp;&amp; ++cnt &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; s.charAt(j) != <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">            list.add(s.substring(i, j));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> list.size(), t = cnt / Math.max(m - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span>) k += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            sb.append(list.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != m - <span class="number">1</span>) sb.append(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sb.length() != n) sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>超强API调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reorderSpaces</span><span class="params">(String text)</span> &#123;</span><br><span class="line">       String[] words = text.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">int</span>) text.chars().filter(x -&gt; x == <span class="string">&#x27; &#x27;</span>).count(), m = words.length;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">1</span>) <span class="keyword">return</span> String.join(<span class="string">&quot;&quot;</span>, words).concat(<span class="string">&quot; &quot;</span>.repeat(s));</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>.repeat(s / (m - <span class="number">1</span>)), words)</span><br><span class="line">                .concat(<span class="string">&quot; &quot;</span>.repeat(s % (m - <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="相同字符间隔"><a href="#相同字符间隔" class="headerlink" title="相同字符间隔"></a>相同字符间隔</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-09-17%2023.53.21.png" alt="截屏2022-09-17 23.53.21" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLengthBetweenEqualCharacters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] characterMap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(characterMap, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (characterMap[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] != -<span class="number">1</span>) &#123;</span><br><span class="line">                max = Math.max(max, i - characterMap[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                characterMap[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="格式化号码"><a href="#格式化号码" class="headerlink" title="格式化号码"></a>格式化号码</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-01%2016.59.01.png" alt="截屏2022-10-01 16.59.01" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reformatNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> number.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i += <span class="number">3</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ans.length() != <span class="number">0</span>) &#123;</span><br><span class="line">               ans.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 剩下的字母数字小于等于4个</span></span><br><span class="line">           <span class="keyword">if</span> (i + <span class="number">4</span> &gt;= n) &#123;</span><br><span class="line">               <span class="comment">// 剩下的字母数字小于等于3个</span></span><br><span class="line">               <span class="keyword">if</span> (i + <span class="number">3</span> &gt;= n) &#123;</span><br><span class="line">                   ans.append(s.substring(i));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 剩下的字母数字为4个</span></span><br><span class="line">                   ans.append(s.substring(i, i+<span class="number">2</span>) + <span class="string">&quot;-&quot;</span> + </span><br><span class="line">                    s.substring(i+<span class="number">2</span>, i+<span class="number">4</span>));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ans.append(s.substring(i, i+<span class="number">3</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="交换字符"><a href="#交换字符" class="headerlink" title="交换字符"></a>交换字符</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-11%2015.31.27.png" alt="截屏2022-10-11 15.31.27" style="zoom:50%;" />



<p><strong>这个题很简单，但是这段代码写的极其优雅，将时空压缩以及if else 逻辑玩的很透</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areAlmostEqual</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), idx1 = -<span class="number">1</span>, idx2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx1 == -<span class="number">1</span>) &#123;</span><br><span class="line">                idx1 = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx2 == -<span class="number">1</span>) &#123;</span><br><span class="line">                idx2 = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx1 == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx2 == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.charAt(idx1) == s2.charAt(idx2) &amp;&amp; </span><br><span class="line">            s1.charAt(idx2) == s2.charAt(idx1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="字母大小写全排列"><a href="#字母大小写全排列" class="headerlink" title="字母大小写全排列"></a>字母大小写全排列</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-01%2015.32.21.png" alt="截屏2022-11-01 15.32.21" style="zoom:50%;" />



<p><strong>方法一：广度优先搜索</strong></p>
<p>基本思想和图的广度优先搜索差不多，借助一个缓存队列 arrayDeque，将每一位的可能性都加入到queue中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// ans list 用来存放结果</span></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// StringBuilder 类型的queue用来存放遍历过程中每一种子串的种类</span></span><br><span class="line">        Queue&lt;StringBuilder&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (sb.length() == s.length()) &#123;</span><br><span class="line">                 <span class="comment">// 如果当前从queue拿出来的串长度和s相同就加入ans集合并从缓存queue中弹出</span></span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前子串没遍历到最后一位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();</span><br><span class="line">                <span class="keyword">if</span> (Character.isLetter(s.charAt(len))) &#123;</span><br><span class="line">                    <span class="comment">// 如果该子串的下一位是字母就在缓存queue中加入新的sb</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sbsb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(sb);</span><br><span class="line">                    <span class="comment">// 字符和32相与会改变大小写</span></span><br><span class="line">                    sbsb.append((<span class="type">char</span>)(s.charAt(len) ^ <span class="number">32</span>));</span><br><span class="line">                    <span class="comment">// 改变了下一位的大小写后加入缓存queue</span></span><br><span class="line">                    queue.offer(sbsb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果不是字母就直接加入到sb</span></span><br><span class="line">                sb.append(s.charAt(len));</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法二：回溯</strong></p>
<p>给人的感觉就是深度优先遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// ans list 用来存放结果</span></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(s.toCharArray(), <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> pos, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; arr.length &amp;&amp; Character.isDigit(arr[pos])) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == arr.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 改变大小写后递归下一位</span></span><br><span class="line">        arr[pos] ^= <span class="number">32</span>;</span><br><span class="line">        dfs(arr, pos + <span class="number">1</span>, ans);</span><br><span class="line">        <span class="comment">// 再变回来，这样就做到了不改变大小写从而去遍历下一位</span></span><br><span class="line">        arr[pos] ^= <span class="number">32</span>;</span><br><span class="line">        dfs(arr, pos + <span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>方法三：二进制位图</strong></p>
<h3 id="自定义字符串排序"><a href="#自定义字符串排序" class="headerlink" title="自定义字符串排序"></a>自定义字符串排序</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-13%2023.09.56.png" alt="截屏2022-11-13 23.09.56" style="zoom:50%;" />





<p><strong>自定义一个比较器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">customSortString</span><span class="params">(String order, String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 采用基数数组的形式给 order 的字符加权值</span></span><br><span class="line">        <span class="type">int</span>[] sorted = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; order.length(); i++) &#123;</span><br><span class="line">            sorted[order.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里只能使用Character数组，不然Arrays.sort()方法识别不了</span></span><br><span class="line">        Character[] ss = <span class="keyword">new</span> <span class="title class_">Character</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ss.length; i++) &#123;</span><br><span class="line">            ss[i] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个比较器，将权值大的放后面</span></span><br><span class="line">        Arrays.sort(ss, (a, b) -&gt; sorted[a - <span class="string">&#x27;a&#x27;</span>] - sorted[b - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ss) &#123;</span><br><span class="line">            ans.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>基数排序</strong></p>
<p>或者弄一个基数排序的方法，定义一个频率数组，用while循环去拼接SB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">customSortString</span><span class="params">(String order, String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明一个频率数组</span></span><br><span class="line">        <span class="type">int</span>[] freq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            freq[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; order.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(freq[order.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans.append(order.charAt(i));</span><br><span class="line">                freq[order.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(freq[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.append((<span class="type">char</span>)(i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                    freq[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="字符串美丽值之和"><a href="#字符串美丽值之和" class="headerlink" title="字符串美丽值之和"></a>字符串美丽值之和</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-12-12%2010.22.12.png" alt="截屏2022-12-12 10.22.12" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">beautySum</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">      <span class="comment">// 双循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="comment">// 记录当前字串的字符频率</span></span><br><span class="line">            <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxFreq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                cnt[s.charAt(j) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                maxFreq = Math.max(maxFreq, cnt[s.charAt(j) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">minFreq</span> <span class="operator">=</span> n;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        minFreq = Math.min(minFreq, cnt[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += maxFreq - minFreq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="全字母句"><a href="#全字母句" class="headerlink" title="全字母句"></a>全字母句</h3><blockquote>
<p>1832</p>
<p><strong>全字母句</strong> 指包含英语字母表中每个字母至少一次的句子。</p>
<p>给你一个仅由小写英文字母组成的字符串 <code>sentence</code> ，请你判断 <code>sentence</code>是否为 <strong>全字母句</strong> 。</p>
<p>如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</blockquote>
<p><strong>数位法</strong></p>
<p>利用一个 32 位 int 来表示 26 个英文字母</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfPangram</span><span class="params">(String sentence)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sentence.toCharArray()) &#123;</span><br><span class="line">            state |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state == (<span class="number">1</span> &lt;&lt; <span class="number">26</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="字符转数字"><a href="#字符转数字" class="headerlink" title="字符转数字"></a>字符转数字</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-12-15%2010.02.57.png" alt="截屏2022-12-15 10.02.57" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLucky</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;  s.length(); i++) &#123;</span><br><span class="line">            sb.append(s.charAt(i) - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">digits</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k &amp;&amp; digits.length() &gt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; digits.length(); j++) &#123;</span><br><span class="line">                sum += digits.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits = Integer.toString(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(digits);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="替换括号内容"><a href="#替换括号内容" class="headerlink" title="替换括号内容"></a>替换括号内容</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-01-12%2023.08.55.png" alt="截屏2023-01-12 23.08.55" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">(String s, List&lt;List&lt;String&gt;&gt; knowledge)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : knowledge) &#123;</span><br><span class="line">            dict.put(list.get(<span class="number">0</span>), list.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">addKey</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                addKey = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dict.containsKey(key.toString())) &#123;</span><br><span class="line">                    res.append(dict.get(key.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.append(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                addKey = <span class="literal">false</span>;</span><br><span class="line">                key.setLength(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (addKey) &#123;</span><br><span class="line">                    key.append(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.append(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="解密消息"><a href="#解密消息" class="headerlink" title="解密消息"></a>解密消息</h3><blockquote>
<p>2325</p>
<p>给你字符串 <code>key</code> 和 <code>message</code> ，分别表示一个加密密钥和一段加密消息。解密 <code>message</code> 的步骤如下：</p>
<ol>
<li>使用 <code>key</code> 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 <strong>顺序</strong> 。</li>
<li>将替换表与普通英文字母表对齐，形成对照表。</li>
<li>按照对照表 <strong>替换</strong> <code>message</code> 中的每个字母。</li>
<li>空格 <code>&#39; &#39;</code> 保持不变。</li>
</ol>
<ul>
<li>例如，<code>key = &quot;***hap***p***y*** ***bo***y&quot;</code>（实际的加密密钥会包含字母表中每个字母 <strong>至少一次</strong>），据此，可以得到部分对照表（<code>&#39;h&#39; -&gt; &#39;a&#39;</code>、<code>&#39;a&#39; -&gt; &#39;b&#39;</code>、<code>&#39;p&#39; -&gt; &#39;c&#39;</code>、<code>&#39;y&#39; -&gt; &#39;d&#39;</code>、<code>&#39;b&#39; -&gt; &#39;e&#39;</code>、<code>&#39;o&#39; -&gt; &#39;f&#39;</code>）。</li>
</ul>
<p>返回解密后的消息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeMessage</span><span class="params">(String key, String message)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> &amp;&amp; !map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, cur);</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; message.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> message.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                c = map.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="隐藏个人信息"><a href="#隐藏个人信息" class="headerlink" title="隐藏个人信息"></a>隐藏个人信息</h3><blockquote>
<p>给你一条个人信息字符串 <code>s</code> ，可能表示一个 <strong>邮箱地址</strong> ，也可能表示一串 <strong>电话号码</strong> 。返回按如下规则 <strong>隐藏</strong> 个人信息后的结果：</p>
<p><em><strong>电子邮件地址：</strong></em></p>
<p>一个电子邮件地址由以下部分组成：</p>
<ul>
<li>一个 <strong>名字</strong> ，由大小写英文字母组成，后面跟着</li>
<li>一个 <code>&#39;@&#39;</code> 字符，后面跟着</li>
<li>一个 <strong>域名</strong> ，由大小写英文字母和一个位于中间的 <code>&#39;.&#39;</code> 字符组成。<code>&#39;.&#39;</code> 不会是域名的第一个或者最后一个字符。</li>
</ul>
<p>要想隐藏电子邮件地址中的个人信息：</p>
<ul>
<li><strong>名字</strong> 和 <strong>域名</strong> 部分的大写英文字母应当转换成小写英文字母。</li>
<li><strong>名字</strong> 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 <code>&quot;*****&quot;</code> 替换。</li>
</ul>
<p><em><strong>电话号码：</strong></em></p>
<p>一个电话号码应当按下述格式组成：</p>
<ul>
<li>电话号码可以由 10-13 位数字组成</li>
<li>后 10 位构成 <strong>本地号码</strong></li>
<li>前面剩下的 0-3 位，构成 <strong>国家代码</strong></li>
<li>利用 <code>&#123;&#39;+&#39;, &#39;-&#39;, &#39;(&#39;, &#39;)&#39;, &#39; &#39;&#125;</code> 这些 <strong>分隔字符</strong> 按某种形式对上述数字进行分隔</li>
</ul>
<p>要想隐藏电话号码中的个人信息：</p>
<ul>
<li>移除所有 <strong>分隔字符</strong></li>
<li>隐藏个人信息后的电话号码应该遵从这种格式：<ul>
<li><code>&quot;***-***-XXXX&quot;</code> 如果国家代码为 0 位数字</li>
<li><code>&quot;+*-***-***-XXXX&quot;</code> 如果国家代码为 1 位数字</li>
<li><code>&quot;+**-***-***-XXXX&quot;</code> 如果国家代码为 2 位数字</li>
<li><code>&quot;+***-***-***-XXXX&quot;</code> 如果国家代码为 3 位数字</li>
</ul>
</li>
<li><code>&quot;XXXX&quot;</code> 是最后 4 位 <strong>本地号码</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String[] country = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;+*-&quot;</span>,<span class="string">&quot;+**-&quot;</span>, <span class="string">&quot;+***-&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">maskPII</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">at</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (at &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = s.toLowerCase();</span><br><span class="line">            <span class="keyword">return</span> s.charAt(<span class="number">0</span>) + <span class="string">&quot;*****&quot;</span> + s.substring(at - <span class="number">1</span>).toLowerCase();</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.replaceAll(<span class="string">&quot;[^0-9]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> country[s.length() - <span class="number">10</span>] + <span class="string">&quot;***-***-&quot;</span> + s.substring(s.length() - <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="动归字符"><a href="#动归字符" class="headerlink" title="动归字符"></a>动归字符</h2><h3 id="不同子序列2"><a href="#不同子序列2" class="headerlink" title="不同子序列2"></a>不同子序列2</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-14%2014.31.21.png" alt="截屏2022-10-14 14.31.21" style="zoom:50%;" />



<p><strong>思路</strong></p>
<p>当前字符串数 &#x3D; 上一个字符的字符串数  + 当前字符所加上后组成的字符数 - 重复数</p>
<img src="/Users/lei/Desktop/Typora笔记/图片/截屏2022-10-14 14.47.53.png" alt="截屏2022-10-14 14.47.53" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distinctSubseqII</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 用基数数组来记录上一个字符出现的次数</span></span><br><span class="line">        <span class="type">int</span>[] preAdded = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curCnt</span> <span class="operator">=</span> ans;</span><br><span class="line">            ans = ((ans + curCnt) % mod - </span><br><span class="line">                preAdded[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] % mod + mod) % mod;</span><br><span class="line">            preAdded[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = curCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后减去空字符串</span></span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h3 id="KMP-详解"><a href="#KMP-详解" class="headerlink" title="KMP 详解"></a>KMP 详解</h3><blockquote>
<ul>
<li>首先要了解字符串前缀和后缀的概念<ul>
<li>“aba” 的前缀是 “a”,”ab” 后缀是 “ba”,”a”，交集是 “a”</li>
</ul>
</li>
<li></li>
</ul>
</blockquote>
<h2 id="数位字符"><a href="#数位字符" class="headerlink" title="数位字符"></a>数位字符</h2><h3 id="最好英文字母"><a href="#最好英文字母" class="headerlink" title="最好英文字母"></a>最好英文字母</h3><blockquote>
<p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong>英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p>
<p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p>
<p>英文字母 <code>b</code> 比另一个英文字母 <code>a</code> <strong>更好</strong> 的前提是：英文字母表中，<code>b</code>在 <code>a</code> 之 <strong>后</strong> 出现。</p>
</blockquote>
<p><strong>一般可以用哈希set写的字符题目都可以用数位来写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greatestLetter</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lower</span> <span class="operator">=</span> <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isLowerCase(c)) &#123;</span><br><span class="line">                lower |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                upper |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lower &amp; upper &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> String.valueOf((<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="BFS、DFS"><a href="#BFS、DFS" class="headerlink" title="BFS、DFS"></a>BFS、DFS</h2><blockquote>
<p>给你一个字符串 <code>s</code> 以及两个整数 <code>a</code> 和 <code>b</code> 。其中，字符串 <code>s</code> 的长度为偶数，且仅由数字 <code>0</code> 到 <code>9</code> 组成。</p>
<p>你可以在 <code>s</code> 上按任意顺序多次执行下面两个操作之一：</p>
<ul>
<li>累加：将 <code>a</code> 加到 <code>s</code> 中所有下标为奇数的元素上（<strong>下标从 0 开始</strong>）。数字一旦超过 <code>9</code> 就会变成 <code>0</code>，如此循环往复。例如，<code>s = &quot;3456&quot;</code> 且 <code>a = 5</code>，则执行此操作后 <code>s</code> 变成 <code>&quot;3951&quot;</code>。</li>
<li>轮转：将 <code>s</code> 向右轮转 <code>b</code> 位。例如，<code>s = &quot;3456&quot;</code> 且 <code>b = 1</code>，则执行此操作后 <code>s</code> 变成 <code>&quot;6345&quot;</code>。</li>
</ul>
<p>请你返回在 <code>s</code> 上执行上述操作任意次后可以得到的 <strong>字典序最小</strong> 的字符串。</p>
<p>如果两个字符串长度相同，那么字符串 <code>a</code> 字典序比字符串 <code>b</code> 小可以这样定义：在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，字符串 <code>a</code> 中的字符出现在字母表中的时间早于 <code>b</code> 中的对应字符。例如，<code>&quot;0158”</code>字典序比 <code>&quot;0190&quot;</code> 小，因为不同的第一个位置是在第三个字符，显然 <code>&#39;5&#39;</code> 出现在 <code>&#39;9&#39;</code> 之前。</p>
<p>LeetCode: 1625</p>
</blockquote>
<p><strong>广度优先</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLexSmallestString</span><span class="params">(String s, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// bfs 操作队列</span></span><br><span class="line">        Deque&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.offer(s);</span><br><span class="line">        Set&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        vis.add(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> s;</span><br><span class="line">        <span class="comment">// 去对每一个队列里面的元素进行操作，从而枚举所有的可能性</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            s = q.poll();</span><br><span class="line">            <span class="comment">// 比较 ans 和当前操作字符串的 ascii 码</span></span><br><span class="line">            <span class="keyword">if</span> (ans.compareTo(s) &gt; <span class="number">0</span>) ans = s;</span><br><span class="line">            <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">            <span class="comment">// 奇数位 + a</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) </span><br><span class="line">                cs[i] = (<span class="type">char</span>)(((cs[i] - <span class="string">&#x27;0&#x27;</span> + a) % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">t1</span> <span class="operator">=</span> String.valueOf(cs);</span><br><span class="line">            <span class="comment">// 偶数位右移 b 位，这里用截取子串的形式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">t2</span> <span class="operator">=</span> s.substring(n - b) + s.substring(<span class="number">0</span>, n - b);</span><br><span class="line">            <span class="comment">// 将两个操作结果加到 list 中并判断是否出现过</span></span><br><span class="line">            <span class="keyword">for</span> (String t : List.of(t1, t2)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis.add(t)) &#123;</span><br><span class="line">                    q.offer(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>枚举</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLexSmallestString</span><span class="params">(String s, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            s = s.substring(b) + s.substring(<span class="number">0</span>, b);</span><br><span class="line">            <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; n; k += <span class="number">2</span>) &#123;</span><br><span class="line">                   cs[k] = (<span class="type">char</span>) (((cs[k] - <span class="string">&#x27;0&#x27;</span> + a) % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; <span class="number">10</span>; ++p) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k += <span class="number">2</span>) &#123;</span><br><span class="line">                            cs[k] = (<span class="type">char</span>) (((cs[k] - <span class="string">&#x27;0&#x27;</span> + a) % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        s = String.valueOf(cs);</span><br><span class="line">                        <span class="keyword">if</span> (ans.compareTo(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            ans = s;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s = String.valueOf(cs);</span><br><span class="line">                    <span class="keyword">if</span> (ans.compareTo(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        ans = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h3><blockquote>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p>LeetCode(hot 100) 49</p>
</blockquote>
<p><strong>排序</strong></p>
<p>可以找到一个规律，如果几个字符串互为字母异位词，那么将他们的字符排序的结果是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">            <span class="comment">// 按字符排序字符串</span></span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>计数</strong></p>
<p>总体思想和排序类似，只不过把map的key用计数的方式得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                cnt[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append((<span class="type">char</span>)(i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                    <span class="comment">// 把出现频率也拼接上可以防止重复字符的问题</span></span><br><span class="line">                    sb.append(cnt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="字符串-双指针"><a href="#字符串-双指针" class="headerlink" title="字符串 + 双指针"></a>字符串 + 双指针</h2><h3 id="字典序排在最后的字符串"><a href="#字典序排在最后的字符串" class="headerlink" title="字典序排在最后的字符串"></a>字典序排在最后的字符串</h3><blockquote>
<p>给你一个字符串 <code>s</code> ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p>
<p>LeetCode 1163 (hard)</p>
</blockquote>
<p><strong>分析</strong></p>
<p>此题是一道思维题，第一遍读完题，我以为它是动态规划题，或者用回溯做，主要思路就是枚举所有子串，然后比较字典序即可，但是转念又想，以 abcd 举例子，a 开头的所有子串，都有相同的前缀 a，所以，后缀越长的子串，那么我只需要遍历字符串，然后比较每一个字符开始到字符串结尾的子串不就好了？于是我写下了如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lastSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(i, n);</span><br><span class="line">            <span class="keyword">if</span> (sub.compareTo(ans) &gt; <span class="number">0</span>) ans = sub;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果力扣这老小子给了我一个几千个由 a 组成的测试案例，让我代码超时，所以我的思路行不通，那么只能从 KMP 算法中借鉴一下他的思想，不采用暴力匹配的方式，将重复的子串跳过比较</p>
<p><strong>双指针</strong></p>
<p>我们可以做如下考虑：利用两个指针，i 指向当前字典序最大的字符串起始位置，循环 j 来比较，在每次比较时需要合适的策略来移动 i 可以做到减少比较次数，然后返回 i 到字符串结尾就好了。</p>
<p> 以 s &#x3D; cacacb 为例，初始 i &#x3D; 0，j &#x3D; 1，第一次不同是 a 和 c，j 的字典序较小，于是 j++，下一次循环比较不同是 k &#x3D; 3 的时候，i 是 a， j 是 b，i 的字典序较小，这时候我们需要移动 i，i &#x3D; i + k + 1，因为，在 {i, i + k} 区间内的所有子串都一定比 j 位置的字符串小，所以可以不用比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lastSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>, k = <span class="number">0</span>; j + k &lt; n;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(i + k) - s.charAt(j + k);</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">                k++; <span class="comment">// 相同就移动 k 来继续比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                i += k + <span class="number">1</span>;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                    j = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j += k + <span class="number">1</span>;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h1 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h1><hr>
<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="统计共同度过的日子"><a href="#统计共同度过的日子" class="headerlink" title="统计共同度过的日子"></a>统计共同度过的日子</h3><blockquote>
<p>Alice 和 Bob 计划分别去罗马开会。</p>
<p>给你四个字符串 <code>arriveAlice</code> ，<code>leaveAlice</code> ，<code>arriveBob</code> 和 <code>leaveBob</code> 。Alice 会在日期 <code>arriveAlice</code> 到 <code>leaveAlice</code> 之间在城市里（<strong>日期为闭区间</strong>），而 Bob 在日期 <code>arriveBob</code> 到 <code>leaveBob</code> 之间在城市里（<strong>日期为闭区间</strong>）。每个字符串都包含 5 个字符，格式为 <code>&quot;MM-DD&quot;</code> ，对应着一个日期的月和日。</p>
<p>请你返回 Alice和 Bob 同时在罗马的天数。</p>
<p>你可以假设所有日期都在 <strong>同一个</strong> 自然年，而且 <strong>不是</strong> 闰年。每个月份的天数分别为：<code>[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</code> 。</p>
<p>LeetCode 2409</p>
</blockquote>
<p><strong>模拟</strong></p>
<p>将日期转换成在一年的天数中的坐标，即可通过 right - lef + 1的方式计算出边界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟12个月份的天气，后面直接累加月份的天数即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] DAYS = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算某个日期在一年中的坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">caculateDate</span><span class="params">(String date)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] d = date.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> (d[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + d[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mon</span> <span class="operator">=</span> (d[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + d[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 只需要遍历到当前月的上一个月</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mon - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            day += DAYS[i];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDaysTogether</span><span class="params">(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> caculateDate(arriveAlice.compareTo(arriveBob) &gt; <span class="number">0</span> ? arriveAlice : arriveBob);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> caculateDate(leaveAlice.compareTo(leaveBob) &lt; <span class="number">0</span> ? leaveAlice : leaveBob);</span><br><span class="line">        <span class="keyword">return</span> Math.max(right - left + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="差值不同的字符串"><a href="#差值不同的字符串" class="headerlink" title="差值不同的字符串"></a>差值不同的字符串</h3><blockquote>
<p>给你一个字符串数组 <code>words</code> ，每一个字符串长度都相同，令所有字符串的长度都为 <code>n</code> 。</p>
<p>每个字符串 <code>words[i]</code> 可以被转化为一个长度为 <code>n - 1</code> 的 <strong>差值整数数组</strong> <code>difference[i]</code> ，其中对于 <code>0 &lt;= j &lt;= n - 2</code> 有 <code>difference[i][j] = words[i][j+1] - words[i][j]</code> 。注意两个字母的差值定义为它们在字母表中 <strong>位置</strong> 之差，也就是说 <code>&#39;a&#39;</code> 的位置是 <code>0</code> ，<code>&#39;b&#39;</code> 的位置是 <code>1</code> ，<code>&#39;z&#39;</code> 的位置是 <code>25</code> 。</p>
<ul>
<li>比方说，字符串 <code>&quot;acb&quot;</code> 的差值整数数组是 <code>[2 - 0, 1 - 2] = [2, -1]</code> 。</li>
</ul>
<p><code>words</code> 中所有字符串 <strong>除了一个字符串以外</strong> ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</p>
<p>请你返回 <code>words</code>中 <strong>差值整数数组</strong> 不同的字符串。</p>
<p>LeetCode 2451 (easy)</p>
</blockquote>
<p><strong>分析</strong></p>
<p>这题比较简单，看上去也没什么算法，无非是先写一个得到差值数组的方法，然后再循环遍历每一个字符串得到各自的差值数组后比较得出不同的那个，我的第一反应就是用一个 HashMap 去存差值数组，最后这个HashMap 里面只有两个元素，个数为 1的那个就是，但是很明显这个方法的空间复杂度和思维都不够优秀，所以记录一下官方题解，他的空间复杂度只有 O1<br>原理是先比较数组的前两个元素，如果不同，说明答案就在其中一个，再和第三个元素比较即可，如果相同就更好办了，继续遍历余下数组，不同的那个就是答案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">oddString</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] diff0 = getDiff(words[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span>[] diff1 = getDiff(words[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(diff0, diff1)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!Arrays.equals(diff0, getDiff(words[i]))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> words[i];</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(diff0, getDiff(words[<span class="number">2</span>])) ? words[<span class="number">1</span>] : words[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getDiff(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res[i] = s.charAt(i + <span class="number">1</span>) - s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="常规模拟"><a href="#常规模拟" class="headerlink" title="常规模拟"></a>常规模拟</h2><h3 id="链表组件"><a href="#链表组件" class="headerlink" title="链表组件"></a>链表组件</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-12%2010.50.46.png" alt="截屏2022-10-12 10.50.46" style="zoom:50%;" />



<p><strong>用一个flag表示链表上一个元素是否在nums的set中，这个点比较妙</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numComponents</span><span class="params">(ListNode head, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; numsSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            numsSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inSet</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numsSet.contains(head.val)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!inSet) &#123;</span><br><span class="line">                    inSet = <span class="literal">true</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inSet = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="猜数字游戏"><a href="#猜数字游戏" class="headerlink" title="猜数字游戏"></a>猜数字游戏</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-10-17%2023.07.32.png" alt="截屏2022-10-17 23.07.32" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHint</span><span class="params">(String secret, String guess)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bulls</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] cntS = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span>[] cntG = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; secret.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret.charAt(i) == guess.charAt(i)) &#123;</span><br><span class="line">                bulls++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cntS[secret.charAt(i) - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">                cntG[guess.charAt(i) - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cows += Math.min(cntG[i], cntS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(bulls) + <span class="string">&quot;A&quot;</span> + Integer.toString(cows) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="解析布尔表达式"><a href="#解析布尔表达式" class="headerlink" title="解析布尔表达式"></a>解析布尔表达式</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-06%2000.11.27.png" alt="截屏2022-11-06 00.11.27" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">parseBoolExpr</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">      <span class="comment">// 用栈来模拟</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> expression.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (stack.peek() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (cur == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                        f++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        t++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="type">char</span> <span class="variable">operation</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">              <span class="comment">// 这里是核心，记录 t 和 f 的个数即可判断对错</span></span><br><span class="line">                <span class="keyword">switch</span>(operation) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                        stack.push(f == <span class="number">1</span> ? <span class="string">&#x27;t&#x27;</span> : <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                        stack.push(f == <span class="number">0</span> ? <span class="string">&#x27;t&#x27;</span> : <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                        stack.push(t &gt; <span class="number">0</span> ? <span class="string">&#x27;t&#x27;</span> : <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek() == <span class="string">&#x27;t&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h3 id="模糊坐标"><a href="#模糊坐标" class="headerlink" title="模糊坐标"></a>模糊坐标</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-07%2010.42.52.png" alt="截屏2022-11-07 10.42.52" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">ambiguousCoordinates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        s = s.substring(<span class="number">1</span>, s.length() - <span class="number">1</span>); <span class="comment">// 先去掉前后括号，只保留数字部分。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) <span class="comment">// 将s划分成【x轴】和【y轴】</span></span><br><span class="line">        <span class="comment">// 获得x轴由逗号分割的【n种】可能的合法数字</span></span><br><span class="line">            <span class="keyword">for</span> (String x : genNums(s.substring(<span class="number">0</span>, i))) </span><br><span class="line">            <span class="comment">// 获得y轴由逗号分割的【m种】可能的合法数字</span></span><br><span class="line">                <span class="keyword">for</span> (String y : genNums(s.substring(i))) </span><br><span class="line">                 <span class="comment">// 拼装在最终结果【n*m种】</span></span><br><span class="line">                    result.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;(&quot;</span>).append(x).</span><br><span class="line">                    append(<span class="string">&quot;, &quot;</span>).append(y).append(<span class="string">&quot;)&quot;</span>).toString());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将num用逗号分割 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">genNums</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        String left, right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= num.length()) &#123;</span><br><span class="line">            left = num.substring(<span class="number">0</span>, i); <span class="comment">// 分割【整数】部分</span></span><br><span class="line">            right = num.substring(i++); <span class="comment">// 分割【小数】部分</span></span><br><span class="line">            <span class="comment">// 对于逗号左侧【整数】，不允许以0开头，除非这个整数就是0本身</span></span><br><span class="line">            <span class="comment">// 对于逗号右侧【小数】，不允许以0作为结尾</span></span><br><span class="line">            <span class="keyword">if</span> ((!left.equals(<span class="string">&quot;0&quot;</span>) &amp;&amp; left.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) || </span><br><span class="line">                    (!right.isEmpty() &amp;&amp; right.charAt(right.length() - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span> (right.isEmpty()) list.add(left);</span><br><span class="line">            <span class="keyword">else</span> list.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(left).</span><br><span class="line">            append(<span class="string">&quot;.&quot;</span>).append(right).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="使字符串平衡"><a href="#使字符串平衡" class="headerlink" title="使字符串平衡"></a>使字符串平衡</h3><blockquote>
<p>给你一个字符串 <code>s</code> ，它仅包含字符 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 。</p>
<p>你可以删除 <code>s</code> 中任意数目的字符，使得 <code>s</code> <strong>平衡</strong> 。当不存在下标对 <code>(i,j)</code> 满足 <code>i &lt; j</code> ，且 <code>s[i] = &#39;b&#39;</code> 的同时 <code>s[j]= &#39;a&#39;</code> ，此时认为 <code>s</code> 是 <strong>平衡</strong> 的。</p>
<p>请你返回使 <code>s</code> <strong>平衡</strong> 的 <strong>最少</strong> 删除次数。</p>
<p>LeetCode: 1653</p>
</blockquote>
<p><strong>模拟</strong></p>
<p>此题可以包含三种情况</p>
<ul>
<li>全是 a</li>
<li>全是 b</li>
<li>有 a 也有 b</li>
</ul>
<p>其实也就是比较三种情况的操作次数，找到最小值，从直观上来说，如果有 a 也有 b的话，操作数是最少的，所以前两种情况可以看为一种，来和情况 3 做对比。</p>
<p>所以就采用以下策略：找到一个分界点，将分界点左侧的 b 删掉，将分界点右侧的 a 删掉，我们需要找到最小的这个操作数分界点，于是从左往右遍历即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeletions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// leftb 是左边要删除的 b 的个数，righta 是右边要删除的 a 的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftb</span> <span class="operator">=</span> <span class="number">0</span>, righta = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 因为待会是从左往右遍历，所以先计算右边需要删除的a的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;a&#x27;</span>) righta++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> righta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                righta--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftb++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.min(res, leftb + righta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>- </p>
<p>上述方法有两个可以继续优化的点</p>
<ol>
<li>只需要记录右 a 的个数就好了，不需要记录左 b，一开始先记录0索引下右边所有的a的个数，然后开始遍历，遇到了 a，就将操作数减1，遇到了 b，就将删除操作数加1</li>
<li>用数学运算的方式取代 if else ，cpu 在执行if分支的时候会预测程序走哪个分支，如果走错了会重新开始走，所以减少 if分支会提高效率</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeletions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">del</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ss) del += <span class="string">&#x27;b&#x27;</span> - c;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> del;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ss) &#123;</span><br><span class="line">            <span class="comment">// 如果是 a 就减少删除操作次数，如果是 b 就增加删除操作次数</span></span><br><span class="line">            del += (c - <span class="string">&#x27;a&#x27;</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            res = Math.min(res, del);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>动态规划</strong></p>
<p>考虑 s 的最后一个字符</p>
<ul>
<li>如果它是 b,则无需操作，问题规模缩小，变成使前 n-1 个字符平衡的最小操作数</li>
<li>如果它是 a，则<ul>
<li>删掉它，使得操作数 +1</li>
<li>保留它，将这个 a 前面的 b 全部删除，</li>
</ul>
</li>
</ul>
<p>设 cntB 是前面 b 的总数，定义 f[i] 表示使前面 i 个字符平衡的最小删除次数</p>
<ul>
<li>如果 i 是 b，则 f[i] &#x3D; fi[i - 1]</li>
<li>如果是 a，则： f[i] &#x3D; Math.min(f[i - 1] + 1, cntB)</li>
</ul>
<p>其中 dp 数组可以用一个变量 f 来代替</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeletions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cntB</span> <span class="operator">=</span> <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;b&#x27;</span>) cntB++;</span><br><span class="line">            <span class="keyword">else</span> f = Math.min(f + <span class="number">1</span>, cntB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="困于环中的机器人"><a href="#困于环中的机器人" class="headerlink" title="困于环中的机器人"></a>困于环中的机器人</h3><blockquote>
<p>在无限的平面上，机器人最初位于 <code>(0, 0)</code> 处，面朝北方。注意:</p>
<ul>
<li><strong>北方向</strong> 是y轴的正方向。</li>
<li><strong>南方向</strong> 是y轴的负方向。</li>
<li><strong>东方向</strong> 是x轴的正方向。</li>
<li><strong>西方向</strong> 是x轴的负方向。</li>
</ul>
<p>机器人可以接受下列三条指令之一：</p>
<ul>
<li><code>&quot;G&quot;</code>：直走 1 个单位</li>
<li><code>&quot;L&quot;</code>：左转 90 度</li>
<li><code>&quot;R&quot;</code>：右转 90 度</li>
</ul>
<p>机器人按顺序执行指令 <code>instructions</code>，并一直重复它们。</p>
<p>只有在平面中存在环使得机器人永远无法离开时，返回 <code>true</code>。否则，返回 <code>false</code>。</p>
<p>LeetCode(1041)</p>
</blockquote>
<p><strong>方向模拟</strong></p>
<p>用一个二位矩阵模拟方向，然后用一个变量模拟方向<br>被困于环的条件：一次执行执行完后，坐标回到原点，或者方向不面对北</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRobotBounded</span><span class="params">(String instructions)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;; </span><br><span class="line">        <span class="comment">// 方向标志，初始向北</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">direcIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 坐标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; instructions.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> instructions.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                x += directions[direcIndex][<span class="number">0</span>];</span><br><span class="line">                y += directions[direcIndex][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                direcIndex += <span class="number">3</span>; <span class="comment">// 向左转意味着在原有方向基础上向西转</span></span><br><span class="line">                direcIndex %= <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                direcIndex += <span class="number">1</span>;</span><br><span class="line">                direcIndex %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行一串指令后不在原点且方向必须为北才不会陷入循环</span></span><br><span class="line">        <span class="keyword">return</span> direcIndex != <span class="number">0</span> || (x == <span class="number">0</span> &amp;&amp; y== <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="区间子数组个数"><a href="#区间子数组个数" class="headerlink" title="区间子数组个数"></a>区间子数组个数</h3><img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2022-11-24%2014.57.54.png" alt="截屏2022-11-24 14.57.54" style="zoom:50%;" />



<p><strong>双指针</strong></p>
<p>经分析可以发现，可以用两个变量last1 和 last2，last1指带上次出现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayBoundedMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last1</span> <span class="operator">=</span> -<span class="number">1</span>, last2 = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= right &amp;&amp; nums[i] &gt;= left) &#123;</span><br><span class="line">                last1 = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; right) &#123;</span><br><span class="line">                last2 = i;</span><br><span class="line">                last1 = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (last1 != -<span class="number">1</span>) &#123;</span><br><span class="line">                ans += last1 - last2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><blockquote>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p>LeetCode: 11 （hot 100）</p>
</blockquote>
<p><strong>双指针 + 贪心</strong></p>
<p>数组的每个元素相当于一个挡板，两个挡板组成的容器的面积是：(r - l) * Math.min(height[l], height[r])<br>此题使用双指针，从数组的两端开始，每次计算完当前挡板组成的面积后，移动高度较小的那个挡板<br>为什么移动高度较小的挡板是正确的？详见题解,仅从个人理解来说，高度较小的挡板是决定面积的关键性因素，移动较小的挡板是直观的，概率更大的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ans = Math.max(ans, (r - l) * Math.min(height[r], height[l]));</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><blockquote>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p>LeetCode : 15 (hot 100)</p>
</blockquote>
<p><strong>暴力</strong></p>
<p>此题主要难点在于如何去重，去重的第一步是将数组排序,并且，每次循环之前也要判断当前遍历的元素和之前遍历的是否相同<br>否则(1, 2,3,3)这样的就会被认为是两个三元组,暴力方法会超时，仅作为抛砖引玉的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == i + <span class="number">1</span> || nums[j] != nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; nums.length; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((k == j + <span class="number">1</span> || nums[k] != nums[k - <span class="number">1</span>])</span><br><span class="line">                            &amp;&amp; (nums[i] + nums[j] + nums[k] == <span class="number">0</span>)) &#123;</span><br><span class="line">                                List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                                cur.add(nums[i]);</span><br><span class="line">                                cur.add(nums[j]);</span><br><span class="line">                                cur.add(nums[k]);</span><br><span class="line">                                list.add(cur);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>双指针</strong></p>
<p>可以考虑固定 a、b指针，c指针从右向左遍历，这样若想 a + b + c &#x3D; 0,则只有唯一的 c 满足此等式，则 b指针在变大的过程中，c 向左遍历，当b &gt; c 时就没有遍历的必要了，重复了。<br><strong>这种固定两个找第三个的思路就是经典的双指针算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>; first &lt; n; first++) &#123;</span><br><span class="line">            <span class="comment">// first 指针判定合法性</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// third 指针不固定，每次从最右边来遍历</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[first];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; n; second++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保证second 在 third 指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">                    list.add(nums[first]);</span><br><span class="line">                    list.add(nums[second]);</span><br><span class="line">                    list.add(nums[third]);</span><br><span class="line">                    ans.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h3><blockquote>
<p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p>
<p>LeetCode 31(hot 100)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        1. 从后往前找到第一个升序数对 i，j</span></span><br><span class="line"><span class="comment">        2. 将 i 后看的排序，并找到第一个比 i 大的交换</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                Arrays.sort(nums, i, n);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[k] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i - <span class="number">1</span>];</span><br><span class="line">                        nums[i - <span class="number">1</span>] = nums[k];</span><br><span class="line">                        nums[k] = temp;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="分割两个字符串得回文串"><a href="#分割两个字符串得回文串" class="headerlink" title="分割两个字符串得回文串"></a>分割两个字符串得回文串</h3><blockquote>
<p>给你两个字符串 <code>a</code> 和 <code>b</code> ，它们长度相同。请你选择一个下标，将两个字符串都在 <strong>相同的下标</strong> 分割开。由 <code>a</code> 可以得到两个字符串： <code>aprefix</code> 和 <code>asuffix</code> ，满足 <code>a = aprefix + asuffix</code> ，同理，由 <code>b</code>可以得到两个字符串 <code>bprefix</code> 和 <code>bsuffix</code> ，满足 <code>b = bprefix + bsuffix</code> 。请你判断 <code>aprefix + bsuffix</code> 或者 <code>bprefix + asuffix</code> 能否构成回文串。</p>
<p>当你将一个字符串 <code>s</code> 分割成 <code>sprefix</code> 和 <code>ssuffix</code> 时， <code>ssuffix</code> 或者 <code>sprefix</code> 可以为空。比方说， <code>s = &quot;abc&quot;</code> 那么 <code>&quot;&quot; + &quot;abc&quot;</code> ， <code>&quot;a&quot; + &quot;bc&quot; </code>， <code>&quot;ab&quot; + &quot;c&quot;</code> 和 <code>&quot;abc&quot; + &quot;&quot;</code> 都是合法分割。</p>
<p>如果 <strong>能构成回文字符串</strong> ，那么请返回 <code>true</code>，否则返回 <code>false</code> 。</p>
<p><strong>注意</strong>， <code>x + y</code> 表示连接字符串 <code>x</code> 和 <code>y</code> 。</p>
<p>LeetCode(1616)</p>
</blockquote>
<p><strong>双指针+贪心</strong></p>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-03-18%2023.41.40.png" alt="截屏2023-03-18 23.41.40" style="zoom:50%;" />



<p>由上图可以看出：</p>
<ul>
<li>a 和 b 分割后能组成回文串其实就是，找到 a 和 b前后匹配的字符的位置，然后在看中间的 a 或 b 的字符串是不是回文</li>
<li>并且由贪心算法可知，a 和 b前后匹配的字符越长，中间是回文串的概率越大</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPalindromeFormation</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(a, b) || check(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针判断最长匹配</span></span><br><span class="line">    <span class="comment">// 从最长匹配开始（这里蕴含一个贪心算法，匹配的字符串越长，中间是回问串的概率越大）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; a.charAt(left) == b.charAt(right)) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isPalindrome(a, left, right) || isPalindrome(b, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是回文串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h3><blockquote>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<p>LeetCode(hot 100) 75</p>
</blockquote>
<p><strong>单指针 + 两次遍历</strong></p>
<p>使用一个指针表示当前交换元素的位置，然后遍历2次，第一次把所有的 0 换到数组前面去，第二次把 2 换到数组前面去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[idx];</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>双指针 + 一次遍历</strong></p>
<p>通过两个指针 p0 和 p1 来完成一次遍历的交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p1];</span><br><span class="line">                nums[p1] = temp;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p0];</span><br><span class="line">                nums[p0] = temp;</span><br><span class="line">                <span class="comment">// p0 &lt; p1 的话说明把 p0 换出来一定会导致 1 换出去</span></span><br><span class="line">                <span class="keyword">if</span> (p0 &lt; p1) &#123;</span><br><span class="line">                    temp = nums[i];</span><br><span class="line">                    nums[i] = nums[p1];</span><br><span class="line">                    nums[p1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                p0++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>双指针 + 一次遍历 优化</strong></p>
<p>很容易从方法二想到，每次交换的数组从0和1变成0和2，一头一尾<br>但是要注意几个问题，当 nums[i] 是2时，我们将其和p2交换，但是p2可能是0，也可能是2，但是如果是2，nums[i] 是交换结束后自加，再也不会考虑的，这就会导致一些问题，所以需要弄一个while循环，不断的去判断当前数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= p2; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= p2 &amp;&amp; nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p2];</span><br><span class="line">                nums[p2] = temp;</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p0];</span><br><span class="line">                nums[p0] = temp;</span><br><span class="line">                p0++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><blockquote>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p>LeetCode : 3 (hot 100)</p>
</blockquote>
<p><strong>滑动窗口：</strong><br>固定左窗口，不断右移右窗口，通过一个map判断字符有没有出现过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                left = Math.max(left, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, i);</span><br><span class="line">            max = Math.max(max, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h1 id="思维倒置"><a href="#思维倒置" class="headerlink" title="思维倒置"></a>思维倒置</h1><h2 id="反向操作"><a href="#反向操作" class="headerlink" title="反向操作"></a>反向操作</h2><h3 id="删除子文件夹"><a href="#删除子文件夹" class="headerlink" title="删除子文件夹"></a>删除子文件夹</h3><blockquote>
<p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p>
<p>如果文件夹 <code>folder[i]</code> 位于另一个文件夹 <code>folder[j]</code> 下，那么 <code>folder[i]</code> 就是 <code>folder[j]</code> 的 <strong>子文件夹</strong> 。</p>
<p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。</p>
<ul>
<li>例如，<code>&quot;/leetcode&quot;</code> 和 <code>&quot;/leetcode/problems&quot;</code> 都是有效的路径，而空字符串和 <code>&quot;/&quot;</code> 不是。</li>
</ul>
<p>LeetCode:1233</p>
</blockquote>
<p><strong>反向处理</strong></p>
<p>在遇到删除类的问题时，常常可以从相反的方向进行处理，比如这题如果想从正面处理，比较每个两两字符串，然后删除，难度较大，所以可以把符合条件的字符串加到新的集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeSubfolders</span><span class="params">(String[] folder)</span> &#123;</span><br><span class="line">        Arrays.sort(folder);</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ans.add(folder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; folder.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preStr</span> <span class="operator">=</span> ans.get(ans.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">preLength</span> <span class="operator">=</span> preStr.length();</span><br><span class="line">            <span class="keyword">if</span> (!(preLength &lt; folder[i].length() &amp;&amp; </span><br><span class="line">                preStr.equals(folder[i].substring(<span class="number">0</span>, preLength)) &amp;&amp;</span><br><span class="line">                folder[i].charAt(preLength) == <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        ans.add(folder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h1 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h1><hr>
<h2 id="简单数组操作"><a href="#简单数组操作" class="headerlink" title="简单数组操作"></a>简单数组操作</h2><h3 id="数组能形成多少数对"><a href="#数组能形成多少数对" class="headerlink" title="数组能形成多少数对"></a>数组能形成多少数对</h3><blockquote>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p>
<ul>
<li>从 <code>nums</code> 选出 <strong>两个</strong> <strong>相等的</strong> 整数</li>
<li>从 <code>nums</code> 中移除这两个整数，形成一个 <strong>数对</strong></li>
</ul>
<p>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</p>
<p>返回一个下标从 <strong>0</strong> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中 <code>answer[0]</code> 是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p>
</blockquote>
<p><strong>哈希</strong></p>
<p>虽然我一开始也考虑过用boolean来表示数字是否有数对，但是没想到这么优雅的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numberOfPairs(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">          <span class="comment">// true：可以成为数对</span></span><br><span class="line">            map.put(num, !map.getOrDefault(num, <span class="literal">false</span>));</span><br><span class="line">            <span class="keyword">if</span> (!map.get(num)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;ans, n - ans * <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>利用数组限制</strong></p>
<p>由于此题给定了数组元素的大小（&lt; 100）所以可以利用计数数组来做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numberOfPairs(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ++cnt[num];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += c / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ans, n - ans * <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="数组-排序"><a href="#数组-排序" class="headerlink" title="数组 + 排序"></a>数组 + 排序</h2><h3 id="按身高排序"><a href="#按身高排序" class="headerlink" title="按身高排序"></a>按身高排序</h3><blockquote>
<p>给你一个字符串数组 <code>names</code> ，和一个由 <strong>互不相同</strong> 的正整数组成的数组 <code>heights</code> 。两个数组的长度均为 <code>n</code> 。</p>
<p>对于每个下标 <code>i</code>，<code>names[i]</code> 和 <code>heights[i]</code> 表示第 <code>i</code> 个人的名字和身高。</p>
<p>请按身高 <strong>降序</strong> 顺序返回对应的名字数组 <code>names</code> 。</p>
<p>LeetCode 2418 (easy)</p>
</blockquote>
<p><strong>排序</strong></p>
<p>这题用 map 做是很简单的，这里提供一个小的新思路，就是用空间换时间，用一个等长数组来表示下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] sortPeople(String[] names, <span class="type">int</span>[] heights) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> names.length;</span><br><span class="line">       Integer[] indicates = <span class="keyword">new</span> <span class="title class_">Integer</span>[n];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           indicates[i] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       Arrays.sort(indicates, (a, b) -&gt; heights[b] - heights[a]);</span><br><span class="line">       String[] ans = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           ans[i] = names[indicates[i]];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><blockquote>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p>LeetCode(hot 100) 56</p>
</blockquote>
<p><strong>排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] intervals1, <span class="type">int</span>[] intervals2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> intervals1[<span class="number">0</span>] - intervals2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 当前区间不在已有的重合区间内</span></span><br><span class="line">            <span class="keyword">if</span> (merged.size() == <span class="number">0</span> || left &gt; merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>]) &#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = </span><br><span class="line">                    Math.max(right, merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="数组原地操作"><a href="#数组原地操作" class="headerlink" title="数组原地操作"></a>数组原地操作</h2><h3 id="找到数组中消失的数字"><a href="#找到数组中消失的数字" class="headerlink" title="找到数组中消失的数字"></a>找到数组中消失的数字</h3><blockquote>
<p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code>在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p>
<p> LeetCode 448 (hot 100)</p>
</blockquote>
<p><strong>鸽笼原理</strong></p>
<p>这题我先用了 set 来做辅助去重，然后又声明了一个长度为 n 的额外数组来做辅助，最后看了官方发现可以进行原地操作，只需要把数变到范围之外即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (num - <span class="number">1</span>) % n;</span><br><span class="line">            nums[x] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n) &#123;</span><br><span class="line">                ans.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="数组的改变和移动"><a href="#数组的改变和移动" class="headerlink" title="数组的改变和移动"></a>数组的改变和移动</h2><h3 id="最小操作次数使相等"><a href="#最小操作次数使相等" class="headerlink" title="最小操作次数使相等"></a>最小操作次数使相等</h3><blockquote>
<p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使 <code>n - 1</code> 个元素增加 <code>1</code> 。返回让数组所有元素相等的最小操作次数。</p>
<p>LeetCode 453 (medium)</p>
</blockquote>
<p><strong>反向考虑</strong></p>
<p>把题目反过来会很好想，这题只求操作数，说明数组元素的具体大小并不影响结果，影响结果的只是相对大小，而每次将 n - 1 个元素 +1也可以理解为将最大的那个唯一的元素 -1，这样就很简单了,我们只需要将数组中所有元素减小到最小值的操作数累加起来就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Arrays.stream(nums).min().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ans += num - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="按列翻转得到最大值的等行"><a href="#按列翻转得到最大值的等行" class="headerlink" title="按列翻转得到最大值的等行"></a>按列翻转得到最大值的等行</h3><blockquote>
<p>给定 <code>m x n</code> 矩阵 <code>matrix</code> 。</p>
<p>你可以从中选出任意数量的列并翻转其上的 <strong>每个</strong> 单元格。（即翻转后，单元格的值从 <code>0</code> 变成 <code>1</code>，或者从 <code>1</code>变为 <code>0</code> 。）</p>
<p>返回 <em>经过一些翻转后，行与行之间所有值都相等的最大行数</em> 。</p>
<p>LeetCode 1072 (medium)</p>
</blockquote>
<p><strong>思路</strong></p>
<p>刚拿到这题也不知道如何考虑，感觉很难，以为是动态规划，枚举翻转所有列的可能性找到相同行的最多的数量，但是明显不可能，难度太大，看了大神的思路后恍然大悟：假设 A 列和 B 列，我们进行列的反转之后，要想 A 和 B 同时达到行同的状态，那么 A 和 B 必须满足以下两种情况的任意一种：</p>
<ul>
<li>A、 B 相同：即 A &#x3D; 1 0 0 1 ， B &#x3D; 1 0 0 1</li>
<li>A 、B互补：即 A &#x3D; 1 0 0 1， B &#x3D; 0 1 1 0</li>
</ul>
<p>这样即可做到，那么我们就可以遍历矩阵，如果行是以 0 开头的，就不反转，1 开头的就反转，并加入 map，看看相同的字符串有几个，相同的字符串就是反转后可以同时达到行同的字符串数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEqualRowsAfterFlips</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] cur = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">            Arrays.fill(cur, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                cur[j] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + (matrix[i][j] ^ matrix[i][<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cur);</span><br><span class="line">            map.put(s, map.getOrDefault(s, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            max = Math.max(max, entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面这段代码思路相同，但是使用了 map 的 merge 方法，值得一看</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEqualRowsAfterFlips</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> row : matrix) &#123;</span><br><span class="line">            <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                cs[i] = (<span class="type">char</span>) (row[<span class="number">0</span>] ^ row[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, cnt.merge(String.valueOf(cs), <span class="number">1</span>, Integer::sum));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="二维矩阵"><a href="#二维矩阵" class="headerlink" title="二维矩阵"></a>二维矩阵</h2><h3 id="二进制矩阵最短通路"><a href="#二进制矩阵最短通路" class="headerlink" title="二进制矩阵最短通路"></a>二进制矩阵最短通路</h3><blockquote>
<p>leetcode 1091 (medium)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/EricsLei/ericsPics/img/%E6%88%AA%E5%B1%8F2023-05-26%2009.52.32.png" style="zoom:50%;">



<p><strong>BFS</strong></p>
<p>首先我们需要弄清楚在二维矩阵搜索时什么时候用 dfs，什么时候用 bfs？</p>
<ol>
<li>如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径；</li>
<li>如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathBinaryMatrix</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || grid[n - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 设置为1表明已经访问过</span></span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="comment">// res记录搜索的轮数，直到找到队列为空仍没到右下角，则返回 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>; !dq.isEmpty(); res++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> dq.size(); k &gt; <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="type">int</span>[] cur = dq.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur[<span class="number">0</span>], j = cur[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 当前元素是右下角，就直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不是右下角元素就将当前节点八个方向不为1的元素加入队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i - <span class="number">1</span>; x &lt;= i + <span class="number">1</span>; x++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j - <span class="number">1</span>; y &lt;= j + <span class="number">1</span>; y++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                            grid[x][y] = <span class="number">1</span>; <span class="comment">// 加入队列意味着访问，当前轮的其他路径可以不用多访问一次了</span></span><br><span class="line">                            dq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































<h1 id="动归-贪心"><a href="#动归-贪心" class="headerlink" title="动归+贪心"></a>动归+贪心</h1><hr>
<h2 id="范围覆盖问题"><a href="#范围覆盖问题" class="headerlink" title="范围覆盖问题"></a>范围覆盖问题</h2><h3 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h3><blockquote>
<p>题目描述：<br>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>假设你总是可以到达数组的最后一个位置。</p>
<p>leetcode：45</p>
</blockquote>
<p><strong>动态规划</strong></p>
<p>令 dp[i] 数组的含义是跳跃到 i 位置的最小跳跃次数<br>则，当我们在 i 时，我们可以跳到 dp[i] + i 的任意位置, 假设从 dp[i] 向前跳了 j 位置，则 dp[i + j] &#x3D; Math.min(dp[i + j], dp[i] + 1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// dp[i] 表示走到 i 位置的最小次数</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从头到尾遍历位置，并完成 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 每遍历到一个位置，就去比较一下该位置所能跳到的位置的 dp 数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                dp[i + j] = Math.min(dp[i + j], dp[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>贪心1. 巧妙的贪心策略</strong></p>
<p>这个贪心策略很巧妙，就是从最后一个元素开始往回推，看哪个元素能走到这里，往回推的策略就是一个巧妙的贪心–我们认为，靠左的元素的到达最后一个元素的步数更少。但这种方案时间复杂度较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                    position = i;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>贪心2. 正面推</strong></p>
<p>维护一个每次移动的边界以及最大距离，即可做到一次遍历得到结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 步数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 判断当前位置有没有到此次最大范围的边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDistance</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 可移动的最大距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            maxDistance = Math.max(maxDistance, i + nums[i]); <span class="comment">// 更新最大范围</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123; <span class="comment">// 如果移动范围已经到了更新前的距离边界，那就 步数++且更新end</span></span><br><span class="line">                ans++;</span><br><span class="line">                end = maxDistance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="灌溉花园的最少水龙头"><a href="#灌溉花园的最少水龙头" class="headerlink" title="灌溉花园的最少水龙头"></a>灌溉花园的最少水龙头</h3><blockquote>
<p>在 x 轴上有一个一维的花园。花园长度为 <code>n</code>，从点 <code>0</code> 开始，到点 <code>n</code> 结束。</p>
<p>花园里总共有 <code>n + 1</code> 个水龙头，分别位于 <code>[0, 1, ..., n]</code> 。</p>
<p>给你一个整数 <code>n</code> 和一个长度为 <code>n + 1</code> 的整数数组 <code>ranges</code> ，其中 <code>ranges[i]</code> （下标从 0 开始）表示：如果打开点 <code>i</code> 处的水龙头，可以灌溉的区域为 <code>[i - ranges[i], i + ranges[i]]</code> 。</p>
<p>请你返回可以灌溉整个花园的 <strong>最少水龙头数目</strong> 。如果花园始终存在无法灌溉到的地方，请你返回 <strong>-1</strong> 。</p>
<p>Leetcode: 1326</p>
</blockquote>
<p><strong>动态规划</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minTaps</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] ranges)</span> &#123;</span><br><span class="line">        <span class="comment">// 将rangs的区间算出来，并截取超出 0 到 n 范围的区间的超出部分</span></span><br><span class="line">        <span class="type">int</span>[][] intervals = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, i - ranges[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(n, i + ranges[i]);</span><br><span class="line">            intervals[i] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;start, end&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将区间从小到大排序（注：后面的lambda是默认的从小到大排序写法，但是必须得有）</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> interval[<span class="number">0</span>], end = interval[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[start] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[start] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h3 id="视频拼接"><a href="#视频拼接" class="headerlink" title="视频拼接"></a>视频拼接</h3><blockquote>
<p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 <code>time</code> 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p>
<p>使用数组 <code>clips</code> 描述所有的视频片段，其中 <code>clips[i] = [starti, endi]</code> 表示：某个视频片段开始于 <code>starti</code> 并于 <code>endi</code> 结束。</p>
<p>甚至可以对这些片段自由地再剪辑：</p>
<ul>
<li>例如，片段 <code>[0, 7]</code> 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。</li>
</ul>
<p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, time]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回 <code>-1</code> 。</p>
<p>leetcode：1024</p>
</blockquote>
<p><strong>动态规划</strong></p>
<p>当前选择的视频片段会对下一个选择的片段有影响，dp 的味道就来了。<br>令 dp[i] 表示将区间 [0, i) 覆盖所需要的最少视频片段的数量，我们通过枚举给定的time时间点来确定 dp 的状态转移方程，假设当前枚举到 i，那么对于第 j 个视频片段其覆盖的区间是 [aj , bj] ，如果 aj &lt;&#x3D; i &lt; bj，那么这个视频片段就可以覆盖 [0, i) 的后半部分，而前半部分可以用 dp[aj] 的对应的最优方法进行覆盖，这样 dp[j] &#x3D; dp[aj] + 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">videoStitching</span><span class="params">(<span class="type">int</span>[][] clips, <span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[time + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE - <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举所有的时间点，确定 dp 方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= time; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] clip : clips) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clip[<span class="number">0</span>] &lt; i &amp;&amp; i &lt;= clip[<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[clip[<span class="number">0</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[time] == Integer.MAX_VALUE - <span class="number">1</span> ? -<span class="number">1</span> : dp[time];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























]]></content>
  </entry>
</search>
